<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>中间件兴趣圈</title>
  
  <subtitle>关注微信公众号「中间件兴趣圈」，第一时间获取最新干货！</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-12-12T15:44:36.442Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>中间件兴趣圈</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>源码分析Dubbo集群容错策略</title>
    <link href="http://example.com/posts/b5542131.html"/>
    <id>http://example.com/posts/b5542131.html</id>
    <published>2020-12-12T15:38:01.000Z</published>
    <updated>2020-12-12T15:44:36.442Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>前面的文章，已经单独对服务发现(Directory、RegistryDirectory)、路由机制(Router)、负载均衡机制(LoadBalance),本节将重点分析集群容错机制(AbstractClusterInvoker) ,AbstractClusterInvoker 就是将上述机制融合在一起，整个集群容错中，上述组件扮演的角色见下图所示，本文将重点分析AbstractClusterInvoker是如何融合这些组件的。<img src="https://img-blog.csdn.net/20180708230808373?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>AbstractClusterInvoker#invoke</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public Result invoke(final Invocation invocation) throws RpcException &#123;</span><br><span class="line">        checkWhetherDestroyed();</span><br><span class="line">        LoadBalance loadbalance &#x3D; null;</span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invokers &#x3D; list(invocation);    &#x2F;&#x2F; @1</span><br><span class="line">        if (invokers !&#x3D; null &amp;&amp; !invokers.isEmpty()) &#123;</span><br><span class="line">            loadbalance &#x3D; ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(invokers.get(0).getUrl()</span><br><span class="line">                    .getMethodParameter(invocation.getMethodName(), Constants.LOADBALANCE_KEY, Constants.DEFAULT_LOADBALANCE));      &#x2F;&#x2F; @2</span><br><span class="line">        &#125;</span><br><span class="line">        RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);   </span><br><span class="line">        return doInvoke(invocation, invokers, loadbalance);  &#x2F;&#x2F; @3</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：根据调用上下文，获取服务提供者列表，服务提供者从Directory中获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) throws RpcException &#123;</span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invokers &#x3D; directory.list(invocation);</span><br><span class="line">        return invokers;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>最终会调用RegistryDirecotry的list方法，该方法的服务提供者是当该消费者订阅的服务的服务提供者列表发送变化后，会在注册中心产生事件，然后通知消费者更新服务提供者列表（本地缓存）。需要注意的是RegistryDirecotry在返回Invoker之前，已经使用Router进行了一次筛选，具体实现在RegistryDirectory#notify方法时。</p><p>代码@2：根据SPI机制，获取负载均衡算法的实现类,根据&lt; dubbo:consumer loadbalance=””/&gt;、&lt; dubbo:reference loadbalance=””/&gt;等标签的配置值，默认为random，加权随机算法。</p><p>代码@3：根据调用上下文，服务提供者列表，负载均衡算法选择一服务提供者，具体代码由AbstractClusterInvoker的各个子类实现。</p><a id="more"></a><p>Dubbo目前支持的集群容错策略在中/dubbo-cluster/src/main/resources/META-INF/dubbo/internal/com.alibaba.dubbo.rpc.cluster.Cluster定义，具体内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mock&#x3D;com.alibaba.dubbo.rpc.cluster.support.wrapper.MockClusterWrapper</span><br><span class="line">failover&#x3D;com.alibaba.dubbo.rpc.cluster.support.FailoverCluster</span><br><span class="line">failfast&#x3D;com.alibaba.dubbo.rpc.cluster.support.FailfastCluster</span><br><span class="line">failsafe&#x3D;com.alibaba.dubbo.rpc.cluster.support.FailsafeCluster</span><br><span class="line">failback&#x3D;com.alibaba.dubbo.rpc.cluster.support.FailbackCluster</span><br><span class="line">forking&#x3D;com.alibaba.dubbo.rpc.cluster.support.ForkingCluster</span><br><span class="line">available&#x3D;com.alibaba.dubbo.rpc.cluster.support.AvailableCluster</span><br><span class="line">mergeable&#x3D;com.alibaba.dubbo.rpc.cluster.support.MergeableCluster</span><br><span class="line">broadcast&#x3D;com.alibaba.dubbo.rpc.cluster.support.BroadcastCluster</span><br></pre></td></tr></table></figure><p>上述各种集群策略，对应的执行器为Cluser+Invoker,例如FailoverCluster对应的Invoker为：FailoverClusterInvoker。</p><p>在讲解各种集群容错策略之前，我们首先关注一下AbstractClusterInvoker具体从服务提供者中按照不同的负载均衡算法选取服务提供者的算法。</p><h2 id="1、源码分析AbstractClusterInvoker-select"><a href="#1、源码分析AbstractClusterInvoker-select" class="headerlink" title="1、源码分析AbstractClusterInvoker#select"></a>1、源码分析AbstractClusterInvoker#select</h2><p>AbstractClusterInvoker#select</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">protected Invoker&lt;T&gt; select(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected) throws </span><br><span class="line">        RpcException &#123;    &#x2F;&#x2F; @1</span><br><span class="line">    if (invokers &#x3D;&#x3D; null || invokers.isEmpty())</span><br><span class="line">         return null;</span><br><span class="line">    String methodName &#x3D; invocation &#x3D;&#x3D; null ? &quot;&quot; : invocation.getMethodName();</span><br><span class="line">    boolean sticky &#x3D; invokers.get(0).getUrl().getMethodParameter(methodName, Constants.CLUSTER_STICKY_KEY, </span><br><span class="line">                Constants.DEFAULT_CLUSTER_STICKY);     &#x2F;&#x2F; @2</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;ignore overloaded method</span><br><span class="line">            if (stickyInvoker !&#x3D; null &amp;&amp; !invokers.contains(stickyInvoker)) &#123;</span><br><span class="line">                stickyInvoker &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;ignore concurrency problem</span><br><span class="line">            if (sticky &amp;&amp; stickyInvoker !&#x3D; null &amp;&amp; (selected &#x3D;&#x3D; null || !selected.contains(stickyInvoker))) &#123;</span><br><span class="line">                if (availablecheck &amp;&amp; stickyInvoker.isAvailable()) &#123;</span><br><span class="line">                    return stickyInvoker;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Invoker&lt;T&gt; invoker &#x3D; doSelect(loadbalance, invocation, invokers, selected);   &#x2F;&#x2F; @3</span><br><span class="line"></span><br><span class="line">        if (sticky) &#123;</span><br><span class="line">            stickyInvoker &#x3D; invoker;</span><br><span class="line">        &#125;</span><br><span class="line">        return invoker;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：参数说明</p><ul><li>LoadBalance loadbalance：负载均衡算法。</li><li>Invocation invocation：服务调用上下文环境。</li><li>List&lt; Invoker&lt; T&gt;&gt; invokers：待选的服务提供者列表。</li><li>List&lt; Invoker&lt; T&gt;&gt; selected：本次集群测试，已选择的服务提供者。<br>代码@2：sticky机制（粘性），如果开启了粘性机制的话。通过&lt; dubbo:method sticky=”true”/&gt;,默认不开启。如果开启，上一次该服务调用的是哪个服务提供者，只要调用过程中不发生错误，后续都会选择该服务提供者进行调用。<br>代码@3：执行doSelect选择。</li></ul><h3 id="1-1-源码分析AbstractClusterInvoker-doSelect"><a href="#1-1-源码分析AbstractClusterInvoker-doSelect" class="headerlink" title="1.1 源码分析AbstractClusterInvoker#doSelect"></a>1.1 源码分析AbstractClusterInvoker#doSelect</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private Invoker&lt;T&gt; doSelect(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected) throws RpcException &#123;</span><br><span class="line">        if (invokers &#x3D;&#x3D; null || invokers.isEmpty())</span><br><span class="line">            return null;</span><br><span class="line">        if (invokers.size() &#x3D;&#x3D; 1)    &#x2F;&#x2F; @1</span><br><span class="line">            return invokers.get(0);</span><br><span class="line">        &#x2F;&#x2F; If we only have two invokers, use round-robin instead.</span><br><span class="line">        if (invokers.size() &#x3D;&#x3D; 2 &amp;&amp; selected !&#x3D; null &amp;&amp; !selected.isEmpty()) &#123;    &#x2F;&#x2F; @2</span><br><span class="line">            return selected.get(0) &#x3D;&#x3D; invokers.get(0) ? invokers.get(1) : invokers.get(0);</span><br><span class="line">        &#125;</span><br><span class="line">        if (loadbalance &#x3D;&#x3D; null) &#123;</span><br><span class="line">            loadbalance &#x3D; ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(Constants.DEFAULT_LOADBALANCE);</span><br><span class="line">        &#125;</span><br><span class="line">        Invoker&lt;T&gt; invoker &#x3D; loadbalance.select(invokers, getUrl(), invocation);    &#x2F;&#x2F; @3</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;If the &#96;invoker&#96; is in the  &#96;selected&#96; or invoker is unavailable &amp;&amp; availablecheck is true, reselect.</span><br><span class="line">        if ((selected !&#x3D; null &amp;&amp; selected.contains(invoker))</span><br><span class="line">                || (!invoker.isAvailable() &amp;&amp; getUrl() !&#x3D; null &amp;&amp; availablecheck)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Invoker&lt;T&gt; rinvoker &#x3D; reselect(loadbalance, invocation, invokers, selected, availablecheck);    &#x2F;&#x2F; @4</span><br><span class="line">                if (rinvoker !&#x3D; null) &#123;</span><br><span class="line">                    invoker &#x3D; rinvoker;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F;Check the index of current selected invoker, if it&#39;s not the last one, choose the one at index+1.</span><br><span class="line">                    int index &#x3D; invokers.indexOf(invoker);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        &#x2F;&#x2F;Avoid collision</span><br><span class="line">                        invoker &#x3D; index &lt; invokers.size() - 1 ? invokers.get(index + 1) : invoker;</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        logger.warn(e.getMessage() + &quot; may because invokers list dynamic change, ignore.&quot;, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                logger.error(&quot;cluster reselect fail reason is :&quot; + t.getMessage() + &quot; if can not solve, you can set cluster.availablecheck&#x3D;false in url&quot;, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return invoker;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果可选Invoker只有一个的话，直接返回该Invoker。<br>代码@2：如果只有两个Invoker，并且其中一个已被选择，返回另外一个未选择的Invoker。<br>代码@3：调用loadBalance负载均衡算法，选择一个服务提供者。<br>代码@4：如果选择的Invoker已被选择，则重新选择，这里有一个疑问，为什么不在选之前，先过滤掉已被选的Invoker。</p><p>从服务提供者列表中选择一个服务提供者算法就介绍到这里，接下来将一一分析Dubbo提供的集群容错方式。</p><h2 id="2、源码分析Dubbo集群策略"><a href="#2、源码分析Dubbo集群策略" class="headerlink" title="2、源码分析Dubbo集群策略"></a>2、源码分析Dubbo集群策略</h2><h3 id="2-1-源码分析FailoverClusterInvoker（FailoverCluster，dubbo默认策略）"><a href="#2-1-源码分析FailoverClusterInvoker（FailoverCluster，dubbo默认策略）" class="headerlink" title="2.1 源码分析FailoverClusterInvoker（FailoverCluster，dubbo默认策略）"></a>2.1 源码分析FailoverClusterInvoker（FailoverCluster，dubbo默认策略）</h3><p>策略：失败后自动选择其他服务提供者进行重试，重试次数由retries属性设置，&lt; dubbo:reference retries = “2”/&gt;设置，默认为2，代表重试2次，最多执行3次。</p><p>FailoverClusterInvoker#doInvoke</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public Result doInvoke(Invocation invocation, final List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance) throws RpcException &#123;</span><br><span class="line">      List&lt;Invoker&lt;T&gt;&gt; copyinvokers &#x3D; invokers;</span><br><span class="line">      checkInvokers(copyinvokers, invocation);</span><br><span class="line">      int len &#x3D; getUrl().getMethodParameter(invocation.getMethodName(), Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + 1;      &#x2F;&#x2F; @1</span><br><span class="line">      if (len &lt;&#x3D; 0) &#123;</span><br><span class="line">          len &#x3D; 1;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; retry loop.</span><br><span class="line">      RpcException le &#x3D; null; &#x2F;&#x2F; last exception.</span><br><span class="line">      List&lt;Invoker&lt;T&gt;&gt; invoked &#x3D; new ArrayList&lt;Invoker&lt;T&gt;&gt;(copyinvokers.size()); &#x2F;&#x2F; invoked invokers.</span><br><span class="line">      Set&lt;String&gt; providers &#x3D; new HashSet&lt;String&gt;(len);      &#x2F;&#x2F; @2</span><br><span class="line">      for (int i &#x3D; 0; i &lt; len; i++) &#123;   &#x2F;&#x2F; @3</span><br><span class="line">          &#x2F;&#x2F;Reselect before retry to avoid a change of candidate &#96;invokers&#96;.</span><br><span class="line">          &#x2F;&#x2F;NOTE: if &#96;invokers&#96; changed, then &#96;invoked&#96; also lose accuracy.</span><br><span class="line">          if (i &gt; 0) &#123;     &#x2F;&#x2F; @4</span><br><span class="line">              checkWhetherDestroyed();</span><br><span class="line">              copyinvokers &#x3D; list(invocation);</span><br><span class="line">              &#x2F;&#x2F; check again</span><br><span class="line">              checkInvokers(copyinvokers, invocation);</span><br><span class="line">          &#125;</span><br><span class="line">          Invoker&lt;T&gt; invoker &#x3D; select(loadbalance, invocation, copyinvokers, invoked);    &#x2F;&#x2F; @5</span><br><span class="line">          invoked.add(invoker);</span><br><span class="line">          RpcContext.getContext().setInvokers((List) invoked);</span><br><span class="line">          try &#123;</span><br><span class="line">              Result result &#x3D; invoker.invoke(invocation);                                                        &#x2F;&#x2F; @6</span><br><span class="line">              if (le !&#x3D; null &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">                  logger.warn(&quot;Although retry the method &quot; + invocation.getMethodName()</span><br><span class="line">                          + &quot; in the service &quot; + getInterface().getName()</span><br><span class="line">                          + &quot; was successful by the provider &quot; + invoker.getUrl().getAddress()</span><br><span class="line">                          + &quot;, but there have been failed providers &quot; + providers</span><br><span class="line">                          + &quot; (&quot; + providers.size() + &quot;&#x2F;&quot; + copyinvokers.size()</span><br><span class="line">                          + &quot;) from the registry &quot; + directory.getUrl().getAddress()</span><br><span class="line">                          + &quot; on the consumer &quot; + NetUtils.getLocalHost()</span><br><span class="line">                          + &quot; using the dubbo version &quot; + Version.getVersion() + &quot;. Last error is: &quot;</span><br><span class="line">                          + le.getMessage(), le);</span><br><span class="line">              &#125;</span><br><span class="line">              return result;</span><br><span class="line">          &#125; catch (RpcException e) &#123;</span><br><span class="line">              if (e.isBiz()) &#123; &#x2F;&#x2F; biz exception.</span><br><span class="line">                  throw e;</span><br><span class="line">              &#125;</span><br><span class="line">              le &#x3D; e;</span><br><span class="line">          &#125; catch (Throwable e) &#123;</span><br><span class="line">              le &#x3D; new RpcException(e.getMessage(), e);</span><br><span class="line">          &#125; finally &#123;</span><br><span class="line">              providers.add(invoker.getUrl().getAddress());       &#x2F;&#x2F; @7</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      throw new RpcException(le !&#x3D; null ? le.getCode() : 0, &quot;Failed to invoke the method &quot;</span><br><span class="line">              + invocation.getMethodName() + &quot; in the service &quot; + getInterface().getName()</span><br><span class="line">              + &quot;. Tried &quot; + len + &quot; times of the providers &quot; + providers</span><br><span class="line">              + &quot; (&quot; + providers.size() + &quot;&#x2F;&quot; + copyinvokers.size()</span><br><span class="line">              + &quot;) from the registry &quot; + directory.getUrl().getAddress()</span><br><span class="line">              + &quot; on the consumer &quot; + NetUtils.getLocalHost() + &quot; using the dubbo version &quot;</span><br><span class="line">              + Version.getVersion() + &quot;. Last error is: &quot;</span><br><span class="line">              + (le !&#x3D; null ? le.getMessage() : &quot;&quot;), le !&#x3D; null &amp;&amp; le.getCause() !&#x3D; null ? le.getCause() : le);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先校验服务提供者列表，如果为空，则抛出RpcException，提示没有可用的服务提供者。</p><p>代码@2：构建Set&lt; Stirng&gt; providers,主要用来已调用服务提供者的地址，如果本次调用失败，将在日志信息中打印已调用的服务提供者信息。</p><p>代码@3，循环执行次数，等于retries + 1 次。</p><p>代码@4：如果i&gt;0，表示服务调用，在重试，此时需要重新调用Directory#list方法，获取最小的服务提供者列表。</p><p>代码@5：根据负载均衡算法，选择Invoker，后续详细分析。</p><p>代码@6：根据负载算法，路由算法从服务提供者列表选一个服务提供者，发起RPC调用。</p><p>代码@7：将本次服务提供者的地址添加到providers集合中，如果多次重试后，无法完成正常的调用，将在错误日志中包含这些信息。</p><h3 id="2-2-源码分析AvailableClusterInvoker"><a href="#2-2-源码分析AvailableClusterInvoker" class="headerlink" title="2.2 源码分析AvailableClusterInvoker"></a>2.2 源码分析AvailableClusterInvoker</h3><p>策略：选择集群第一个可用的服务提供者。<br>缺点：相当于服务的主备，但同时只有一个服务提供者承载流量，并没有使用集群的负载均衡机制。<br>AvailableClusterInvoker#doInvoke</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Result doInvoke(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance) throws RpcException &#123;</span><br><span class="line">        for (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            if (invoker.isAvailable()) &#123;</span><br><span class="line">                return invoker.invoke(invocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new RpcException(&quot;No provider available in &quot; + invokers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历服务提供者列表，选择第一个可用服务提供者，然后执行RPC服务调用，如果调用失败，则失败。</p><h3 id="2-3-源码分析BroadcastClusterInvoker"><a href="#2-3-源码分析BroadcastClusterInvoker" class="headerlink" title="2.3 源码分析BroadcastClusterInvoker"></a>2.3 源码分析BroadcastClusterInvoker</h3><p>策略：广播调用，将调用所有服务提供者，一个服务调用者失败，并不会熔断，并且一个服务提供者调用失败，整个调用认为失败。<br>场景：刷新缓存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public Result doInvoke(final Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance) throws RpcException &#123;</span><br><span class="line">        checkInvokers(invokers, invocation);                                     &#x2F;&#x2F; @1</span><br><span class="line">        RpcContext.getContext().setInvokers((List) invokers);</span><br><span class="line">        RpcException exception &#x3D; null;</span><br><span class="line">        Result result &#x3D; null;</span><br><span class="line">        for (Invoker&lt;T&gt; invoker : invokers) &#123;   &#x2F;&#x2F; @2</span><br><span class="line">            try &#123;    </span><br><span class="line">                result &#x3D; invoker.invoke(invocation);</span><br><span class="line">            &#125; catch (RpcException e) &#123;</span><br><span class="line">                exception &#x3D; e;</span><br><span class="line">                logger.warn(e.getMessage(), e);</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                exception &#x3D; new RpcException(e.getMessage(), e);</span><br><span class="line">                logger.warn(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (exception !&#x3D; null) &#123;   &#x2F;&#x2F; @3</span><br><span class="line">            throw exception;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：检测服务提供者列表，如果为空，则抛出没有服务提供的异常。<br>代码@2：遍历服务提供者列表，依次调用服务提供者的invoker,每个服务调用用try catch语句包裹，当服务调用发生异常时，记录异常信息，但并不立即返回，广播模式，每个服务提供者调用是异步还是同步，取决服务调用的配置，默认是同步调用。<br>代码@3：只要其中一个服务调用发送一次，将抛出异常 信息，异常信息被封装为RpcException。</p><h3 id="2-4-源码分析FailbackClusterInvoker"><a href="#2-4-源码分析FailbackClusterInvoker" class="headerlink" title="2.4 源码分析FailbackClusterInvoker"></a>2.4 源码分析FailbackClusterInvoker</h3><p>策略：调用失败后，返回成功，但会在后台定时重试，重试次数（反复）<br>场景：通常用于消息通知，但消费者重启后，重试任务丢失。</p><p>FailbackClusterInvoker#doInvoke</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected Result doInvoke(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance) throws RpcException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            checkInvokers(invokers, invocation);  &#x2F;&#x2F; @1</span><br><span class="line">            Invoker&lt;T&gt; invoker &#x3D; select(loadbalance, invocation, invokers, null);   &#x2F;&#x2F; @2</span><br><span class="line">            return invoker.invoke(invocation);   &#x2F;&#x2F; @3</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            logger.error(&quot;Failback to invoke method &quot; + invocation.getMethodName() + &quot;, wait for retry in background. Ignored exception: &quot;</span><br><span class="line">                    + e.getMessage() + &quot;, &quot;, e);</span><br><span class="line">            addFailed(invocation, this);   &#x2F;&#x2F; @4</span><br><span class="line">            return new RpcResult(); &#x2F;&#x2F; ignore</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：校验服务提供者列表，如果为空，则抛出没有服务提供者错误。<br>代码@2：根据负载均衡机制，选择一个服务提供者。<br>代码@3：发起远程服务调用，如果出现异常，调用addFailed方法，添加重试任务，然后返回给调用方成功。</p><p>接下来看一下addFailed方法。</p><p>FailbackClusterInvoker#addFailed</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void addFailed(Invocation invocation, AbstractClusterInvoker&lt;?&gt; router) &#123;  &#x2F;&#x2F; @1 </span><br><span class="line">        if (retryFuture &#x3D;&#x3D; null) &#123;    &#x2F;&#x2F; @2</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                if (retryFuture &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    retryFuture &#x3D; scheduledExecutorService.scheduleWithFixedDelay(new Runnable() &#123;     &#x2F;&#x2F; @3</span><br><span class="line"></span><br><span class="line">                        @Override</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                            &#x2F;&#x2F; collect retry statistics</span><br><span class="line">                            try &#123;</span><br><span class="line">                                retryFailed();</span><br><span class="line">                            &#125; catch (Throwable t) &#123; &#x2F;&#x2F; Defensive fault tolerance</span><br><span class="line">                                logger.error(&quot;Unexpected error occur at collect statistic&quot;, t);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, RETRY_FAILED_PERIOD, RETRY_FAILED_PERIOD, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        failed.put(invocation, router);   &#x2F;&#x2F; @4</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：Invocation invocation：调用上下文；AbstractClusterInvoker&lt; ?&gt; router：调用集群策略。</p><p>代码@2：如果retryFuture（ScheduledFuture&lt; ?&gt; retryFuture）为空，则加锁创建一个定时调度任务，任务以每隔5s的频率调用retryFailed方法。</p><p>代码@3：添加重试任务（ConcurrentMap&lt; Invocation, AbstractClusterInvoker&lt; ?&gt;&gt; failed）。想必retryFailed方法就是遍历failed，一个一个重复调用，如果调用成功则移除，调用不成功，继续放入。</p><p>FailbackClusterInvoker#retryFailed</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void retryFailed() &#123;</span><br><span class="line">        if (failed.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (Map.Entry&lt;Invocation, AbstractClusterInvoker&lt;?&gt;&gt; entry : new HashMap&lt;Invocation, AbstractClusterInvoker&lt;?&gt;&gt;(    &#x2F;&#x2F; @1</span><br><span class="line">                failed).entrySet()) &#123;</span><br><span class="line">            Invocation invocation &#x3D; entry.getKey();</span><br><span class="line">            Invoker&lt;?&gt; invoker &#x3D; entry.getValue();</span><br><span class="line">            try &#123;</span><br><span class="line">                invoker.invoke(invocation);   &#x2F;&#x2F; @2</span><br><span class="line">                failed.remove(invocation);    &#x2F;&#x2F; @3</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                logger.error(&quot;Failed retry to invoke method &quot; + invocation.getMethodName() + &quot;, waiting again.&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：遍历待重试列表，然后发起远程调用，如果调用成功，则从集合中移除，如果只选失败，并不会从待重试列表中移除，也就是在消费端不重启的情况下，会一直重复调用，直到成功。</p><h3 id="2-5-源码分析FailfastClusterInvoker"><a href="#2-5-源码分析FailfastClusterInvoker" class="headerlink" title="2.5 源码分析FailfastClusterInvoker"></a>2.5 源码分析FailfastClusterInvoker</h3><p>策略：快速失败，服务调用失败后立马抛出异常，不进行重试。<br>场景：是否修改类服务（未实行幂等的服务调用）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public Result doInvoke(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance) throws RpcException &#123;</span><br><span class="line">        checkInvokers(invokers, invocation);     &#x2F;&#x2F; @1</span><br><span class="line">        Invoker&lt;T&gt; invoker &#x3D; select(loadbalance, invocation, invokers, null);   &#x2F;&#x2F; @2</span><br><span class="line">        try &#123;</span><br><span class="line">            return invoker.invoke(invocation);    &#x2F;&#x2F; @3</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            if (e instanceof RpcException &amp;&amp; ((RpcException) e).isBiz()) &#123; &#x2F;&#x2F; biz exception.</span><br><span class="line">                throw (RpcException) e;</span><br><span class="line">            &#125;</span><br><span class="line">            throw new RpcException(e instanceof RpcException ? ((RpcException) e).getCode() : 0, &quot;Failfast invoke providers &quot; + invoker.getUrl() + &quot; &quot; +   </span><br><span class="line">                 loadbalance.getClass().getSimpleName() + &quot; select from all providers &quot; + invokers + &quot; for service &quot; + getInterface().getName() + &quot; method &quot; + </span><br><span class="line">                 invocation.getMethodName() + &quot; on consumer &quot; + NetUtils.getLocalHost() + &quot; use dubbo version &quot; + Version.getVersion() + &quot;, but no luck to </span><br><span class="line">                 perform the invocation. Last error is: &quot; + e.getMessage(), e.getCause() !&#x3D; null ? e.getCause() : e);    &#x2F;&#x2F; @4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：检查服务提供者，如果服务提供者列表为空，抛出没有服务提供者错误。<br>代码@2：根据负载算法选择一个服务提供者。<br>代码@3：发起RPC服务调用。<br>代码@4：如果服务调用异常，抛出异常，打印服务消费者，服务提供者信息。</p><h3 id="2-6-源码分析FailsafeClusterInvoker"><a href="#2-6-源码分析FailsafeClusterInvoker" class="headerlink" title="2.6 源码分析FailsafeClusterInvoker"></a>2.6 源码分析FailsafeClusterInvoker</h3><p>策略：服务调用失败后，只打印错误日志，然后返回服务调用成功。<br>场景：调用审计，日志类服务接口。</p><p>FailsafeClusterInvoker#doInvoke</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Result doInvoke(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance) throws RpcException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            checkInvokers(invokers, invocation);   &#x2F;&#x2F; @1</span><br><span class="line">            Invoker&lt;T&gt; invoker &#x3D; select(loadbalance, invocation, invokers, null);  &#x2F;&#x2F; @2</span><br><span class="line">            return invoker.invoke(invocation);   &#x2F;&#x2F; @3</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            logger.error(&quot;Failsafe ignore exception: &quot; + e.getMessage(), e);</span><br><span class="line">            return new RpcResult(); &#x2F;&#x2F; ignore</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：检查服务提供者，如果服务提供者列表为空，抛出没有服务提供者错误。<br>代码@2：根据负载算法选择一个服务提供者。<br>代码@3：发起RPC服务调用，如果出现异常，记录错误堆栈信息，并返回成功。</p><h3 id="2-7-源码分析ForkingClusterInvoker"><a href="#2-7-源码分析ForkingClusterInvoker" class="headerlink" title="2.7 源码分析ForkingClusterInvoker"></a>2.7 源码分析ForkingClusterInvoker</h3><p>策略：并行调用多个服务提供者，当一个服务提供者返回成功，则返回成功。<br>场景：实时性要求比较高的场景，但浪费服务器资源，通常可以通过forks参数设置并发调用度。</p><p>ForkingClusterInvoker#doInvoke</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public Result doInvoke(final Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance) throws RpcException &#123;</span><br><span class="line">        checkInvokers(invokers, invocation);   &#x2F;&#x2F; @1</span><br><span class="line">        final List&lt;Invoker&lt;T&gt;&gt; selected;          </span><br><span class="line">        final int forks &#x3D; getUrl().getParameter(Constants.FORKS_KEY, Constants.DEFAULT_FORKS);              &#x2F;&#x2F; @2</span><br><span class="line">        final int timeout &#x3D; getUrl().getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">        if (forks &lt;&#x3D; 0 || forks &gt;&#x3D; invokers.size()) &#123;</span><br><span class="line">            selected &#x3D; invokers;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            selected &#x3D; new ArrayList&lt;Invoker&lt;T&gt;&gt;();</span><br><span class="line">            for (int i &#x3D; 0; i &lt; forks; i++) &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO. Add some comment here, refer chinese version for more details.</span><br><span class="line">                Invoker&lt;T&gt; invoker &#x3D; select(loadbalance, invocation, invokers, selected);</span><br><span class="line">                if (!selected.contains(invoker)) &#123;&#x2F;&#x2F;Avoid add the same invoker several times.</span><br><span class="line">                    selected.add(invoker);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        RpcContext.getContext().setInvokers((List) selected);</span><br><span class="line">        final AtomicInteger count &#x3D; new AtomicInteger();</span><br><span class="line">        final BlockingQueue&lt;Object&gt; ref &#x3D; new LinkedBlockingQueue&lt;Object&gt;();</span><br><span class="line">        for (final Invoker&lt;T&gt; invoker : selected) &#123;   &#x2F;&#x2F; @3</span><br><span class="line">            executor.execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Result result &#x3D; invoker.invoke(invocation);</span><br><span class="line">                        ref.offer(result);</span><br><span class="line">                    &#125; catch (Throwable e) &#123;</span><br><span class="line">                        int value &#x3D; count.incrementAndGet();</span><br><span class="line">                        if (value &gt;&#x3D; selected.size()) &#123;</span><br><span class="line">                            ref.offer(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            Object ret &#x3D; ref.poll(timeout, TimeUnit.MILLISECONDS);   &#x2F;&#x2F; @4</span><br><span class="line">            if (ret instanceof Throwable) &#123;</span><br><span class="line">                Throwable e &#x3D; (Throwable) ret;</span><br><span class="line">                throw new RpcException(e instanceof RpcException ? ((RpcException) e).getCode() : 0, &quot;Failed to forking invoke provider &quot; + selected + &quot;, but no luck to perform the invocation. Last error is: &quot; + e.getMessage(), e.getCause() !&#x3D; null ? e.getCause() : e);</span><br><span class="line">            &#125;</span><br><span class="line">            return (Result) ret;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            throw new RpcException(&quot;Failed to forking invoke provider &quot; + selected + &quot;, but no luck to perform the invocation. Last error is: &quot; + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：检查服务提供者，如果服务提供者列表为空，抛出没有服务提供者错误。</p><p>代码@2：获取forks属性，貌似只能通过在&lt; dubbo:reference /&gt;用&lt; dubbo:parameter key=”forks” value=””/&gt;来设置forks，其默认值为2，如果forks值大于服务提供者的数量，则将调用所有服务提供者，如果forks值小于服务提供者的数量，则使用负载均衡算法，选择forks个服务提供者。</p><p>代码@3：依次异步向服务提供者发起RPC调用，并将结果添加到BlockingQueue&lt; Object&gt; ref，如果服务调用发送错误，并且发生错误的个数大于等于本次调用的个数，则将错误信息放入BlockingQueue&lt; Object&gt; ref，否则，将错误数增加1。</p><p>代码@4：Object ret = ref.poll(timeout, TimeUnit.MILLISECONDS)，从该队列中获取结果，如果队列未空，则会阻塞等待，直到超时，当有一个调用成功后，将返回，忽略其他调用结果。</p><p>本文重点分析了Dubbo集群容错机制，路由发现、路由算法、负载均衡等是如何共同协作完成Dubbo的服务调用，并详细分析了Dubbo各种集群策略，例如failover、failfast、failsafe、failback、forking、available等实现细节。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面的文章，已经单独对服务发现(Directory、RegistryDirectory)、路由机制(Router)、负载均衡机制(LoadBalance),本节将重点分析集群容错机制(AbstractClusterInvoker) ,AbstractClusterInvoker 就是将上述机制融合在一起，整个集群容错中，上述组件扮演的角色见下图所示，本文将重点分析AbstractClusterInvoker是如何融合这些组件的。&lt;img src=&quot;https://img-blog.csdn.net/20180708230808373?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;AbstractClusterInvoker#invoke&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public Result invoke(final Invocation invocation) throws RpcException &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        checkWhetherDestroyed();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        LoadBalance loadbalance &amp;#x3D; null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers &amp;#x3D; list(invocation);    &amp;#x2F;&amp;#x2F; @1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (invokers !&amp;#x3D; null &amp;amp;&amp;amp; !invokers.isEmpty()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            loadbalance &amp;#x3D; ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(invokers.get(0).getUrl()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    .getMethodParameter(invocation.getMethodName(), Constants.LOADBALANCE_KEY, Constants.DEFAULT_LOADBALANCE));      &amp;#x2F;&amp;#x2F; @2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return doInvoke(invocation, invokers, loadbalance);  &amp;#x2F;&amp;#x2F; @3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码@1：根据调用上下文，获取服务提供者列表，服务提供者从Directory中获取。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;protected List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; list(Invocation invocation) throws RpcException &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers &amp;#x3D; directory.list(invocation);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return invokers;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最终会调用RegistryDirecotry的list方法，该方法的服务提供者是当该消费者订阅的服务的服务提供者列表发送变化后，会在注册中心产生事件，然后通知消费者更新服务提供者列表（本地缓存）。需要注意的是RegistryDirecotry在返回Invoker之前，已经使用Router进行了一次筛选，具体实现在RegistryDirectory#notify方法时。&lt;/p&gt;
&lt;p&gt;代码@2：根据SPI机制，获取负载均衡算法的实现类,根据&amp;lt; dubbo:consumer loadbalance=””/&amp;gt;、&amp;lt; dubbo:reference loadbalance=””/&amp;gt;等标签的配置值，默认为random，加权随机算法。&lt;/p&gt;
&lt;p&gt;代码@3：根据调用上下文，服务提供者列表，负载均衡算法选择一服务提供者，具体代码由AbstractClusterInvoker的各个子类实现。&lt;/p&gt;</summary>
    
    
    
    <category term="dubbo" scheme="http://example.com/categories/dubbo/"/>
    
    
    <category term="dubbo" scheme="http://example.com/tags/dubbo/"/>
    
    <category term="集群容错" scheme="http://example.com/tags/%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99/"/>
    
    <category term="failover" scheme="http://example.com/tags/failover/"/>
    
    <category term="failfast" scheme="http://example.com/tags/failfast/"/>
    
    <category term="failsafe" scheme="http://example.com/tags/failsafe/"/>
    
    <category term="failback" scheme="http://example.com/tags/failback/"/>
    
    <category term="forking" scheme="http://example.com/tags/forking/"/>
    
    <category term="available" scheme="http://example.com/tags/available/"/>
    
  </entry>
  
  <entry>
    <title>源码分析Dubbo负载算法</title>
    <link href="http://example.com/posts/398539d9.html"/>
    <id>http://example.com/posts/398539d9.html</id>
    <published>2020-12-12T15:31:01.000Z</published>
    <updated>2020-12-12T15:44:36.442Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>Dubbo支持在服务调用方对服务提供者采用负载均衡算法，LoadBalance 接口定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@SPI(RandomLoadBalance.NAME)</span><br><span class="line">public interface LoadBalance &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * select one invoker in list.</span><br><span class="line"> * </span><br><span class="line"> * @param invokers invokers.</span><br><span class="line"> * @param url refer url</span><br><span class="line"> * @param invocation invocation.</span><br><span class="line"> * @return selected invoker.</span><br><span class="line"> *&#x2F;</span><br><span class="line">    @Adaptive(&quot;loadbalance&quot;)</span><br><span class="line">&lt;T&gt; Invoker&lt;T&gt; select(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从中透露出如下几个信息：默认如果不配置，使用RandomLoadBalance策略(加权随机负载算法）。整个Dubbo的负载均衡类图如下所示：<br><img src="https://img-blog.csdn.net/20180706123312775?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>上述各种路由负载策略，对应的配置值如下：dubbo-cluster\src\main\resources\META-INF\dubbo\internal\com.alibaba.dubbo.rpc.cluster.LoadBalance</p><ul><li>random<br> random=com.alibaba.dubbo.rpc.cluster.loadbalance.RandomLoadBalance</li><li>roundrobin<br> roundrobin=com.alibaba.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance</li><li>leastactive<br> leastactive=com.alibaba.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance</li><li>consistenthash<br>consistenthash=com.alibaba.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance<br>其配置使用，通常一般在&lt; dubbo:consumer/&gt;、&lt; dubbo:service /&gt;、&lt; dubbo:reference /&gt;的loadbalance属性配置，通常&lt; dubbo:consumer/&gt;这个属性指定消费端的默认策略，某些服务需要指定特殊负载均衡策略的话，一般通过&lt; dubbo:reference /&gt;来指定。<br>如果各位对其源码实现比较有兴趣的话，可以看接下来的部分，源码分析各种负载算法的具体实现细节。</li></ul><h2 id="1、源码分析ConsistentHashLoadBalance（一致性Hash算法）"><a href="#1、源码分析ConsistentHashLoadBalance（一致性Hash算法）" class="headerlink" title="1、源码分析ConsistentHashLoadBalance（一致性Hash算法）"></a>1、源码分析ConsistentHashLoadBalance（一致性Hash算法）</h2><p><img src="https://img-blog.csdn.net/20180706123621108?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>一致Hash算法，通常用在缓存领域，主要解决的问题是当数据节点数量发送变化后，尽量减少数据的迁移，在负责算法领域，个人不建议使用。Dubbo一致性Hash算法的实现逻辑主要分布在ConsistentHashLoadBalance$ConsistentHashSelector中。</p><h3 id="1-1-核心属性与构造方法"><a href="#1-1-核心属性与构造方法" class="headerlink" title="1.1 核心属性与构造方法"></a>1.1 核心属性与构造方法</h3><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final TreeMap&lt;Long, Invoker&lt;T&gt;&gt; virtualInvokers;</span><br><span class="line">private final int                       replicaNumber;</span><br><span class="line">private final int                       identityHashCode;</span><br><span class="line">private final int[]                     argumentIndex;</span><br></pre></td></tr></table></figure><p>TreeMap&lt; Long, Invoker&lt; T&gt;&gt; virtualInvokers：虚拟节点，使用TreeMap实现Hash环，将Invoker分布在环上。</p><ul><li>int                       replicaNumber：虚拟节点个数。</li><li> int                       identityHashCode：HashCode。</li><li>int[]                     argumentIndex：需要参与hash的参数索引,,argumentIndex = [0,1]表示服务方法的第一个，第二个参数参与hashcode计算。<br>接下来看一下其构造方法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, int identityHashCode) &#123;</span><br><span class="line">    this.virtualInvokers &#x3D; new TreeMap&lt;Long, Invoker&lt;T&gt;&gt;();</span><br><span class="line">    this.identityHashCode &#x3D; System.identityHashCode(invokers);    &#x2F;&#x2F; @1</span><br><span class="line">    URL url &#x3D; invokers.get(0).getUrl();</span><br><span class="line">    this.replicaNumber &#x3D; url.getMethodParameter(methodName, &quot;hash.nodes&quot;, 160);   &#x2F;&#x2F; @2</span><br><span class="line">    String[] index &#x3D; Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, &quot;hash.arguments&quot;, &quot;0&quot;));   &#x2F;&#x2F; @3 start</span><br><span class="line">    argumentIndex &#x3D; new int[index.length];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; index.length; i ++) &#123;</span><br><span class="line">          argumentIndex[i] &#x3D; Integer.parseInt(index[i]);</span><br><span class="line">    &#125;  &#x2F;&#x2F; @3 end</span><br><span class="line">    for (Invoker&lt;T&gt; invoker : invokers) &#123;    &#x2F;&#x2F; @4</span><br><span class="line">         for (int i &#x3D; 0; i &lt; replicaNumber &#x2F; 4; i++) &#123;</span><br><span class="line">               byte[] digest &#x3D; md5(invoker.getUrl().toFullString() + i);</span><br><span class="line">               for (int h &#x3D; 0; h &lt; 4; h++) &#123; </span><br><span class="line">                     long m &#x3D; hash(digest, h);</span><br><span class="line">                     virtualInvokers.put(m, invoker);  </span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">      &#125; &#x2F;&#x2F; @4 end</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：根据所有的调用者生成一个HashCode，用该HashCode值来判断服务提供者是否发生了变化。</p><p>代码@2：获取服务提供者&lt; dubbo:method/&gt;标签的hash.nodes属性，如果为空，默认为160，表示一致性hash算法中虚拟节点数量。其配置方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt; dubbo:method ... &gt;</span><br><span class="line">    &lt; dubbo:parameter key&#x3D;&quot;hash.nodes&quot; value&#x3D;&quot;160&quot; &#x2F;&gt;</span><br><span class="line">    &lt; dubbo:parameter key&#x3D;&quot;hash.arguments&quot; value&#x3D;&quot;0,1&quot; &#x2F;&gt;</span><br><span class="line">&lt; &#x2F;dubbo:method&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>代码@3：一致性Hash算法，在dubbo中，相同的服务调用参数走固定的节点，hash.arguments表示哪些参数参与hashcode，默认值“0”，表示第一个参数。</p><p>代码@4：为每一个Invoker创建replicaNumber 个虚拟节点，每一个节点的Hashcode不同。同一个Invoker不同hashcode的创建逻辑为：invoker.getUrl().toFullString() + i (0-39) 的值，对其md5,然后用该值+h(0-3)的值取hash。一致性hash实现的一个关键是如果将一个Invoker创建的replicaNumber 个虚拟节点(hashcode)能够均匀分布在Hash环上，Dubbo给出的实现如下，由于能力有限，目前并未真正理解如下方法的实现依据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private long hash(byte[] digest, int number) &#123;</span><br><span class="line">            return (((long) (digest[3 + number * 4] &amp; 0xFF) &lt;&lt; 24)</span><br><span class="line">                    | ((long) (digest[2 + number * 4] &amp; 0xFF) &lt;&lt; 16)</span><br><span class="line">                    | ((long) (digest[1 + number * 4] &amp; 0xFF) &lt;&lt; 8)</span><br><span class="line">                    | (digest[number * 4] &amp; 0xFF))</span><br><span class="line">                    &amp; 0xFFFFFFFFL;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>综上所述，构造函数主要完成一致性Hash算法Hash环的构建，利用了TreeMap的有序性来实现。</p><h3 id="1-2-源码分析public-Invoker-lt-T-gt-select-Invocation-invocation"><a href="#1-2-源码分析public-Invoker-lt-T-gt-select-Invocation-invocation" class="headerlink" title="1.2 源码分析public Invoker&lt; T&gt; select(Invocation invocation)"></a>1.2 源码分析public Invoker&lt; T&gt; select(Invocation invocation)</h3><p>根据调用环境根据一致性Hash算法选择一个Invoker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Invoker&lt;T&gt; select(Invocation invocation) &#123;</span><br><span class="line">     String key &#x3D; toKey(invocation.getArguments());   &#x2F;&#x2F; @1</span><br><span class="line">     byte[] digest &#x3D; md5(key);                                      &#x2F;&#x2F; @2</span><br><span class="line">     return selectForKey(hash(digest, 0));                   &#x2F;&#x2F; @3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：根据调用参数，并根据hash.arguments配置值，获取指定的位置的参数值，追加一起返回。<br>代码@2：对Key进行md5签名。<br>代码@3：根据key进行选择调用者。</p><h4 id="1-2-1-ConsistentHashLoadBalance-ConsistentHashSelector-selectForKey"><a href="#1-2-1-ConsistentHashLoadBalance-ConsistentHashSelector-selectForKey" class="headerlink" title="1.2.1 ConsistentHashLoadBalance$ConsistentHashSelector#selectForKey"></a>1.2.1 ConsistentHashLoadBalance$ConsistentHashSelector#selectForKey</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Invoker&lt;T&gt; selectForKey(long hash) &#123;</span><br><span class="line">     Map.Entry&lt;Long, Invoker&lt;T&gt;&gt; entry &#x3D; virtualInvokers.tailMap(hash, true).firstEntry();    &#x2F;&#x2F; @1</span><br><span class="line">     if (entry &#x3D;&#x3D; null) &#123;    &#x2F;&#x2F; @2</span><br><span class="line">     entry &#x3D; virtualInvokers.firstEntry();</span><br><span class="line">     &#125;</span><br><span class="line">     return entry.getValue();   &#x2F;&#x2F; @3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1，对虚拟节点，从virtualInvokers中选取一个子集，subMap(hash,ture,lastKey,true),其实就是实现根据待查找hashcode(key)顺时针，选中大于等于指定key的第一个key。<br>代码@2，如果未找到，则返回virtualInvokers第一个key。<br>代码@3：根据key返回指定的Invoker即可。<br>这里实现，应该可以不使用tailMap，代码修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Invoker&lt;T&gt; selectForKey(long hash) &#123;</span><br><span class="line">     Map.Entry&lt;Long, Invoker&lt;T&gt;&gt; entry &#x3D; virtualInvokers.ceilingEntry(hash);</span><br><span class="line">     if(entry &#x3D;&#x3D; null ) &#123;</span><br><span class="line">     entry &#x3D; virtualInvokers.firstEntry();</span><br><span class="line">     &#125;</span><br><span class="line">     return entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要了解TreeMap关于这一块的特性(tailMap、ceillingEntry、headMap)等API的详细解释，可以查看我的另外一篇博文：<a href="https://blog.csdn.net/prestigeding/article/details/80821576">https://blog.csdn.net/prestigeding/article/details/80821576</a></p><h2 id="2、源码分析RandomLoadBalance"><a href="#2、源码分析RandomLoadBalance" class="headerlink" title="2、源码分析RandomLoadBalance"></a>2、源码分析RandomLoadBalance</h2><h3 id="2-1-Dubbo预热机制（权重）"><a href="#2-1-Dubbo预热机制（权重）" class="headerlink" title="2.1 Dubbo预热机制（权重）"></a>2.1 Dubbo预热机制（权重）</h3><p>由于roundrobin（加权轮询）、random（加权随机）、leastactive（最小活跃连接数）都与权重有关系，在介绍这两种负载均衡算法之前，我们首先看一下Dubbo关于权重的获取逻辑，代码见AbstractLoadBalance#getWeigh方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected int getWeight(Invoker&lt;?&gt; invoker, Invocation invocation) &#123;</span><br><span class="line">        int weight &#x3D; invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);   &#x2F;&#x2F; @1</span><br><span class="line">        if (weight &gt; 0) &#123;</span><br><span class="line">            long timestamp &#x3D; invoker.getUrl().getParameter(Constants.REMOTE_TIMESTAMP_KEY, 0L);  &#x2F;&#x2F; @2</span><br><span class="line">            if (timestamp &gt; 0L) &#123;</span><br><span class="line">                int uptime &#x3D; (int) (System.currentTimeMillis() - timestamp);</span><br><span class="line">                int warmup &#x3D; invoker.getUrl().getParameter(Constants.WARMUP_KEY, Constants.DEFAULT_WARMUP);  &#x2F;&#x2F; @3</span><br><span class="line">                if (uptime &gt; 0 &amp;&amp; uptime &lt; warmup) &#123;</span><br><span class="line">                    weight &#x3D; calculateWarmupWeight(uptime, warmup, weight);   &#x2F;&#x2F; @4</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return weight;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先获取服务提供者的权重(weight)。</p><p>代码@2：获取服务提供者的启动时间，在服务提供者启动时，会将启动时间戳存储在服务提供者的URL中，在服务发现(RegistryDirecotry)服务发现时，会将服务提供者的时间戳KEY，换成REMOTE_TIMESTAMP_KEY，避免与服务消费者的启动时间戳冲突。</p><p>代码@3：获取服务提供者是否开启预热机制，通过服务提供者&lt; dubbo:service warmup=””/&gt;参数来设置，如果未设置，去默认值10 * 60 * 1000（10分钟）。</p><p>代码@4：如果服务提供者启动时间小于预热时间（预热期间），需要根据启动时间，来计算预热期间服务提供者的权重。<br>AbstractLoadBalance#calculateWarmupWeight</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static int calculateWarmupWeight(int uptime, int warmup, int weight) &#123; &#x2F;&#x2F; @1</span><br><span class="line">        int ww &#x3D; (int) ((float) uptime &#x2F; ((float) warmup &#x2F; (float) weight));</span><br><span class="line">        return ww &lt; 1 ? 1 : (ww &gt; weight ? weight : ww);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：参数说明，uptime：服务提供者启动时间；warmup：设置的预热时间;weight：服务提供者的权重，该方法在uptime &lt; warmup时被调用<br>该方法的实现，就是在预热期间，根据启动时间，动态返回该服务提供者的权重，并且启动时间越长，返回的权重越接近weight，启动时间超过预热时间，则直接返回weight。<br>该方法单元测试：<br><img src="https://img-blog.csdn.net/20180706124209836?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>其输出结果：<br><img src="https://img-blog.csdn.net/20180706124240681?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h3 id="2-2-RandomLoadBalance-加权随机算法实现分析"><a href="#2-2-RandomLoadBalance-加权随机算法实现分析" class="headerlink" title="2.2 RandomLoadBalance 加权随机算法实现分析"></a>2.2 RandomLoadBalance 加权随机算法实现分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123;</span><br><span class="line">        int length &#x3D; invokers.size(); &#x2F;&#x2F; Number of invokers                    </span><br><span class="line">        int totalWeight &#x3D; 0; &#x2F;&#x2F; The sum of weights       &#x2F;&#x2F; @1 start</span><br><span class="line">        boolean sameWeight &#x3D; true; &#x2F;&#x2F; Every invoker has the same weight?</span><br><span class="line">        for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">            int weight &#x3D; getWeight(invokers.get(i), invocation);</span><br><span class="line">            totalWeight +&#x3D; weight; &#x2F;&#x2F; Sum</span><br><span class="line">            if (sameWeight &amp;&amp; i &gt; 0</span><br><span class="line">                    &amp;&amp; weight !&#x3D; getWeight(invokers.get(i - 1), invocation)) &#123;</span><br><span class="line">                sameWeight &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   &#x2F;&#x2F; @1 end</span><br><span class="line">        if (totalWeight &gt; 0 &amp;&amp; !sameWeight) &#123;    &#x2F;&#x2F; @2</span><br><span class="line">            &#x2F;&#x2F; If (not every invoker has the same weight &amp; at least one invoker&#39;s weight&gt;0), select randomly based on totalWeight.</span><br><span class="line">            int offset &#x3D; random.nextInt(totalWeight);</span><br><span class="line">            &#x2F;&#x2F; Return a invoker based on the random value.</span><br><span class="line">            for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">                offset -&#x3D; getWeight(invokers.get(i), invocation);</span><br><span class="line">                if (offset &lt; 0) &#123;</span><br><span class="line">                    return invokers.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; If all invokers have the same weight value or totalWeight&#x3D;0, return evenly.</span><br><span class="line">        return invokers.get(random.nextInt(length));  &#x2F;&#x2F; @3</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先求所有服务提供者的总权重，并判断每个服务提供者的权重是否相同。</p><p>代码@2：如果提供者之间的权重不相同，则产生一个随机数(0-totalWeight)，视为offset,然后依次用offset减去服务提供者的权重，如果减去(offset - provider.weight &lt; 0),则该invoker命中。</p><p>代码@3：如果服务提供者的权重相同，则随机产生[0-invoker.size)即可。</p><h3 id="2-3-RoundRobinLoadBalance-加权轮询算法分析"><a href="#2-3-RoundRobinLoadBalance-加权轮询算法分析" class="headerlink" title="2.3 RoundRobinLoadBalance 加权轮询算法分析"></a>2.3 RoundRobinLoadBalance 加权轮询算法分析</h3><p>加权轮询算法的核心算法是按权重轮询，一个基本点是应该是一个当前序号与服务提供者数量取模，需要结合权重。Dubbo使用如下数据结构存储当前序号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">private final ConcurrentMap&lt;String, AtomicPositiveInteger&gt; sequences &#x3D; new ConcurrentHashMap&lt;String, AtomicPositiveInteger&gt;();键值：serviceKey(&lt;dubbo:service interface&#x3D;&quot;&quot;&#x2F;&gt;+ methodname)，每个方法采用不同的计数器。</span><br><span class="line">RoundRobinLoadBalance #doSelect</span><br><span class="line">protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123;</span><br><span class="line">        String key &#x3D; invokers.get(0).getUrl().getServiceKey() + &quot;.&quot; + invocation.getMethodName();    &#x2F;&#x2F; @1</span><br><span class="line">        int length &#x3D; invokers.size(); &#x2F;&#x2F; Number of invokers</span><br><span class="line">        int maxWeight &#x3D; 0; &#x2F;&#x2F; The maximum weight</span><br><span class="line">        int minWeight &#x3D; Integer.MAX_VALUE; &#x2F;&#x2F; The minimum weight</span><br><span class="line">        final LinkedHashMap&lt;Invoker&lt;T&gt;, IntegerWrapper&gt; invokerToWeightMap &#x3D; new LinkedHashMap&lt;Invoker&lt;T&gt;, IntegerWrapper&gt;();   &#x2F;&#x2F; @2 start</span><br><span class="line">        int weightSum &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">            int weight &#x3D; getWeight(invokers.get(i), invocation);</span><br><span class="line">            maxWeight &#x3D; Math.max(maxWeight, weight); &#x2F;&#x2F; Choose the maximum weight</span><br><span class="line">            minWeight &#x3D; Math.min(minWeight, weight); &#x2F;&#x2F; Choose the minimum weight</span><br><span class="line">            if (weight &gt; 0) &#123;</span><br><span class="line">                invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));</span><br><span class="line">                weightSum +&#x3D; weight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   &#x2F;&#x2F; @2 end </span><br><span class="line">        AtomicPositiveInteger sequence &#x3D; sequences.get(key);</span><br><span class="line">        if (sequence &#x3D;&#x3D; null) &#123;</span><br><span class="line">            sequences.putIfAbsent(key, new AtomicPositiveInteger());</span><br><span class="line">            sequence &#x3D; sequences.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        int currentSequence &#x3D; sequence.getAndIncrement();    &#x2F;&#x2F; @3</span><br><span class="line">        if (maxWeight &gt; 0 &amp;&amp; minWeight &lt; maxWeight) &#123;   &#x2F;&#x2F; @4</span><br><span class="line">            int mod &#x3D; currentSequence % weightSum;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; maxWeight; i++) &#123;</span><br><span class="line">                for (Map.Entry&lt;Invoker&lt;T&gt;, IntegerWrapper&gt; each : invokerToWeightMap.entrySet()) &#123;</span><br><span class="line">                    final Invoker&lt;T&gt; k &#x3D; each.getKey();</span><br><span class="line">                    final IntegerWrapper v &#x3D; each.getValue();</span><br><span class="line">                    if (mod &#x3D;&#x3D; 0 &amp;&amp; v.getValue() &gt; 0) &#123;</span><br><span class="line">                        return k;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (v.getValue() &gt; 0) &#123;</span><br><span class="line">                        v.decrement();</span><br><span class="line">                        mod--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; Round robin</span><br><span class="line">        return invokers.get(currentSequence % length);   &#x2F;&#x2F; @5</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：构建ConcurrentMap&lt; String, AtomicPositiveInteger&gt; sequences中的key,以interface+methodname为键，里面存储的是当前序号（轮询）。</p><p>代码@2：构建LinkedHashMap&lt; Invoker&lt; T&gt;, IntegerWrapper&gt;存储结构，通过遍历所有Invoker，构建每个Invoker的权重，与此同时算出总权重，并且得出所有服务提供者权重是否相同。</p><p>代码@3：获取当前的轮询序号，用于取模。</p><p>代码@4：如果服务提供者之间的权重有差别，需要按权重轮询，实现方式是：</p><ul><li>用当前轮询序号与服务提供者总权重取模，余数为mod。</li><li>然后从0循环直到最大权重，针对每一次循环，按同一顺序遍历所有服务提供者，如果mod等于0并且对应的Invoker的权重计算器大于0，则选择该服务提供者；否则，mod–,invoker对应的权重减一，权重是临时比那里LinkedHashMap&lt; Invoker&lt; T&gt;, IntegerWrapper&gt;。由于外层循环的次数为所有服务提供者的最大权重，内层循环当mod等于0时，肯定会有一个服务提供者的权重计数器大于0,而返回对应的服务提供者。返回的服务提供者是第一个满足的服务提供者，后续的服务提供者在下一次就会有机会， 因为下一次mod会增大1，后续的服务提供者通过轮询会被选择，选择的机会，取决于权重的大小。</li></ul><p>代码@5：如果各服务提供者权重相同，则直接对服务提供者取模即可，轮询后递增。</p><h3 id="2-4-LeastActiveLoadBalance"><a href="#2-4-LeastActiveLoadBalance" class="headerlink" title="2.4 LeastActiveLoadBalance"></a>2.4 LeastActiveLoadBalance</h3><p>最少活跃连接数负载均衡算法分析，最小活跃连接数，其核心实现就是，首先找到服务提供者当前最小的活跃连接数，如果一个服务提供者的服务连接数比其他的都要小，则选择这个活跃连接数最小的服务提供者发起调用，如果存在多个服务提供者的活跃连接数，并且是最小的，则在这些服务提供者之间选择加权随机算法选择一个服务提供者。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123;</span><br><span class="line">        int length &#x3D; invokers.size(); &#x2F;&#x2F; Number of invokers                                                                                            &#x2F;&#x2F; @1 start</span><br><span class="line">        int leastActive &#x3D; -1; &#x2F;&#x2F; The least active value of all invokers</span><br><span class="line">        int leastCount &#x3D; 0; &#x2F;&#x2F; The number of invokers having the same least active value (leastActive)</span><br><span class="line">        int[] leastIndexs &#x3D; new int[length]; &#x2F;&#x2F; The index of invokers having the same least active value (leastActive)</span><br><span class="line">        int totalWeight &#x3D; 0; &#x2F;&#x2F; The sum of weights</span><br><span class="line">        int firstWeight &#x3D; 0; &#x2F;&#x2F; Initial value, used for comparision</span><br><span class="line">        boolean sameWeight &#x3D; true; &#x2F;&#x2F; Every invoker has the same weight value?                                                      &#x2F;&#x2F; @1 end</span><br><span class="line">        for (int i &#x3D; 0; i &lt; length; i++) &#123;                                                                                                                             &#x2F;&#x2F; @2 </span><br><span class="line">            Invoker&lt;T&gt; invoker &#x3D; invokers.get(i);</span><br><span class="line">            int active &#x3D; RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive(); &#x2F;&#x2F; Active number</span><br><span class="line">            int weight &#x3D; invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT); &#x2F;&#x2F;          </span><br><span class="line">                                                    &#x2F;&#x2F; Weight</span><br><span class="line">            if (leastActive &#x3D;&#x3D; -1 || active &lt; leastActive) &#123; &#x2F;&#x2F; Restart, when find a invoker having smaller least active value.              &#x2F;&#x2F; @3</span><br><span class="line">                leastActive &#x3D; active; &#x2F;&#x2F; Record the current least active value</span><br><span class="line">                leastCount &#x3D; 1; &#x2F;&#x2F; Reset leastCount, count again based on current leastCount</span><br><span class="line">                leastIndexs[0] &#x3D; i; &#x2F;&#x2F; Reset</span><br><span class="line">                totalWeight &#x3D; weight; &#x2F;&#x2F; Reset</span><br><span class="line">                firstWeight &#x3D; weight; &#x2F;&#x2F; Record the weight the first invoker</span><br><span class="line">                sameWeight &#x3D; true; &#x2F;&#x2F; Reset, every invoker has the same weight value?</span><br><span class="line">            &#125; else if (active &#x3D;&#x3D; leastActive) &#123; &#x2F;&#x2F; If current invoker&#39;s active value equals with leaseActive, then accumulating.       &#x2F;&#x2F; @4</span><br><span class="line">                leastIndexs[leastCount++] &#x3D; i; &#x2F;&#x2F; Record index number of this invoker</span><br><span class="line">                totalWeight +&#x3D; weight; &#x2F;&#x2F; Add this invoker&#39;s weight to totalWeight.</span><br><span class="line">                &#x2F;&#x2F; If every invoker has the same weight?</span><br><span class="line">                if (sameWeight &amp;&amp; i &gt; 0</span><br><span class="line">                        &amp;&amp; weight !&#x3D; firstWeight) &#123;</span><br><span class="line">                    sameWeight &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; assert(leastCount &gt; 0)</span><br><span class="line">        if (leastCount &#x3D;&#x3D; 1) &#123;     &#x2F;&#x2F; @5</span><br><span class="line">            &#x2F;&#x2F; If we got exactly one invoker having the least active value, return this invoker directly.</span><br><span class="line">            return invokers.get(leastIndexs[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!sameWeight &amp;&amp; totalWeight &gt; 0) &#123;    &#x2F;&#x2F; @6</span><br><span class="line">            &#x2F;&#x2F; If (not every invoker has the same weight &amp; at least one invoker&#39;s weight&gt;0), select randomly based on totalWeight.</span><br><span class="line">            int offsetWeight &#x3D; random.nextInt(totalWeight);</span><br><span class="line">            &#x2F;&#x2F; Return a invoker based on the random value.</span><br><span class="line">            for (int i &#x3D; 0; i &lt; leastCount; i++) &#123;</span><br><span class="line">                int leastIndex &#x3D; leastIndexs[i];</span><br><span class="line">                offsetWeight -&#x3D; getWeight(invokers.get(leastIndex), invocation);</span><br><span class="line">                if (offsetWeight &lt;&#x3D; 0)</span><br><span class="line">                    return invokers.get(leastIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; If all invokers have the same weight value or totalWeight&#x3D;0, return evenly.</span><br><span class="line">        return invokers.get(leastIndexs[random.nextInt(leastCount)]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：解释相关局部变量。</p><ul><li>length ：服务提供者数量。</li><li> leastActive ：服务提供者的最小活跃连接数，初始化为-1。</li><li>  leastCount ：服务提供者中都是活跃连接数的个数，例如，3个服务提供者当前的活跃连接数分别为 100,102,100,则leastCount 为2。</li><li> leastIndexs：存放拥有活跃连接数的Invoker索引，例如上面100,102,100,则leastIndexs[0]=0， leastIndexs[1] = 2；</li><li>  totalWeight：拥有最小活跃连接数的Invoker的总权重。</li><li>  firstWeight ：第一个最小活跃连接数的Invoker的权重。</li><li>  sameWeight ：拥有最小活跃连接数的Invoker权重是否相同。</li></ul><p>代码@2：遍历所有的服务提供者，计算上述变量的值。</p><p>代码@3：如果leastActive （最小活跃连接数为-1，表示第一次遍历）或最新连接数大于当前遍历的Invoker的活跃连接数,需要reset如下值，重新计算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">leastActive &#x3D; active; &#x2F;&#x2F; Record the current least active value</span><br><span class="line">leastCount &#x3D; 1; &#x2F;&#x2F; Reset leastCount, count again based on current leastCount leastIndexs[0] &#x3D; i; &#x2F;&#x2F; Reset</span><br><span class="line">totalWeight &#x3D; weight; &#x2F;&#x2F; Reset</span><br><span class="line">firstWeight &#x3D; weight; &#x2F;&#x2F; Record the weight the first invoker</span><br><span class="line">sameWeight &#x3D; true; &#x2F;&#x2F; Reset, every invoker has the same weight value?</span><br></pre></td></tr></table></figure><p>代码@4：如果当前遍历的服务提供者的活跃数等于leastActive ，则将总权重想加，并在leastIndexs中记录服务提供者序号。</p><p>代码@5，如果最小活跃连接数的服务提供者数量只有一个，则直接返回该服务提供者。</p><p>代码@6，如果最小活跃连接数的服务提供者有多个，则使用加权随机算法选取服务提供者。</p><p>关于Dubbo的4种负载均衡算法的实现细节就分析到这里了。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;Dubbo支持在服务调用方对服务提供者采用负载均衡算法，LoadBalance 接口定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@SPI(RandomLoadBalance.NAME)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public interface LoadBalance &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#x2F;**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 * select one invoker in list.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 * &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 * @param invokers invokers.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 * @param url refer url&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 * @param invocation invocation.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 * @return selected invoker.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 *&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Adaptive(&amp;quot;loadbalance&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; select(List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers, URL url, Invocation invocation) throws RpcException;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从中透露出如下几个信息：默认如果不配置，使用RandomLoadBalance策略(加权随机负载算法）。整个Dubbo的负载均衡类图如下所示：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180706123312775?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;上述各种路由负载策略，对应的配置值如下：dubbo-cluster\src\main\resources\META-INF\dubbo\internal\com.alibaba.dubbo.rpc.cluster.LoadBalance&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;random&lt;br&gt; random=com.alibaba.dubbo.rpc.cluster.loadbalance.RandomLoadBalance&lt;/li&gt;
&lt;li&gt;roundrobin&lt;br&gt; roundrobin=com.alibaba.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance&lt;/li&gt;
&lt;li&gt;leastactive&lt;br&gt; leastactive=com.alibaba.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance&lt;/li&gt;
&lt;li&gt;consistenthash&lt;br&gt;consistenthash=com.alibaba.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance&lt;br&gt;其配置使用，通常一般在&amp;lt; dubbo:consumer/&amp;gt;、&amp;lt; dubbo:service /&amp;gt;、&amp;lt; dubbo:reference /&amp;gt;的loadbalance属性配置，通常&amp;lt; dubbo:consumer/&amp;gt;这个属性指定消费端的默认策略，某些服务需要指定特殊负载均衡策略的话，一般通过&amp;lt; dubbo:reference /&amp;gt;来指定。&lt;br&gt;如果各位对其源码实现比较有兴趣的话，可以看接下来的部分，源码分析各种负载算法的具体实现细节。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1、源码分析ConsistentHashLoadBalance（一致性Hash算法）&quot;&gt;&lt;a href=&quot;#1、源码分析ConsistentHashLoadBalance（一致性Hash算法）&quot; class=&quot;headerlink&quot; title=&quot;1、源码分析ConsistentHashLoadBalance（一致性Hash算法）&quot;&gt;&lt;/a&gt;1、源码分析ConsistentHashLoadBalance（一致性Hash算法）&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180706123621108?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;一致Hash算法，通常用在缓存领域，主要解决的问题是当数据节点数量发送变化后，尽量减少数据的迁移，在负责算法领域，个人不建议使用。Dubbo一致性Hash算法的实现逻辑主要分布在ConsistentHashLoadBalance$ConsistentHashSelector中。&lt;/p&gt;
&lt;h3 id=&quot;1-1-核心属性与构造方法&quot;&gt;&lt;a href=&quot;#1-1-核心属性与构造方法&quot; class=&quot;headerlink&quot; title=&quot;1.1 核心属性与构造方法&quot;&gt;&lt;/a&gt;1.1 核心属性与构造方法&lt;/h3&gt;</summary>
    
    
    
    <category term="dubbo" scheme="http://example.com/categories/dubbo/"/>
    
    
    <category term="dubbo" scheme="http://example.com/tags/dubbo/"/>
    
    <category term="LoadBalance" scheme="http://example.com/tags/LoadBalance/"/>
    
    <category term="一致性Hash" scheme="http://example.com/tags/%E4%B8%80%E8%87%B4%E6%80%A7Hash/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo路由机制概述</title>
    <link href="http://example.com/posts/9d847bb5.html"/>
    <id>http://example.com/posts/9d847bb5.html</id>
    <published>2020-12-12T15:17:01.000Z</published>
    <updated>2020-12-12T15:44:36.432Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>上一节我们主要讲解了利用dubbo-admin如何进行参数的动态修改，本节将重点介绍集群实现中另外一个实现细节：路由机制，Dubbo的路由机制主要解决的目的就是服务调用时，从已知的所有服务提供者中根据路由规则刷选服务提供者。</p><h2 id="1、Dubbo路由机制概述"><a href="#1、Dubbo路由机制概述" class="headerlink" title="1、Dubbo路由机制概述"></a>1、Dubbo路由机制概述</h2><p>以下内容来源于官方文档：<br><img src="https://img-blog.csdn.net/20180628201426372?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180628201447412?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180628201509453?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/2018062820152941?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180628201547105?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>以上是Dubbo 路由机制的基本知识，接下来从源码的角度分析一下其实现原理。</p><a id="more"></a><h2 id="2、Router相关类图："><a href="#2、Router相关类图：" class="headerlink" title="2、Router相关类图："></a>2、Router相关类图：</h2><p><img src="https://img-blog.csdn.net/20180628201629305?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><ol><li>Router：dubbo路由接口类<br> ● URL getUrl() ：获取路由配置URL。<br> ● &lt; T&gt; List&lt; Invoker&lt; T&gt;&gt; route(List&lt; Invoker&lt; T&gt;&gt; invokers, URL url, Invocation invocation) ：根据路由规则返回符合规则的服务调用者。</li><li>ConditionRouter：条件路由规则。</li><li>ScriptRouter：脚本路由规则（JavaScript）。</li></ol><h3 id="2-1-如何添加路由规则"><a href="#2-1-如何添加路由规则" class="headerlink" title="2.1 如何添加路由规则"></a>2.1 如何添加路由规则</h3><p>可以通过dubbo-admin管理后台，动态添加路由规则，其界面如图所示：<br><img src="https://img-blog.csdn.net/20180628201726802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>点击保存后，使用URL描述一条路由规则，并将存储在注册中心${service}/routers目录下，然后通知相关订阅者（服务消费者【调用方】）。<br>具体调用的方法为RegistryDirecotry#notify方法，其片段如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; routers</span><br><span class="line">if (routerUrls !&#x3D; null &amp;&amp; !routerUrls.isEmpty()) &#123;  &#x2F;&#x2F; @1</span><br><span class="line">     List&lt;Router&gt; routers &#x3D; toRouters(routerUrls);     &#x2F;&#x2F; @2</span><br><span class="line">     if (routers !&#x3D; null) &#123; &#x2F;&#x2F; null - do nothing           </span><br><span class="line">          setRouters(routers);                                        &#x2F;&#x2F; @3</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1:如果routerUrls 不为空，说明注册中心的catalog=routers目录下新增或删除了某些路由规则，最后存在路由规则。<br>代码@2：将路由规则URL转换为路由实现类Router接口的实现类，例如条件路由规则、脚本路由规则具体实现类。<br>代码@3：将现存的路由规则实现类覆盖RegistroyDirectory#routers属性，在下一次服务调用时，这些路由规则将生效。</p><p>我们见到看一下toRouter方法的实现：</p><p>RegistryDirectory#toRouters</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;Router&gt; toRouters(List&lt;URL&gt; urls) &#123;</span><br><span class="line">        List&lt;Router&gt; routers &#x3D; new ArrayList&lt;Router&gt;();</span><br><span class="line">        if (urls &#x3D;&#x3D; null || urls.isEmpty()) &#123;</span><br><span class="line">            return routers;</span><br><span class="line">        &#125;</span><br><span class="line">        if (urls !&#x3D; null &amp;&amp; !urls.isEmpty()) &#123;</span><br><span class="line">            for (URL url : urls) &#123;</span><br><span class="line">                if (Constants.EMPTY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                String routerType &#x3D; url.getParameter(Constants.ROUTER_KEY);</span><br><span class="line">                if (routerType !&#x3D; null &amp;&amp; routerType.length() &gt; 0) &#123;</span><br><span class="line">                    url &#x3D; url.setProtocol(routerType);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Router router &#x3D; routerFactory.getRouter(url);</span><br><span class="line">                    if (!routers.contains(router))</span><br><span class="line">                        routers.add(router);</span><br><span class="line">                &#125; catch (Throwable t) &#123;</span><br><span class="line">                    logger.error(&quot;convert router url to router error, url: &quot; + url, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return routers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法实现比较简单，就是基于协议头condition://或script://构建具体的路由规则实现类。<br>从上面两个方法可以看出，当主从中心的路由配置发生变化后，会重新构建RegistryDirectory的List&lt; Router&gt; routers属性，那这个属性在什么时候用呢？</p><p>AbstractDirectory#list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) throws RpcException &#123;</span><br><span class="line">        if (destroyed) &#123;</span><br><span class="line">            throw new RpcException(&quot;Directory already destroyed .url: &quot; + getUrl());</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invokers &#x3D; doList(invocation);</span><br><span class="line">        List&lt;Router&gt; localRouters &#x3D; this.routers; &#x2F;&#x2F; local reference</span><br><span class="line">        if (localRouters !&#x3D; null &amp;&amp; !localRouters.isEmpty()) &#123;</span><br><span class="line">            for (Router router : localRouters) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (router.getUrl() &#x3D;&#x3D; null || router.getUrl().getParameter(Constants.RUNTIME_KEY, false)) &#123;</span><br><span class="line">                        invokers &#x3D; router.route(invokers, getConsumerUrl(), invocation);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Throwable t) &#123;</span><br><span class="line">                    logger.error(&quot;Failed to execute router: &quot; + getUrl() + &quot;, cause: &quot; + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return invokers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在通过RegistryDirector时，获取List&lt; Invoker&gt;时，会对所有的Invoker列表进行路由过滤，然后返回符合路由规则的Invoker，本文就不相信分析Dubbo是如何根据配置的条件路由规则、脚本路由规则去过滤，其实现细节，如有兴趣，可关注：ConditionRouter、ScriptRouter。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节我们主要讲解了利用dubbo-admin如何进行参数的动态修改，本节将重点介绍集群实现中另外一个实现细节：路由机制，Dubbo的路由机制主要解决的目的就是服务调用时，从已知的所有服务提供者中根据路由规则刷选服务提供者。&lt;/p&gt;
&lt;h2 id=&quot;1、Dubbo路由机制概述&quot;&gt;&lt;a href=&quot;#1、Dubbo路由机制概述&quot; class=&quot;headerlink&quot; title=&quot;1、Dubbo路由机制概述&quot;&gt;&lt;/a&gt;1、Dubbo路由机制概述&lt;/h2&gt;&lt;p&gt;以下内容来源于官方文档：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180628201426372?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180628201447412?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180628201509453?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://img-blog.csdn.net/2018062820152941?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180628201547105?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;以上是Dubbo 路由机制的基本知识，接下来从源码的角度分析一下其实现原理。&lt;/p&gt;</summary>
    
    
    
    <category term="dubbo" scheme="http://example.com/categories/dubbo/"/>
    
    
    <category term="dubbo" scheme="http://example.com/tags/dubbo/"/>
    
    <category term="路由机制" scheme="http://example.com/tags/%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6/"/>
    
    <category term="Router" scheme="http://example.com/tags/Router/"/>
    
    <category term="ConditionRouter" scheme="http://example.com/tags/ConditionRouter/"/>
    
    <category term="ScriptRouter" scheme="http://example.com/tags/ScriptRouter/"/>
    
  </entry>
  
  <entry>
    <title>源码分析Dubbo配置规则机制(override协议)</title>
    <link href="http://example.com/posts/a0fe1016.html"/>
    <id>http://example.com/posts/a0fe1016.html</id>
    <published>2020-12-12T15:14:01.000Z</published>
    <updated>2020-12-12T15:44:36.442Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>在上篇在讲解RegistryDirectory的时候，dubbo管理员可以通过dubbo-admin管理系统在线上修改dubbo服务提供者的参数，最终将存储在注册中心的configurators catalog，然后通知RegistryDirectory更新服务提供者的URL中相关属性，按照最新的配置，重新创建Invoker并销毁原来的Invoker。<br>有关官方文档关于动态改变配置(override协议）的详细描述如下：<br><img src="https://img-blog.csdn.net/20180624225822489?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/2018062422584447?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>dubbo-admin 管理后台，界面如下：<br><img src="https://img-blog.csdn.net/20180624225915334?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180624225933538?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><a id="more"></a><p>当Dubbo管理人员在上述界面，选择配置后点击保存，会构建override:// url存入到注册中心(configurators) catalog下，此时基于注册中心发现服务提供者的监听器(RegistryDirectory)会收到回调(notify)方法，接下来我们再来看一下RegistryDirectory#notify方法。</p><p>RegistryDirectory#notify</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void notify(List&lt;URL&gt; urls) &#123;        &#x2F;&#x2F; @1</span><br><span class="line">        List&lt;URL&gt; invokerUrls &#x3D; new ArrayList&lt;URL&gt;();</span><br><span class="line">        List&lt;URL&gt; routerUrls &#x3D; new ArrayList&lt;URL&gt;();</span><br><span class="line">        List&lt;URL&gt; configuratorUrls &#x3D; new ArrayList&lt;URL&gt;();</span><br><span class="line">        for (URL url : urls) &#123;</span><br><span class="line">            String protocol &#x3D; url.getProtocol();</span><br><span class="line">            String category &#x3D; url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br><span class="line">            if (Constants.ROUTERS_CATEGORY.equals(category) </span><br><span class="line">                    || Constants.ROUTE_PROTOCOL.equals(protocol)) &#123;</span><br><span class="line">                routerUrls.add(url);</span><br><span class="line">            &#125; else if (Constants.CONFIGURATORS_CATEGORY.equals(category) </span><br><span class="line">                    || Constants.OVERRIDE_PROTOCOL.equals(protocol)) &#123;</span><br><span class="line">                configuratorUrls.add(url);</span><br><span class="line">            &#125; else if (Constants.PROVIDERS_CATEGORY.equals(category)) &#123;</span><br><span class="line">                invokerUrls.add(url);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                logger.warn(&quot;Unsupported category &quot; + category + &quot; in notified url: &quot; + url + &quot; from registry &quot; + getUrl().getAddress() + &quot; to consumer &quot; + </span><br><span class="line">                     NetUtils.getLocalHost());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; configurators </span><br><span class="line">        if (configuratorUrls !&#x3D; null &amp;&amp; configuratorUrls.size() &gt;0 )&#123;       &#x2F;&#x2F; @2</span><br><span class="line">            this.configurators &#x3D; toConfigurators(configuratorUrls);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; routers</span><br><span class="line">        if (routerUrls !&#x3D; null &amp;&amp; routerUrls.size() &gt;0 )&#123;</span><br><span class="line">            List&lt;Router&gt; routers &#x3D; toRouters(routerUrls);</span><br><span class="line">            if(routers !&#x3D; null)&#123; &#x2F;&#x2F; null - do nothing</span><br><span class="line">                setRouters(routers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Configurator&gt; localConfigurators &#x3D; this.configurators; &#x2F;&#x2F; local reference</span><br><span class="line">        &#x2F;&#x2F; 合并override参数</span><br><span class="line">        this.overrideDirectoryUrl &#x3D; directoryUrl;</span><br><span class="line">        if (localConfigurators !&#x3D; null &amp;&amp; localConfigurators.size() &gt; 0) &#123;</span><br><span class="line">            for (Configurator configurator : localConfigurators) &#123;</span><br><span class="line">                this.overrideDirectoryUrl &#x3D; configurator.configure(overrideDirectoryUrl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; providers</span><br><span class="line">        refreshInvoker(invokerUrls);    &#x2F;&#x2F; @3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这个方法的实现在上一篇文章<a href="https://blog.csdn.net/prestigeding/article/details/80727275">《源码分析Dubbo服务发现机制(RegistryDirectory)》</a>中详细分析，故这里只列出与本文章相关的关注点：<br>代码@1：参数为当前configurators目录下所有的URL,例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urls: [override:&#x2F;&#x2F;0.0.0.0&#x2F;com.wuys.frame.api.service.IUserService?category&#x3D;configurators&amp;dynamic&#x3D;false&amp;enabled&#x3D;true&amp;timeout&#x3D;10000, override:&#x2F;&#x2F;0.0.0.0&#x2F;com.wuys.frame.api.service.IUserService?category&#x3D;configurators&amp;dynamic&#x3D;false&amp;enabled&#x3D;true&amp;weight&#x3D;200]。</span><br></pre></td></tr></table></figure><p>代码@2:将override url转换为List&lt; Configurator&gt;，是本节重点要讨论的内容。<br>代码@3：调用refreshInvoker方法，由于这里的invokerUrls为空，此时会对原先的invoker马上应用新的配置参数吗？带着这个疑问，我们先看一下refreshInvoker是如何处理的，然后回头重点分析代码@2的实现细节。<br>关于refreshInvoker的实现，在上一篇<a href="https://blog.csdn.net/prestigeding/article/details/80727275">源码分析Dubbo服务注册与发现机制RegistryDirectory)</a>中也详细分析过，这里只是为了求证一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (invokerUrls.size() &#x3D;&#x3D; 0 &amp;&amp; this.cachedInvokerUrls !&#x3D; null)&#123;</span><br><span class="line">       invokerUrls.addAll(this.cachedInvokerUrls);</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">      this.cachedInvokerUrls &#x3D; new HashSet&lt;URL&gt;();</span><br><span class="line">            this.cachedInvokerUrls.addAll(invokerUrls);&#x2F;&#x2F;缓存invokerUrls列表，便于交叉对比</span><br><span class="line">      &#125;</span><br><span class="line">     if (invokerUrls.size() &#x3D;&#x3D;0 )&#123;</span><br><span class="line">          return;</span><br><span class="line">     &#125;</span><br><span class="line">   &#x2F;&#x2F; 省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里看出，如果invokerUrls为空，如果已缓存的服务提供者不为空，则将已缓存的服务提供者加入到invokerUrls中，此时invokerUrls不为空，则会重新用新的配置生成新的invoker，然后销毁原先的invoker。</p><p>接下来重点分析Dubbo关于override协议的解析实现细节。</p><h2 id="1、dubbo关于override类图"><a href="#1、dubbo关于override类图" class="headerlink" title="1、dubbo关于override类图"></a>1、dubbo关于override类图</h2><p><img src="https://img-blog.csdn.net/20180624230247836?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><ol><li>Configurator：协议配置接口，主要抽象出两个接口方法：</li></ol><ul><li>URL getUrl()：获取配置URL。</li><li>URL configure(URL url)：根据configureUrl来配置 URL url。</li></ul><ol start="2"><li>AbstractConfigurator：协议配置抽象实现类（模板类）。</li><li>AbsentConfigurator：absent配置器，其策略是，如果configureUrl存在的属性，则不覆盖。</li><li>OverrideConfigurator：override配置器，其策略是，直接覆盖属性。</li></ol><h2 id="2、源码分析OverrideConfigurator实现原理"><a href="#2、源码分析OverrideConfigurator实现原理" class="headerlink" title="2、源码分析OverrideConfigurator实现原理"></a>2、源码分析OverrideConfigurator实现原理</h2><h3 id="2-1-源码分析AbstractConfigurator-configure"><a href="#2-1-源码分析AbstractConfigurator-configure" class="headerlink" title="2.1 源码分析AbstractConfigurator#configure"></a>2.1 源码分析AbstractConfigurator#configure</h3><p>AbstractConfigurator#configure</p><ol><li>Configurator：协议配置接口，主要抽象出两个接口方法：</li></ol><ul><li>URL getUrl()：获取配置URL。</li><li>URL configure(URL url)：根据configureUrl来配置 URL url。</li></ul><ol start="2"><li>AbstractConfigurator：协议配置抽象实现类（模板类）。</li><li>AbsentConfigurator：absent配置器，其策略是，如果configureUrl存在的属性，则不覆盖。</li><li>OverrideConfigurator：override配置器，其策略是，直接覆盖属性。</li></ol><h3 id="2-2-源码分析AbstractConfigurator-configure"><a href="#2-2-源码分析AbstractConfigurator-configure" class="headerlink" title="2.2 源码分析AbstractConfigurator#configure"></a>2.2 源码分析AbstractConfigurator#configure</h3><p>AbstractConfigurator#configure</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public URL configure(URL url) &#123;</span><br><span class="line">        if (configuratorUrl &#x3D;&#x3D; null || configuratorUrl.getHost() &#x3D;&#x3D; null</span><br><span class="line">                || url &#x3D;&#x3D; null || url.getHost() &#x3D;&#x3D; null) &#123;     &#x2F;&#x2F; @1</span><br><span class="line">            return url;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (configuratorUrl.getPort() !&#x3D; 0) &#123;          &#x2F;&#x2F;  @2</span><br><span class="line">            if (url.getPort() &#x3D;&#x3D; configuratorUrl.getPort()) &#123;</span><br><span class="line">                return configureIfMatch(url.getHost(), url);      &#x2F;&#x2F; @3</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (url.getParameter(Constants.SIDE_KEY, Constants.PROVIDER).equals(Constants.CONSUMER)) &#123;   &#x2F;&#x2F; @4</span><br><span class="line">                return configureIfMatch(NetUtils.getLocalHost(), url);&#x2F;&#x2F; NetUtils.getLocalHost is the ip address consumer registered to registry.</span><br><span class="line">            &#125; else if (url.getParameter(Constants.SIDE_KEY, Constants.CONSUMER).equals(Constants.PROVIDER)) &#123;   &#x2F;&#x2F; @5</span><br><span class="line">                return configureIfMatch(Constants.ANYHOST_VALUE, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return url;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果configuratorUrl (配置URL)为空host为空，或url为空或host为空，则返回url。这里参数的覆盖方向  configuratorUrl —-&gt; url。<br>代码@2：如果configuratorUrl如果端口不为空，则需要判断url的端口，端口必须相同，才执行configuratorUrl配置url。<br>代码@3，执行具体的配置操作，下文待分析。<br>代码@4、@5：如果端口为空，该配置URL(configuratorUrl)的类型要么是针对消费者，要么地址是0.0.0.0(任意)。</p><p>如果url属于服务消费者，host为消费者的注册IP地址，如果是服务提供者，则host为0.0.0.0来配置。</p><h3 id="2-3-源码分析AbstractConfigurator-configureIfMatch"><a href="#2-3-源码分析AbstractConfigurator-configureIfMatch" class="headerlink" title="2.3 源码分析AbstractConfigurator#configureIfMatch"></a>2.3 源码分析AbstractConfigurator#configureIfMatch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private URL configureIfMatch(String host, URL url) &#123;</span><br><span class="line">        if (Constants.ANYHOST_VALUE.equals(configuratorUrl.getHost()) || host.equals(configuratorUrl.getHost())) &#123;</span><br><span class="line">            String configApplication &#x3D; configuratorUrl.getParameter(Constants.APPLICATION_KEY,</span><br><span class="line">                    configuratorUrl.getUsername());</span><br><span class="line">            String currentApplication &#x3D; url.getParameter(Constants.APPLICATION_KEY, url.getUsername());</span><br><span class="line">            if (configApplication &#x3D;&#x3D; null || Constants.ANY_VALUE.equals(configApplication)</span><br><span class="line">                    || configApplication.equals(currentApplication)) &#123;</span><br><span class="line">                Set&lt;String&gt; condtionKeys &#x3D; new HashSet&lt;String&gt;();</span><br><span class="line">                condtionKeys.add(Constants.CATEGORY_KEY);</span><br><span class="line">                condtionKeys.add(Constants.CHECK_KEY);</span><br><span class="line">                condtionKeys.add(Constants.DYNAMIC_KEY);</span><br><span class="line">                condtionKeys.add(Constants.ENABLED_KEY);</span><br><span class="line">                for (Map.Entry&lt;String, String&gt; entry : configuratorUrl.getParameters().entrySet()) &#123;</span><br><span class="line">                    String key &#x3D; entry.getKey();</span><br><span class="line">                    String value &#x3D; entry.getValue();</span><br><span class="line">                    if (key.startsWith(&quot;~&quot;) || Constants.APPLICATION_KEY.equals(key) || Constants.SIDE_KEY.equals(key)) &#123;</span><br><span class="line">                        condtionKeys.add(key);</span><br><span class="line">                        if (value !&#x3D; null &amp;&amp; !Constants.ANY_VALUE.equals(value)</span><br><span class="line">                                &amp;&amp; !value.equals(url.getParameter(key.startsWith(&quot;~&quot;) ? key.substring(1) : key))) &#123;</span><br><span class="line">                            return url;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return doConfigure(url, configuratorUrl.removeParameters(condtionKeys));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return url;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法主要实现的功能就是排除不能动态修改的属性，不支持属性主要包括：category、check、dynamic、enabled、还有以<del>开头的属性，并且如果</del>开头的属性，配置URL与原URL的值不相同，则不使用该配置URL重写原URL。将配置URL(configuratorUrl)移除不支持属性后，调用其子类的doConfigure方法覆盖属性，Dubbo默认支持如下覆盖策略</p><ul><li>override 直接覆盖。</li><li>absent，如果原先存在该属性的配置，则以原先配置的属性值优先，如果原先没有配置该属性，则添加新的配置属性。</li></ul><p>总结一下：当在dubbo-admin(管理后台)中创建一条override规则后，会首先存储在注册中心（zookeeper的指定目录下${service}/configurators目录下，此时基于注册中心的事件机制，会通知相关监听者（服务消费者），服务消费者收到最新的配置时，会根据最新的配置重新构建Invoker对象，然后销毁原先的Invoker对象。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在上篇在讲解RegistryDirectory的时候，dubbo管理员可以通过dubbo-admin管理系统在线上修改dubbo服务提供者的参数，最终将存储在注册中心的configurators catalog，然后通知RegistryDirectory更新服务提供者的URL中相关属性，按照最新的配置，重新创建Invoker并销毁原来的Invoker。&lt;br&gt;有关官方文档关于动态改变配置(override协议）的详细描述如下：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180624225822489?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://img-blog.csdn.net/2018062422584447?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;dubbo-admin 管理后台，界面如下：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180624225915334?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180624225933538?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="dubbo" scheme="http://example.com/categories/dubbo/"/>
    
    
    <category term="dubbo" scheme="http://example.com/tags/dubbo/"/>
    
    <category term="override" scheme="http://example.com/tags/override/"/>
    
  </entry>
  
  <entry>
    <title>源码分析Dubbo服务注册与发现机制RegistryDirectory)</title>
    <link href="http://example.com/posts/7c2dea71.html"/>
    <id>http://example.com/posts/7c2dea71.html</id>
    <published>2020-12-12T15:03:01.000Z</published>
    <updated>2020-12-12T15:44:36.442Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>RegistryDirectory，基于注册中心的服务发现，本文将重点探讨Dubbo是如何实现服务的自动注册与发现。从上篇文章，得知在消息消费者在创建服务调用器(Invoker)【消费者在初始时】时需要根据不同的协议，例如dubbo、registry(从注册中心获取服务提供者)来构建，其调用的方法为Protocol#refer，基于注册中心发现服务提供者的实现协议为RegistryProtocol。</p><p>RegistryProtocol#refer —-&gt; doRefer方法。</p><p>RegistryProtocol#doRefer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private &lt;T&gt; Invoker&lt;T&gt; doRefer(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url) &#123;    &#x2F;&#x2F; @1</span><br><span class="line">        RegistryDirectory&lt;T&gt; directory &#x3D; new RegistryDirectory&lt;T&gt;(type, url);   &#x2F;&#x2F; @2</span><br><span class="line">        directory.setRegistry(registry);</span><br><span class="line">        directory.setProtocol(protocol);   &#x2F;&#x2F; @3</span><br><span class="line">        &#x2F;&#x2F; all attributes of REFER_KEY</span><br><span class="line">        Map&lt;String, String&gt; parameters &#x3D; new HashMap&lt;String, String&gt;(directory.getUrl().getParameters());   &#x2F;&#x2F; @4</span><br><span class="line">        URL subscribeUrl &#x3D; new URL(Constants.CONSUMER_PROTOCOL, parameters.remove(Constants.REGISTER_IP_KEY), 0, type.getName(), parameters);  &#x2F;&#x2F; @5</span><br><span class="line">        if (!Constants.ANY_VALUE.equals(url.getServiceInterface())</span><br><span class="line">                &amp;&amp; url.getParameter(Constants.REGISTER_KEY, true)) &#123;</span><br><span class="line">            registry.register(subscribeUrl.addParameters(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY,</span><br><span class="line">                    Constants.CHECK_KEY, String.valueOf(false)));</span><br><span class="line">        &#125;   &#x2F;&#x2F; @6</span><br><span class="line">        directory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY,</span><br><span class="line">                Constants.PROVIDERS_CATEGORY</span><br><span class="line">                        + &quot;,&quot; + Constants.CONFIGURATORS_CATEGORY</span><br><span class="line">                        + &quot;,&quot; + Constants.ROUTERS_CATEGORY));     &#x2F;&#x2F; @7</span><br><span class="line"></span><br><span class="line">        Invoker invoker &#x3D; cluster.join(directory);    &#x2F;&#x2F; @8</span><br><span class="line">        ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);     &#x2F;&#x2F; @9</span><br><span class="line">        return invoker;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：参数详解</p><ul><li>Cluster cluster：集群策略。</li><li> Registry registry：注册中心实现类。</li><li>Class<T> type：引用服务名，dubbo:reference interface。</li><li>URL url：注册中心URL。</li></ul><p>代码@2：构建RegistryDirectory对象，基于注册中心动态发现服务提供者（服务提供者新增或减少），本节重点会剖析该类的实现细节。</p><p>代码@3：为RegistryDirectory设置注册中心、协议。</p><p>代码@4：获取服务消费者的配置属性。</p><p>代码@5：构建消费者URL，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer:&#x2F;&#x2F;192.168.56.1&#x2F;com.alibaba.dubbo.demo.DemoService?application&#x3D;demo-consumer&amp;check&#x3D;false&amp;dubbo&#x3D;2.0.0&amp;interface&#x3D;com.alibaba.dubbo.demo.DemoService&amp;methods&#x3D;sayHello&amp;pid&#x3D;9892&amp;qos.port&#x3D;33333&amp;side&#x3D;consumer&amp;timestamp&#x3D;1528380277185</span><br></pre></td></tr></table></figure><p>代码@6：向注册中心消息消费者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer:&#x2F;&#x2F;192.168.56.1&#x2F;com.alibaba.dubbo.demo.DemoService?application&#x3D;demo-consumer&amp;category&#x3D;consumers&amp;check&#x3D;false&amp;dubbo&#x3D;2.0.0&amp;interface&#x3D;com.alibaba.dubbo.demo.DemoService&amp;methods&#x3D;sayHello&amp;pid&#x3D;9892&amp;qos.port&#x3D;33333&amp;side&#x3D;consumer&amp;timestamp&#x3D;1528380277185</span><br></pre></td></tr></table></figure><p>相比第5步的URL，增加了category=consumers、check=false，其中category表示在注册中心的命名空间，这里代表消费端。该步骤的作用就是向注册中心为服务增加一个消息消费者，其生成的效果如下：【以zookeeper为例】。<br><img src="https://img-blog.csdn.net/20180618220050346?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>代码@7：为消息消费者添加category=providers,configurators,routers属性后，然后向注册中心订阅该URL，关注该服务下的providers,configurators,routers发生变化时通知RegistryDirectory，以便及时发现服务提供者、配置、路由规则的变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer:&#x2F;&#x2F;192.168.56.1&#x2F;com.alibaba.dubbo.demo.DemoService?application&#x3D;demo-consumer&amp;category&#x3D;providers,configurators,routers&amp;check&#x3D;false&amp;dubbo&#x3D;2.0.0&amp;interface&#x3D;com.alibaba.dubbo.demo.DemoService&amp;methods&#x3D;sayHello&amp;pid&#x3D;9892&amp;qos.port&#x3D;33333&amp;side&#x3D;consumer&amp;timestamp&#x3D;1528380277185</span><br></pre></td></tr></table></figure><p>其订阅关系调用的入口为：RegistryDirectory#subscribe方法，是接下来需要重点分析的重点。</p><p>代码@8：根据Directory，利用集群策略返回集群Invoker。</p><p>代码@9：缓存服务消费者、服务提供者对应关系。</p><p>从这里发现，服务的注册与发现与RegistryDirectory联系非常紧密，接下来让我们来详细分析RegistryDirectory的实现细节。</p><h2 id="1、RegistryDirectory类图"><a href="#1、RegistryDirectory类图" class="headerlink" title="1、RegistryDirectory类图"></a>1、RegistryDirectory类图</h2><p><img src="https://img-blog.csdn.net/20180618223543475?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><ul><li>private static final Cluster cluster = ExtensionLoader.getExtensionLoader(Cluster.class).getAdaptiveExtension();<pre><code>集群策略，默认为failover。</code></pre></li><li>private static final RouterFactory routerFactory = ExtensionLoader.getExtensionLoader (RouterFactory.class).getAdaptiveExtension()路由工厂，可以通过监控中心或治理中心配置。</li><li>private static final ConfiguratorFactory configuratorFactory = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class).getAdaptiveExtension();配置实现工厂类。</li><li>private final String serviceKey;  服务key，默认为服务接口名。com.alibaba.dubbo.registry.RegistryService，注册中心在Dubbo中也是使用服务暴露。</li><li>private final Class&lt; T &gt; serviceType;服务提供者接口类，例如interface com.alibaba.dubbo.demo.DemoService</li><li>private final Map&lt; String, String&gt; queryMap：服务消费者URL中的所有属性。</li><li>private final URL directoryUrl;注册中心URL，只保留消息消费者URL查询属性，也就是queryMap。</li><li>private final String[] serviceMethods：引用服务提供者方法数组。</li><li>private final boolean multiGroup：是否引用多个服务组。</li><li>private Protocol protocol：协议。</li><li>private Registry registry：注册中心实现者。</li><li>private volatile List&lt; Configurator&gt; configurators;配置信息。</li><li>private volatile Map&lt; String, Invoker&lt; T&gt;&gt; urlInvokerMap; 服务URL对应的Invoker(服务提供者调用器)。</li><li>private volatile Map&lt; String, List&lt; Invoker&lt; T&gt;&gt;&gt; methodInvokerMap; methodName : List&lt; Invoker&lt; T &gt;&gt;，<pre><code>   dubbo:method 对应的Invoker缓存表。</code></pre></li><li>private volatile Set&lt; URL &gt; cachedInvokerUrls; 当前缓存的所有URL提供者URL。</li></ul><a id="more"></a><h2 id="2、RegistryDirectory-构造方法详解"><a href="#2、RegistryDirectory-构造方法详解" class="headerlink" title="2、RegistryDirectory 构造方法详解"></a>2、RegistryDirectory 构造方法详解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public RegistryDirectory(Class&lt;T&gt; serviceType, URL url) &#123;    &#x2F;&#x2F; @1</span><br><span class="line">        super(url);</span><br><span class="line">        if (serviceType &#x3D;&#x3D; null)</span><br><span class="line">            throw new IllegalArgumentException(&quot;service type is null.&quot;);</span><br><span class="line">        if (url.getServiceKey() &#x3D;&#x3D; null || url.getServiceKey().length() &#x3D;&#x3D; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;registry serviceKey is null.&quot;);</span><br><span class="line">        this.serviceType &#x3D; serviceType;  </span><br><span class="line">        this.serviceKey &#x3D; url.getServiceKey();     &#x2F;&#x2F; @2</span><br><span class="line">        this.queryMap &#x3D; StringUtils.parseQueryString(url.getParameterAndDecoded(Constants.REFER_KEY));  &#x2F;&#x2F; @3</span><br><span class="line">        this.overrideDirectoryUrl &#x3D; this.directoryUrl &#x3D; url.setPath(url.getServiceInterface()).clearParameters().addParameters(queryMap).removeParameter(Constants.MONITOR_KEY); &#x2F;&#x2F;@4</span><br><span class="line">        String group &#x3D; directoryUrl.getParameter(Constants.GROUP_KEY, &quot;&quot;);</span><br><span class="line">        this.multiGroup &#x3D; group !&#x3D; null &amp;&amp; (&quot;*&quot;.equals(group) || group.contains(&quot;,&quot;));</span><br><span class="line">        String methods &#x3D; queryMap.get(Constants.METHODS_KEY);</span><br><span class="line">        this.serviceMethods &#x3D; methods &#x3D;&#x3D; null ? null : Constants.COMMA_SPLIT_PATTERN.split(methods);   &#x2F;&#x2F; @5</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：参数描述，serviceType：消费者引用的服务&lt; dubbo:reference interface=”” …/&gt;;URL url：注册中心的URL，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper:&#x2F;&#x2F;127.0.0.1:2181&#x2F;com.alibaba.dubbo.registry.RegistryService?application&#x3D;demo-consumer&amp;dubbo&#x3D;2.0.0&amp;pid&#x3D;5552&amp;qos.port&#x3D;33333&amp;refer&#x3D;application%3Ddemo-consumer%26check%3Dfalse%26dubbo%3D2.0.0%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D5552%26qos.port%3D33333%26register.ip%3D192.168.56.1%26side%3Dconsumer%26timestamp%3D1528379076123&amp;timestamp&#x3D;1528379076179</span><br></pre></td></tr></table></figure><p>代码@2：获取注册中心URL的serviceKey：com.alibaba.dubbo.registry.RegistryService。</p><p>代码@3：获取注册中心URL消费提供者的所有配置参数:从url属性的refer。</p><p>代码@4：初始化haulovverrideDirecotryUrl、directoryUrl：注册中心的URL，移除监控中心以及其他属性值，只保留消息消费者的配置属性。</p><p>代码@5：获取服务消费者单独配置的方法名dubbo:method。</p><h2 id="3、RegistryDirectory-subscribe"><a href="#3、RegistryDirectory-subscribe" class="headerlink" title="3、RegistryDirectory#subscribe"></a>3、RegistryDirectory#subscribe</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void subscribe(URL url) &#123;</span><br><span class="line">     setConsumerUrl(url);   &#x2F;&#x2F; @1</span><br><span class="line">     registry.subscribe(url, this); &#x2F;&#x2F; @2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：设置RegistryDirectory的consumerUrl为消费者URL。<br>代码@2：调用注册中心订阅消息消息消费者URL，首先看一下接口Registry#subscribe的接口声明：<br>RegistryService:void subscribe(URL url, NotifyListener listener); 这里传入的NotifyListener为RegistryDirectory，其注册中心的subscribe方法暂时不深入去跟踪，不过根据上面URL上面的特点，应该能猜出如下实现关键点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer:&#x2F;&#x2F;192.168.56.1&#x2F;com.alibaba.dubbo.demo.DemoService?application&#x3D;demo-consumer&amp;category&#x3D;providers,configurators,routers&amp;check&#x3D;false&amp;dubbo&#x3D;2.0.0&amp;interface&#x3D;com.alibaba.dubbo.demo.DemoService&amp;methods&#x3D;sayHello&amp;pid&#x3D;9892&amp;qos.port&#x3D;33333&amp;side&#x3D;consumer&amp;timestamp&#x3D;1528380277185</span><br></pre></td></tr></table></figure><ul><li>根据消息消费者URL，获取服务名。</li><li>根据category=providers、configurators、routers，分别在该服务名下的providers目录、configurators目录、routers目录建立事件监听，监听该目录下节点的创建、更新、删除事件，然后一旦事件触发，将回调RegistryDirectory#void notify(List&lt; URL&gt; urls)。</li></ul><h2 id="4、RegistryDirectory-notify"><a href="#4、RegistryDirectory-notify" class="headerlink" title="4、RegistryDirectory#notify"></a>4、RegistryDirectory#notify</h2><p>首先该方法是在注册中心providers、configurators、routers目录下的节点发生变化后，通知RegistryDirectory，已便更新最新信息，实现”动态“发现机制。</p><p>RegistryDirectory#notify</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;URL&gt; invokerUrls &#x3D; new ArrayList&lt;URL&gt;();</span><br><span class="line">List&lt;URL&gt; routerUrls &#x3D; new ArrayList&lt;URL&gt;();</span><br><span class="line">List&lt;URL&gt; configuratorUrls &#x3D; new ArrayList&lt;URL&gt;();</span><br><span class="line">for (URL url : urls) &#123;</span><br><span class="line">     String protocol &#x3D; url.getProtocol();    &#x2F;&#x2F; @1 </span><br><span class="line">     String category &#x3D; url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);   &#x2F;&#x2F; @2</span><br><span class="line">     if (Constants.ROUTERS_CATEGORY.equals(category) || Constants.ROUTE_PROTOCOL.equals(protocol)) &#123;   &#x2F;&#x2F; @3</span><br><span class="line">           routerUrls.add(url);</span><br><span class="line">      &#125; else if (Constants.CONFIGURATORS_CATEGORY.equals(category) || Constants.OVERRIDE_PROTOCOL.equals(protocol)) &#123;   &#x2F;&#x2F; @4</span><br><span class="line">           configuratorUrls.add(url);</span><br><span class="line">     &#125; else if (Constants.PROVIDERS_CATEGORY.equals(category)) &#123;    &#x2F;&#x2F; @5</span><br><span class="line">           invokerUrls.add(url);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">          logger.warn(&quot;Unsupported category &quot; + category + &quot; in notified url: &quot; + url + &quot; from registry &quot; + getUrl().getAddress() + &quot; to consumer &quot; + </span><br><span class="line">                NetUtils.getLocalHost());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step1：根据通知的URL的前缀，分别添加到：invokerUrls(提供者url)、routerUrls（路由信息）、configuratorUrls （配置url）。</p><ul><li>代码@1：从url中获取协议字段，例如condition://、route://、script://、override://等。</li><li>代码@2：获取url的category,在注册中心的命令空间，例如:providers、configurators、routers。</li><li>代码@3：如果category等于routers或协议等于route，则添加到routerUrls中。</li><li>代码@4：如果category等于configurators或协议等于override，则添加到configuratorUrls中。</li><li>代码@5：如果category等于providers，则表示服务提供者url，加入到invokerUrls中。</li></ul><p>RegistryDirectory#notify</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; configurators</span><br><span class="line">if (configuratorUrls !&#x3D; null &amp;&amp; !configuratorUrls.isEmpty()) &#123;</span><br><span class="line">    this.configurators &#x3D; toConfigurators(configuratorUrls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step2：将configuratorUrls转换为配置对象List&lt; Configurator&gt; configurators，该方法将在《源码分析Dubbo配置规则实现细节》一文中详细讲解。</p><p>RegistryDirectory#notify</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; routers</span><br><span class="line">if (routerUrls !&#x3D; null &amp;&amp; !routerUrls.isEmpty()) &#123;</span><br><span class="line">      List&lt;Router&gt; routers &#x3D; toRouters(routerUrls);</span><br><span class="line">      if (routers !&#x3D; null) &#123; &#x2F;&#x2F; null - do nothing</span><br><span class="line">            setRouters(routers);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step3：将routerUrls路由URL转换为Router对象，该部分内容将在《源码分析Dubbo路由机制实现细节》一文中详细分析。</p><p>RegistryDirectory#notify</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; providers</span><br><span class="line">refreshInvoker(invokerUrls);</span><br></pre></td></tr></table></figure><p>Step4：根据回调通知刷新服务提供者集合。</p><h2 id="5、RegistryDirectory-refreshInvoker"><a href="#5、RegistryDirectory-refreshInvoker" class="headerlink" title="5、RegistryDirectory#refreshInvoker"></a>5、RegistryDirectory#refreshInvoker</h2><p>RegistryDirectory#refreshInvoker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (invokerUrls !&#x3D; null &amp;&amp; invokerUrls.size() &#x3D;&#x3D; 1 &amp;&amp; invokerUrls.get(0) !&#x3D; null</span><br><span class="line">         &amp;&amp; Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) &#123;</span><br><span class="line">     this.forbidden &#x3D; true; &#x2F;&#x2F; Forbid to access</span><br><span class="line">     this.methodInvokerMap &#x3D; null; &#x2F;&#x2F; Set the method invoker map to null</span><br><span class="line">     destroyAllInvokers(); &#x2F;&#x2F; Close all invokers</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>Step1：如果invokerUrls不为空并且长度为1，并且协议为empty,表示该服务的所有服务提供者都下线了。需要销毁当前所有的服务提供者Invoker。</p><p>RegistryDirectory#refreshInvoker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">this.forbidden &#x3D; false; &#x2F;&#x2F; Allow to access</span><br><span class="line">Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap &#x3D; this.urlInvokerMap; &#x2F;&#x2F; local reference</span><br><span class="line">if (invokerUrls.isEmpty() &amp;&amp; this.cachedInvokerUrls !&#x3D; null) &#123;</span><br><span class="line">        invokerUrls.addAll(this.cachedInvokerUrls);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">      this.cachedInvokerUrls &#x3D; new HashSet&lt;URL&gt;();</span><br><span class="line">      this.cachedInvokerUrls.addAll(invokerUrls);&#x2F;&#x2F;Cached invoker urls, convenient for comparison</span><br><span class="line">&#125;</span><br><span class="line">if (invokerUrls.isEmpty()) &#123;</span><br><span class="line">      return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step2： 如果invokerUrls为空，并且已缓存的invokerUrls不为空，将缓存中的invoker url复制到invokerUrls中，这里可以说明如果providers目录未发送变化，invokerUrls则为空，表示使用上次缓存的服务提供者URL对应的invoker；如果invokerUrls不为空，则用iinvokerUrls中的值替换原缓存的invokerUrls，这里说明，如果providers发生变化，invokerUrls中会包含此时注册中心所有的服务提供者。如果invokerUrls为空，则无需处理，结束本次更新服务提供者Invoker操作。</p><p>RegistryDirectory#refreshInvoker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap &#x3D; toInvokers(invokerUrls);&#x2F;&#x2F; Translate url list to Invoker map</span><br><span class="line">Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; newMethodInvokerMap &#x3D; toMethodInvokers(newUrlInvokerMap); &#x2F;&#x2F; Change method name to map Invoker Map</span><br></pre></td></tr></table></figure><p>Step3：将invokerUrls转换为对应的Invoke，然后根据服务级的url:invoker映射关系创建method:List&lt; Invoker&gt;映射关系，将在下文相信分析。</p><p>RegistryDirectory#refreshInvoker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">this.methodInvokerMap &#x3D; multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;</span><br><span class="line">this.urlInvokerMap &#x3D; newUrlInvokerMap;</span><br><span class="line">try &#123;</span><br><span class="line">        destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); &#x2F;&#x2F; Close the unused Invoker</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">        logger.warn(&quot;destroyUnusedInvokers error. &quot;, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step4：如果支持multiGroup机制，则合并methodInvoker，将在下文分析，然后根据toInvokers、toMethodInvokers刷新当前最新的服务提供者信息。</p><h2 id="6、RegistryDirectory-toInvokers"><a href="#6、RegistryDirectory-toInvokers" class="headerlink" title="6、RegistryDirectory#toInvokers"></a>6、RegistryDirectory#toInvokers</h2><p>RegistryDirectory#toInvokers</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String queryProtocols &#x3D; this.queryMap.get(Constants.PROTOCOL_KEY);</span><br><span class="line">for (URL providerUrl : urls) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step1：获取消息消费者URL中的协议类型，&lt; dubbo:reference protocol=”” …/&gt;属性值，然后遍历所有的Invoker Url(服务提供者URL)。</p><p>RegistryDirectory#toInvokers</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (queryProtocols !&#x3D; null &amp;&amp; queryProtocols.length() &gt; 0) &#123;</span><br><span class="line">       boolean accept &#x3D; false;</span><br><span class="line">       String[] acceptProtocols &#x3D; queryProtocols.split(&quot;,&quot;);</span><br><span class="line">       for (String acceptProtocol : acceptProtocols) &#123;</span><br><span class="line">            if (providerUrl.getProtocol().equals(acceptProtocol)) &#123;</span><br><span class="line">                  accept &#x3D; true;</span><br><span class="line">                  break;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      if (!accept) &#123;</span><br><span class="line">            continue;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step2： 从这一步开始，代码都包裹在for(URL providerUrl : urls)中，一个一个处理提供者URL。如果dubbo:referecnce标签的protocol不为空，则需要对服务提供者URL进行过滤，匹配其协议与protocol属性相同的服务，如果不匹配，则跳过后续处理逻辑，接着处理下一个服务提供者URL。</p><p>RegistryDirectory#toInvokers</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) &#123;</span><br><span class="line">      continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step3：如果协议为empty，跳过，处理下一个服务提供者URL。</p><p>RegistryDirectory#toInvokers</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) &#123;</span><br><span class="line">       logger.error(new IllegalStateException(&quot;Unsupported protocol &quot; + providerUrl.getProtocol() + &quot; in notified url: &quot; + providerUrl + &quot; from registry &quot; + getUrl().getAddress() + &quot; to </span><br><span class="line">                 consumer &quot; + NetUtils.getLocalHost()</span><br><span class="line">                        + &quot;, supported protocol: &quot; + ExtensionLoader.getExtensionLoader(Protocol.class).getSupportedExtensions()));</span><br><span class="line">   continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step4：验证服务提供者协议，如果不支持，则跳过。</p><p>RegistryDirectory#toInvokers</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URL url &#x3D; mergeUrl(providerUrl);</span><br></pre></td></tr></table></figure><p>Step5：合并URL中的属性，其具体实现细节如下：</p><ol><li>消费端属性覆盖生产者端属性（配置属性消费者端优先生产者端属性），其具体实现方法：ClusterUtils.mergeUrl(providerUrl, queryMap)，其中queryMap为消费端属性。<br>  a、首先移除只在服务提供者端生效的属性（线程池相关）：threadname、default.threadname、threadpool、default.threadpool、corethreads、default.corethreads、threads、default.threads、queues、default.queues、alive、default.alive、transporter、default.transporter，服务提供者URL中的这些属性来源于dubbo:protocol、dubbo:provider。<br> b、用消费端配置属性覆盖服务端属性。<br> c、如下属性以服务端优先：dubbo(dubbo信息)、version（版本）、group（服务组）、methods（服务方法）、timestamp（时间戳）。<br> d、合并服务端，消费端Filter,其配置属性（reference.filter），返回结果为：provider#reference.filter,<br> consumer#reference.filter。<br> e、合并服务端，消费端Listener，其配置属性(invoker.listener)，返回结果为：provider#invoker.listener，consumer#invoker.listener。</li><li>合并configuratorUrls 中的属性，我们现在应该知道，dubbo可以在监控中心或管理端(dubbo-admin)覆盖覆盖服务提供者的属性，其使用协议为override，该部分的实现逻辑见：《源码分析Dubbo配置规则机制（override协议）》</li><li>为服务提供者URL增加check=false，默认只有在服务调用时才检查服务提供者是否可用。</li><li>重新复制overrideDirectoryUrl，providerUrl在进过第一步参数合并后（包含override协议覆盖后的属性）赋值给overrideDirectoryUrl。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String key &#x3D; url.toFullString(); &#x2F;&#x2F; The parameter urls are sorted</span><br><span class="line">if (keys.contains(key)) &#123; &#x2F;&#x2F; Repeated url</span><br><span class="line">      continue;</span><br><span class="line">&#125;</span><br><span class="line">keys.add(key);</span><br></pre></td></tr></table></figure>Step6：获取url所有属性构成的key,该key也是RegistryDirectory中Map&lt;String, Invoker<T>&gt; urlInvokerMap;中的key。</li></ol><p>RegistryDirectory#toInvokers</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap &#x3D; this.urlInvokerMap; &#x2F;&#x2F; local reference</span><br><span class="line">Invoker&lt;T&gt; invoker &#x3D; localUrlInvokerMap &#x3D;&#x3D; null ? null : localUrlInvokerMap.get(key);</span><br><span class="line">if (invoker &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Not in the cache, refer again</span><br><span class="line">   try &#123;</span><br><span class="line">         boolean enabled &#x3D; true;</span><br><span class="line">         if (url.hasParameter(Constants.DISABLED_KEY)) &#123;</span><br><span class="line">               enabled &#x3D; !url.getParameter(Constants.DISABLED_KEY, false);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">               enabled &#x3D; url.getParameter(Constants.ENABLED_KEY, true);</span><br><span class="line">           &#125;</span><br><span class="line">           if (enabled) &#123;</span><br><span class="line">                invoker &#x3D; new InvokerDelegate&lt;T&gt;(protocol.refer(serviceType, url), url, providerUrl);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125; catch (Throwable t) &#123;</span><br><span class="line">               logger.error(&quot;Failed to refer invoker for interface:&quot; + serviceType + &quot;,url:(&quot; + url + &quot;)&quot; + t.getMessage(), t);</span><br><span class="line">      &#125;</span><br><span class="line">      if (invoker !&#x3D; null) &#123; &#x2F;&#x2F; Put new invoker in cache</span><br><span class="line">            newUrlInvokerMap.put(key, invoker);</span><br><span class="line">      &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">       newUrlInvokerMap.put(key, invoker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step7：如果localUrlInvokerMap中未包含invoker并且该provider状态为启用，则创建该URL对应的Invoker，并添加到newUrlInvokerMap中。toInvokers运行结束后，回到refreshInvoker方法中继续往下执行，根据 最新的服务提供者映射关系Map&lt; String,Invoker&gt;，构建Map&lt; String,List&lt; Invoker&gt;&gt;,其中键为methodName。然后更新RegistryDirectory的urlInvokerMap、methodInvokerMap属性，并销毁老的Invoker对象，完成一次路由发现过程。</p><p>上面整个过程完成了一次动态服务提供者发现流程，下面再分析一下RegistryDirectory的另外一个重要方法，doList，再重复一遍RegistryDirectory的作用，服务提供者目录服务，在集群Invoker的实现中，内部持有一个Direcotry对象，在进行服务调用之前，首先先从众多的Invoker中选择一个来执行，那众多的Invoker从哪来呢？其来源于集群Invoker中会调用Direcotry的public List&lt; Invoker&lt; T&gt;&gt; list(Invocation invocation)，首先将调用AbstractDirectory#list方法，然后再内部调用doList方法，doList方法有其子类实现。</p><h2 id="7、RegistryDirectory-doList-Invocation-invocation-方法详解"><a href="#7、RegistryDirectory-doList-Invocation-invocation-方法详解" class="headerlink" title="7、RegistryDirectory#doList(Invocation invocation) 方法详解"></a>7、RegistryDirectory#doList(Invocation invocation) 方法详解</h2><p>RegistryDirectory#doList</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (forbidden) &#123;</span><br><span class="line">      &#x2F;&#x2F; 1. No service provider 2. Service providers are disabled</span><br><span class="line">      throw new RpcException(RpcException.FORBIDDEN_EXCEPTION,</span><br><span class="line">            &quot;No provider available from registry &quot; + getUrl().getAddress() + &quot; for service &quot; + getConsumerUrl().getServiceKey() + &quot; on consumer &quot; +  NetUtils.getLocalHost()</span><br><span class="line">                  + &quot; use dubbo version &quot; + Version.getVersion() + &quot;, please check status of providers(disabled, not registered or in blacklist).&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step1：如果禁止访问（如果没有服务提供者，或服务提供者被禁用），则抛出没有提供者异常。</p><p>RegistryDirectory#doList</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; localMethodInvokerMap &#x3D; this.methodInvokerMap; &#x2F;&#x2F; local reference</span><br><span class="line">if (localMethodInvokerMap !&#x3D; null &amp;&amp; localMethodInvokerMap.size() &gt; 0) &#123;</span><br><span class="line">    String methodName &#x3D; RpcUtils.getMethodName(invocation);</span><br><span class="line">    Object[] args &#x3D; RpcUtils.getArguments(invocation);</span><br><span class="line">    if (args !&#x3D; null &amp;&amp; args.length &gt; 0 &amp;&amp; args[0] !&#x3D; null</span><br><span class="line">             &amp;&amp; (args[0] instanceof String || args[0].getClass().isEnum())) &#123;</span><br><span class="line">          invokers &#x3D; localMethodInvokerMap.get(methodName + &quot;.&quot; + args[0]); &#x2F;&#x2F; The routing can be enumerated according to the first parameter</span><br><span class="line">     &#125;</span><br><span class="line">    if (invokers &#x3D;&#x3D; null) &#123;</span><br><span class="line">          invokers &#x3D; localMethodInvokerMap.get(methodName);</span><br><span class="line">    &#125;</span><br><span class="line">    if (invokers &#x3D;&#x3D; null) &#123;</span><br><span class="line">          invokers &#x3D; localMethodInvokerMap.get(Constants.ANY_VALUE);</span><br><span class="line">     &#125;</span><br><span class="line">     if (invokers &#x3D;&#x3D; null) &#123;</span><br><span class="line">         Iterator&lt;List&lt;Invoker&lt;T&gt;&gt;&gt; iterator &#x3D; localMethodInvokerMap.values().iterator();</span><br><span class="line">         if (iterator.hasNext()) &#123;</span><br><span class="line">              invokers &#x3D; iterator.next();</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">return invokers &#x3D;&#x3D; null ? new ArrayList&lt;Invoker&lt;T&gt;&gt;(0) : invokers;</span><br></pre></td></tr></table></figure><p>Step2：根据方法名称，从Map&lt; String,List&lt; Invoker&gt;&gt;这个集合中找到合适的List&lt; Invoker&gt;，如果方法名未命中，则返回所有的Invoker，localMethodInvokerMap中方法名，主要是dubbo:service的子标签dubbo:method，最终返回invokers。</p><p>本文详细介绍了服务消费者基于注册中心的服务发现机制，其中对routers(路由)与configurators(override协议)并未详细展开，下节先重点分析configurators与routers(路由)实现细节。</p><p>总结一下服务注册与发现机制：<br>基于注册 中心的事件通知（订阅与发布），一切支持事件订阅与发布的框架都可以作为Dubbo注册中心的选型。</p><ol><li><p>服务提供者在暴露服务时，会向注册中心注册自己，具体就是在${service interface}/providers目录下添加 一个节点（临时），服务提供者需要与注册中心保持长连接，一旦连接断掉（重试连接）会话信息失效后，注册中心会认为该服务提供者不可用（提供者节点会被删除）。</p></li><li><p>消费者在启动时，首先也会向注册中心注册自己，具体在${interface interface}/consumers目录下创建一个节点。</p></li><li><p>消费者订阅${service interface}/ [  providers、configurators、routers ]三个目录，这些目录下的节点删除、新增事件都胡通知消费者，根据通知，重构服务调用器(Invoker)。</p></li></ol><p>以上就是Dubbo服务注册与动态发现机制的原理与实现细节。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;RegistryDirectory，基于注册中心的服务发现，本文将重点探讨Dubbo是如何实现服务的自动注册与发现。从上篇文章，得知在消息消费者在创建服务调用器(Invoker)【消费者在初始时】时需要根据不同的协议，例如dubbo、registry(从注册中心获取服务提供者)来构建，其调用的方法为Protocol#refer，基于注册中心发现服务提供者的实现协议为RegistryProtocol。&lt;/p&gt;
&lt;p&gt;RegistryProtocol#refer —-&amp;gt; doRefer方法。&lt;/p&gt;
&lt;p&gt;RegistryProtocol#doRefer&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; doRefer(Cluster cluster, Registry registry, Class&amp;lt;T&amp;gt; type, URL url) &amp;#123;    &amp;#x2F;&amp;#x2F; @1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        RegistryDirectory&amp;lt;T&amp;gt; directory &amp;#x3D; new RegistryDirectory&amp;lt;T&amp;gt;(type, url);   &amp;#x2F;&amp;#x2F; @2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        directory.setRegistry(registry);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        directory.setProtocol(protocol);   &amp;#x2F;&amp;#x2F; @3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#x2F;&amp;#x2F; all attributes of REFER_KEY&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Map&amp;lt;String, String&amp;gt; parameters &amp;#x3D; new HashMap&amp;lt;String, String&amp;gt;(directory.getUrl().getParameters());   &amp;#x2F;&amp;#x2F; @4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        URL subscribeUrl &amp;#x3D; new URL(Constants.CONSUMER_PROTOCOL, parameters.remove(Constants.REGISTER_IP_KEY), 0, type.getName(), parameters);  &amp;#x2F;&amp;#x2F; @5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (!Constants.ANY_VALUE.equals(url.getServiceInterface())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;amp;&amp;amp; url.getParameter(Constants.REGISTER_KEY, true)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            registry.register(subscribeUrl.addParameters(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    Constants.CHECK_KEY, String.valueOf(false)));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;   &amp;#x2F;&amp;#x2F; @6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        directory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Constants.PROVIDERS_CATEGORY&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        + &amp;quot;,&amp;quot; + Constants.CONFIGURATORS_CATEGORY&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        + &amp;quot;,&amp;quot; + Constants.ROUTERS_CATEGORY));     &amp;#x2F;&amp;#x2F; @7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Invoker invoker &amp;#x3D; cluster.join(directory);    &amp;#x2F;&amp;#x2F; @8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);     &amp;#x2F;&amp;#x2F; @9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return invoker;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码@1：参数详解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cluster cluster：集群策略。&lt;/li&gt;
&lt;li&gt; Registry registry：注册中心实现类。&lt;/li&gt;
&lt;li&gt;Class&lt;T&gt; type：引用服务名，dubbo:reference interface。&lt;/li&gt;
&lt;li&gt;URL url：注册中心URL。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码@2：构建RegistryDirectory对象，基于注册中心动态发现服务提供者（服务提供者新增或减少），本节重点会剖析该类的实现细节。&lt;/p&gt;
&lt;p&gt;代码@3：为RegistryDirectory设置注册中心、协议。&lt;/p&gt;
&lt;p&gt;代码@4：获取服务消费者的配置属性。&lt;/p&gt;
&lt;p&gt;代码@5：构建消费者URL，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;consumer:&amp;#x2F;&amp;#x2F;192.168.56.1&amp;#x2F;com.alibaba.dubbo.demo.DemoService?application&amp;#x3D;demo-consumer&amp;amp;check&amp;#x3D;false&amp;amp;dubbo&amp;#x3D;2.0.0&amp;amp;interface&amp;#x3D;com.alibaba.dubbo.demo.DemoService&amp;amp;methods&amp;#x3D;sayHello&amp;amp;pid&amp;#x3D;9892&amp;amp;qos.port&amp;#x3D;33333&amp;amp;side&amp;#x3D;consumer&amp;amp;timestamp&amp;#x3D;1528380277185&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码@6：向注册中心消息消费者：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;consumer:&amp;#x2F;&amp;#x2F;192.168.56.1&amp;#x2F;com.alibaba.dubbo.demo.DemoService?application&amp;#x3D;demo-consumer&amp;amp;category&amp;#x3D;consumers&amp;amp;check&amp;#x3D;false&amp;amp;dubbo&amp;#x3D;2.0.0&amp;amp;interface&amp;#x3D;com.alibaba.dubbo.demo.DemoService&amp;amp;methods&amp;#x3D;sayHello&amp;amp;pid&amp;#x3D;9892&amp;amp;qos.port&amp;#x3D;33333&amp;amp;side&amp;#x3D;consumer&amp;amp;timestamp&amp;#x3D;1528380277185&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;相比第5步的URL，增加了category=consumers、check=false，其中category表示在注册中心的命名空间，这里代表消费端。该步骤的作用就是向注册中心为服务增加一个消息消费者，其生成的效果如下：【以zookeeper为例】。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180618220050346?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;代码@7：为消息消费者添加category=providers,configurators,routers属性后，然后向注册中心订阅该URL，关注该服务下的providers,configurators,routers发生变化时通知RegistryDirectory，以便及时发现服务提供者、配置、路由规则的变化。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;consumer:&amp;#x2F;&amp;#x2F;192.168.56.1&amp;#x2F;com.alibaba.dubbo.demo.DemoService?application&amp;#x3D;demo-consumer&amp;amp;category&amp;#x3D;providers,configurators,routers&amp;amp;check&amp;#x3D;false&amp;amp;dubbo&amp;#x3D;2.0.0&amp;amp;interface&amp;#x3D;com.alibaba.dubbo.demo.DemoService&amp;amp;methods&amp;#x3D;sayHello&amp;amp;pid&amp;#x3D;9892&amp;amp;qos.port&amp;#x3D;33333&amp;amp;side&amp;#x3D;consumer&amp;amp;timestamp&amp;#x3D;1528380277185&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其订阅关系调用的入口为：RegistryDirectory#subscribe方法，是接下来需要重点分析的重点。&lt;/p&gt;
&lt;p&gt;代码@8：根据Directory，利用集群策略返回集群Invoker。&lt;/p&gt;
&lt;p&gt;代码@9：缓存服务消费者、服务提供者对应关系。&lt;/p&gt;
&lt;p&gt;从这里发现，服务的注册与发现与RegistryDirectory联系非常紧密，接下来让我们来详细分析RegistryDirectory的实现细节。&lt;/p&gt;
&lt;h2 id=&quot;1、RegistryDirectory类图&quot;&gt;&lt;a href=&quot;#1、RegistryDirectory类图&quot; class=&quot;headerlink&quot; title=&quot;1、RegistryDirectory类图&quot;&gt;&lt;/a&gt;1、RegistryDirectory类图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180618223543475?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;private static final Cluster cluster = ExtensionLoader.getExtensionLoader(Cluster.class).getAdaptiveExtension();&lt;pre&gt;&lt;code&gt;集群策略，默认为failover。&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;private static final RouterFactory routerFactory = ExtensionLoader.getExtensionLoader (RouterFactory.class).getAdaptiveExtension()路由工厂，可以通过监控中心或治理中心配置。&lt;/li&gt;
&lt;li&gt;private static final ConfiguratorFactory configuratorFactory = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class).getAdaptiveExtension();配置实现工厂类。&lt;/li&gt;
&lt;li&gt;private final String serviceKey;  服务key，默认为服务接口名。com.alibaba.dubbo.registry.RegistryService，注册中心在Dubbo中也是使用服务暴露。&lt;/li&gt;
&lt;li&gt;private final Class&amp;lt; T &amp;gt; serviceType;服务提供者接口类，例如interface com.alibaba.dubbo.demo.DemoService&lt;/li&gt;
&lt;li&gt;private final Map&amp;lt; String, String&amp;gt; queryMap：服务消费者URL中的所有属性。&lt;/li&gt;
&lt;li&gt;private final URL directoryUrl;注册中心URL，只保留消息消费者URL查询属性，也就是queryMap。&lt;/li&gt;
&lt;li&gt;private final String[] serviceMethods：引用服务提供者方法数组。&lt;/li&gt;
&lt;li&gt;private final boolean multiGroup：是否引用多个服务组。&lt;/li&gt;
&lt;li&gt;private Protocol protocol：协议。&lt;/li&gt;
&lt;li&gt;private Registry registry：注册中心实现者。&lt;/li&gt;
&lt;li&gt;private volatile List&amp;lt; Configurator&amp;gt; configurators;配置信息。&lt;/li&gt;
&lt;li&gt;private volatile Map&amp;lt; String, Invoker&amp;lt; T&amp;gt;&amp;gt; urlInvokerMap; 服务URL对应的Invoker(服务提供者调用器)。&lt;/li&gt;
&lt;li&gt;private volatile Map&amp;lt; String, List&amp;lt; Invoker&amp;lt; T&amp;gt;&amp;gt;&amp;gt; methodInvokerMap; methodName : List&amp;lt; Invoker&amp;lt; T &amp;gt;&amp;gt;，&lt;pre&gt;&lt;code&gt;   dubbo:method 对应的Invoker缓存表。&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;private volatile Set&amp;lt; URL &amp;gt; cachedInvokerUrls; 当前缓存的所有URL提供者URL。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="dubbo" scheme="http://example.com/categories/dubbo/"/>
    
    
    <category term="dubbo" scheme="http://example.com/tags/dubbo/"/>
    
    <category term="服务发现" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    
    <category term="RegistryDirectory" scheme="http://example.com/tags/RegistryDirectory/"/>
    
    <category term="服务注册" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>源码分析Dubbo Invoker概述----服务发现、集群、负载均衡、路由体系</title>
    <link href="http://example.com/posts/22a2e460.html"/>
    <id>http://example.com/posts/22a2e460.html</id>
    <published>2020-12-12T14:57:01.000Z</published>
    <updated>2020-12-12T15:44:36.442Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>Invoker,负载网络调用组件，底层依懒与网络通信，Invoker主要负责服务调用，自然与路由（比如集群）等功能息息相关，本节先从整体上把控一下Dubbo服务调用体系，服务发现、集群、负载均衡、路由机制等整个知识体系，梳理整理Dubbo Invoker整个类图如下：<br><img src="https://img-blog.csdn.net/20180610171223710?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>主要有如下接口群</p><ol><li>Invocation(调用上下文环境)</li></ol><ul><li>Invocation：<br>1、String getMethodName()    获取调用方法名。<br>2、Class&lt; ? &gt;[] getParameterTypes()    获取被调用方法的参数列表（参数类型）<br>3、Object[] getArguments()    获取被调用方法的参数值数组。<br>4、Map&lt; String, String&gt; getAttachments()    获取附加属性。<br>5、String getAttachment(String key)    根据key获取附加属性值。<br>6、String getAttachment(String key, String defaultValue)    根据key获取附加属性，如果不存在，取默认值。<br>7、Invoker&lt; ?&gt; getInvoker() 获取当前的invoker。</li><li>RpcInvocation rpc服务调用实现类<pre><code>Invocation执行调用上下文环境，就是用一个Bean存储当前调用方法的参数，其本质就是一个普通的Bean而已。</code></pre></li><li>MockInvocation<pre><code>用于mock单元测试用。</code></pre></li><li>DecodeableRpcInvocation 带解码功能的rpc调用上下文<pre><code>该实现主要能从RPC服务调用请求中解析二进制流（二进制包）得到RPC服务调用上下文（方法调用元数据）。</code></pre></li></ul><a id="more"></a><ol start="2"><li>Invoker 服务调用器，Dubbo中调用服务的抽象。<br>Invoer的抽象接口，继承自com.alibaba.dubbo.common.Node接口</li></ol><ul><li>Node：<br>1、URL getUrl();      获取URL，在dubbo中，注册中心、服务提供者、服务消费者、监控中心等都使用URL描述。<br>2、boolean isAvailable()    ：判断是否可用。<br>3、void destroy()    ：资源销毁。</li><li>Invoker:<br>1、Class<T> getInterface()    :获取服务提供者的接口。<br>Result invoke(Invocation invocation) throws RpcException    ：调用服务，返回调用结果。</li><li>AbstractInvoker Invoker默认实现（模板类）<br>   该方法主要实现public Result invoke(Invocation inv) throws RpcException,定义执行invoker的基础流程（模板），然后根据不同的实现子类（不同的协议）执行各自个性化的执行任务。其抽象方法：protected abstract Result doInvoke(Invocation invocation) throws Throwable，具体实现将在后文中分析。</li><li>DubboInvoker dubbo协议调用器具体实现。</li><li>InjvmInvoker injvm协议调用其具体实现（本地协议）</li></ul><ol start="3"><li>AbstractClusterInvoker 集群模式调用模板类<br>  该类为Dubbo集群模式的调用模板类，主题解决一个服务服务有多个服务提供者，此时消息消费端在调用服务时如何选择具体的服务提供者。该类需要组织多个服务提供者，并按照指定算法选择一服务提供者进行调用。</li></ol><ul><li>AvailableClusterInvoker<br>通过&lt; dubbo:service cluster = “available” …/&gt; 或 &lt; dubbo:reference cluster=”available” …/&gt;<br>集群策略：总是选择第一个可用的服务提供者。</li><li>BroadcastClusterInvoker<br>通过&lt; dubbo:service cluster = “broadcast” …/&gt; 或 &lt; dubbo:reference cluster=”broadcast” …/&gt;<br>集群策略：广播模式，向所有服务提供者都发送请求，任何一个调用失败，则认为失败。</li><li>FailbackClusterInvoker<br>通过&lt; dubbo:service cluster = “failback” …/&gt; 或 &lt; dubbo:reference cluster=”failback” …/&gt;<br>集群策略：服务调用失败后，定时重试，重试次数无线次，重试频率：5s。并不会切换服务提供者。</li><li>FailfastClusterInvoker<br>通过&lt; dubbo:service cluster = “failfast” …/&gt; 或 &lt; dubbo:reference cluster=”failfast” …/&gt;<br>集群策略：服务调用后，快速失败，直接抛出异常，并不重试，也不受retries参数的制约，适合新增、修改类操作。</li><li>FailoverClusterInvoker<br>通过&lt; dubbo:service cluster = “failover” …/&gt; 或 &lt; dubbo:reference cluster=”failover” …/&gt;<br>集群策略：服务调用后，如果出现失败，则重试其他服务提供者，默认重试2次，总共执行3次，重试次数由retries配置，dubbo集群默认方式。</li><li>FailsafeClusterInvoker<br>通过&lt; dubbo:service cluster = “failsafe” …/&gt; 或 &lt; dubbo:reference cluster=”failsafe” …/&gt;<br>集群策略：服务调用后，只打印错误日志，然后直接返回。</li><li>ForkingClusterInvoker<br>通过&lt; dubbo:service cluster = “forking” …/&gt; 或 &lt; dubbo:reference cluster=”forking” …/&gt;<br>集群策略：并发调用多个服务提供者，取第一个返回的结果。可以通过forks设置并发调用的服务台提供者个数。</li></ul><p>更多的集群策略，可以参考/dubbo-cluster/src/main/resources/META-/com.alibaba.dubbo.rpc.cluster.Cluster文件。<br><img src="https://img-blog.csdn.net/2018061017153961?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><ol start="4"><li>LoadBalance 集群负载算法<br>当一个服务有多个服务提供者时，消费端在进行服务调用时选择服务服务提供者的负载均衡算法。<br>LoadBalance定义的接口为：<br>&lt; T&gt; Invoker<T> select(List&lt; Invoker<T>&gt; invokers, URL url, Invocation invocation) throws RpcException;</li></ol><ul><li>ConsistentHashLoadBalance<br>可以通过&lt; dubbo:service loadbalance=”consistenthash” …/&gt;或&lt; dubbo:provider loadbalance = “consistenthash” …/&gt;<br>负载均衡算法：一致性Hash算法，在AbstractClusterInvoker中从多个服务提供者中选择一个服务提供者时被调用。</li><li>LeastActiveLoadBalance<br>可以通过&lt; dubbo:service loadbalance=”leastactive” …/&gt;或&lt; dubbo:provider loadbalance = “leastactive” …/&gt;<br>负载均衡算法：最小活跃调用。</li><li>RandomLoadBalance<br>可以通过&lt; dubbo:service loadbalance=”random” …/&gt;或&lt; dubbo:service loadbalance = “random” …/&gt;<br>负载均衡算法：随机，如果weight（权重越大，机会越高）</li><li>RoundRobinLoadBalance<br>可以通过&lt; dubbo:service loadbalance=”roundrobin” …/&gt;或&lt; dubbo:provider loadbalance = “roundrobin” …/&gt;<br>负载均衡算法：加权轮询算法。</li></ul><ol start="5"><li>Directory（目录服务，Invoker的目录服务）<br>该接口主要的作用是服务提供者的目录服务，管理多个服务提供者。</li></ol><ul><li>Directory<br>1、Class&lt; T&gt; getInterface() 获取该服务接口类别。<br>2、List&lt; Invoker&lt; T&gt;&gt; list(Invocation invocation) throws RpcException 根据调用上下文获取当前所有该服务的服务提供者。</li></ul><p>4.2 AbstractDirectory 目录服务实现的抽象列（模板类）<br>4.3 StaticDirectory 静态目录服务<br>    所谓静态目录服务就是在创建StaticDirectory时指定一个服务提供者集合，则该目录服务实例在其生命周期中，只会返回这些服务提供者。</p><ul><li>RegistryDirectory 动态目录服务（基于注册中心）、<br>从注册中心动态获取发现服务提供，默认消息消费者并不会指定特定的服务提供者URL，所以会向注册中心订阅服务的服务提供者（监听注册中心providers目录），利用RegistryDirectory自动获取注册中心服务器列表。</li></ul><ol start="6"><li>Router 路由功能<br>根据消息消费者URL，结合路由表达式或JS引擎，从Directory中选择符合路由规则的Invoker，再执行负载均衡算法。</li></ol><ul><li>Router<br>1、URL getUrl();    获取消息消费者URL。<br>2、&lt; T&gt; List&lt; Invoker&lt; T&gt;&gt; route(List&lt;  Invoker&lt; T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException  根据消息消费者URL，从invokers中筛选合适的Invokers。</li><li>ConditionRouter 基于条件表达式的路由实现。</li><li>ScriptRouter 基于JS引擎的路由实现。</li></ul><p>单个Invoker的实现，例如DubboInvoker、InJVMInvoker底层调用网络通道发送请求命令（oneway、同步、异步调用方式），其网络底层细节将在后续专门讲解网络实现篇章重点分析，接下来的篇章，主要从源码的角度剖析集群、负载均衡、动态路由目录服务（RegistryDirectory ）的实现细节。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;Invoker,负载网络调用组件，底层依懒与网络通信，Invoker主要负责服务调用，自然与路由（比如集群）等功能息息相关，本节先从整体上把控一下Dubbo服务调用体系，服务发现、集群、负载均衡、路由机制等整个知识体系，梳理整理Dubbo Invoker整个类图如下：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180610171223710?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;主要有如下接口群&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Invocation(调用上下文环境)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Invocation：&lt;br&gt;1、String getMethodName()    获取调用方法名。&lt;br&gt;2、Class&amp;lt; ? &amp;gt;[] getParameterTypes()    获取被调用方法的参数列表（参数类型）&lt;br&gt;3、Object[] getArguments()    获取被调用方法的参数值数组。&lt;br&gt;4、Map&amp;lt; String, String&amp;gt; getAttachments()    获取附加属性。&lt;br&gt;5、String getAttachment(String key)    根据key获取附加属性值。&lt;br&gt;6、String getAttachment(String key, String defaultValue)    根据key获取附加属性，如果不存在，取默认值。&lt;br&gt;7、Invoker&amp;lt; ?&amp;gt; getInvoker() 获取当前的invoker。&lt;/li&gt;
&lt;li&gt;RpcInvocation rpc服务调用实现类&lt;pre&gt;&lt;code&gt;Invocation执行调用上下文环境，就是用一个Bean存储当前调用方法的参数，其本质就是一个普通的Bean而已。&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;MockInvocation&lt;pre&gt;&lt;code&gt;用于mock单元测试用。&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;DecodeableRpcInvocation 带解码功能的rpc调用上下文&lt;pre&gt;&lt;code&gt;该实现主要能从RPC服务调用请求中解析二进制流（二进制包）得到RPC服务调用上下文（方法调用元数据）。&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="dubbo" scheme="http://example.com/categories/dubbo/"/>
    
    
    <category term="dubbo" scheme="http://example.com/tags/dubbo/"/>
    
    <category term="invoker" scheme="http://example.com/tags/invoker/"/>
    
    <category term="服务发现" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    
    <category term="负载均衡" scheme="http://example.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    <category term="路由体系" scheme="http://example.com/tags/%E8%B7%AF%E7%94%B1%E4%BD%93%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>源码分析Dubbo服务消费端启动流程</title>
    <link href="http://example.com/posts/cc583494.html"/>
    <id>http://example.com/posts/cc583494.html</id>
    <published>2020-12-12T14:57:01.000Z</published>
    <updated>2020-12-12T15:44:36.442Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>通过前面文章详解，我们知道Dubbo服务消费者标签dubbo:reference最终会在Spring容器中创建一个对应的ReferenceBean实例，而ReferenceBean实现了Spring生命周期接口：InitializingBean，接下来应该看一下其afterPropertiesSet方法的实现。</p><a id="more"></a><h2 id="1、源码分析ReferenceBean-afterPropertiesSet"><a href="#1、源码分析ReferenceBean-afterPropertiesSet" class="headerlink" title="1、源码分析ReferenceBean#afterPropertiesSet"></a>1、源码分析ReferenceBean#afterPropertiesSet</h2><p>ReferenceBean#afterPropertiesSet</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if (getConsumer() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            Map&lt;String, ConsumerConfig&gt; consumerConfigMap &#x3D; applicationContext &#x3D;&#x3D; null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, </span><br><span class="line">                 ConsumerConfig.class, false, false);</span><br><span class="line">            if (consumerConfigMap !&#x3D; null &amp;&amp; consumerConfigMap.size() &gt; 0) &#123;</span><br><span class="line">                ConsumerConfig consumerConfig &#x3D; null;</span><br><span class="line">                for (ConsumerConfig config : consumerConfigMap.values()) &#123;</span><br><span class="line">                    if (config.isDefault() &#x3D;&#x3D; null || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                        if (consumerConfig !&#x3D; null) &#123;</span><br><span class="line">                            throw new IllegalStateException(&quot;Duplicate consumer configs: &quot; + consumerConfig + &quot; and &quot; + config);</span><br><span class="line">                        &#125;</span><br><span class="line">                        consumerConfig &#x3D; config;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (consumerConfig !&#x3D; null) &#123;</span><br><span class="line">                    setConsumer(consumerConfig);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>Step1：如果consumer为空，说明dubbo:reference标签未设置consumer属性，如果一个dubbo:consumer标签，则取该实例，如果存在多个dubbo:consumer 配置，则consumer必须设置，否则会抛出异常：”Duplicate consumer configs”。</p><p>Step2：如果application为空,则尝试从BeanFactory中查询dubbo:application实例，如果存在多个dubbo:application配置，则抛出异常：”Duplicate application configs”。</p><p>Step3：如果ServiceBean的module为空，则尝试从BeanFactory中查询dubbo:module实例，如果存在多个dubbo:module，则抛出异常：”Duplicate module configs: “。</p><p>Step4：尝试从BeanFactory中加载所有的注册中心，注意ServiceBean的List&lt; RegistryConfig&gt; registries属性，为注册中心集合。</p><p>Step5：尝试从BeanFacotry中加载一个监控中心，填充ServiceBean的MonitorConfig monitor属性，如果存在多个dubbo:monitor配置，则抛出”Duplicate monitor configs: “。</p><p>ReferenceBean#afterPropertiesSet</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Boolean b &#x3D; isInit();</span><br><span class="line">if (b &#x3D;&#x3D; null &amp;&amp; getConsumer() !&#x3D; null) &#123;</span><br><span class="line">      b &#x3D; getConsumer().isInit();</span><br><span class="line">&#125;</span><br><span class="line">if (b !&#x3D; null &amp;&amp; b.booleanValue()) &#123;</span><br><span class="line">      getObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step6：判断是否初始化，如果为初始化，则调用getObject()方法，该方法也是FactoryBean定义的方法，ReferenceBean是dubbo:reference所真实引用的类(interface)的实例工程，getObject发返回的是interface的实例，而不是ReferenceBean实例。</p><h3 id="1-1-源码分析getObject"><a href="#1-1-源码分析getObject" class="headerlink" title="1.1 源码分析getObject()"></a>1.1 源码分析getObject()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object getObject() throws Exception &#123;</span><br><span class="line">        return get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReferenceBean#getObject()方法直接调用其父类的get方法,get方法内部调用init()方法进行初始化</p><h3 id="1-2-源码分析ReferenceConfig-init方法"><a href="#1-2-源码分析ReferenceConfig-init方法" class="headerlink" title="1.2 源码分析ReferenceConfig#init方法"></a>1.2 源码分析ReferenceConfig#init方法</h3><p>ReferenceConfig#init</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (initialized) &#123;</span><br><span class="line">     return;</span><br><span class="line"> &#125;</span><br><span class="line">initialized &#x3D; true;</span><br><span class="line">if (interfaceName &#x3D;&#x3D; null || interfaceName.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;&lt;dubbo:reference interface&#x3D;\&quot;\&quot; &#x2F;&gt; interface not allow null!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step1：如果已经初始化，直接返回，如果interfaceName为空，则抛出异常。</p><p>ReferenceConfig#init调用ReferenceConfig#checkDefault</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void checkDefault() &#123;</span><br><span class="line">        if (consumer &#x3D;&#x3D; null) &#123;</span><br><span class="line">            consumer &#x3D; new ConsumerConfig();</span><br><span class="line">        &#125;</span><br><span class="line">        appendProperties(consumer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Step2:如果dubbo:reference标签也就是ReferenceBean的consumer属性为空，调用appendProperties方法，填充默认属性，其具体加载顺序：</p><ol><li>从系统属性加载对应参数值，参数键：dubbo.consumer.属性名，从系统属性中获取属性值的方法为：System.getProperty(key)。</li><li>加载属性配置文件的值。属性配置文件，可通过系统属性：dubbo.properties.file，如果该值未配置，则默认取dubbo.properties属性配置文件。<br>ReferenceConfig#init<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendProperties(this);</span><br></pre></td></tr></table></figure>Step3：调用appendProperties方法，填充ReferenceBean的属性，属性值来源与step2一样，当然只填充ReferenceBean中属性为空的属性。</li></ol><p>ReferenceConfig#init</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (getGeneric() &#x3D;&#x3D; null &amp;&amp; getConsumer() !&#x3D; null) &#123;</span><br><span class="line">      setGeneric(getConsumer().getGeneric());</span><br><span class="line">&#125;</span><br><span class="line">if (ProtocolUtils.isGeneric(getGeneric())) &#123;</span><br><span class="line">      interfaceClass &#x3D; GenericService.class;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">              interfaceClass &#x3D; Class.forName(interfaceName, true, Thread.currentThread().getContextClassLoader());</span><br><span class="line">      &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                throw new IllegalStateException(e.getMessage(), e);</span><br><span class="line">      &#125;</span><br><span class="line">      checkInterfaceAndMethods(interfaceClass, methods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step4：如果使用返回引用，将interface值替换为GenericService全路径名，如果不是，则加载interfacename，并检验dubbo:reference子标签dubbo:method引用的方法是否在interface指定的接口中存在。</p><p>ReferenceConfig#init</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">String resolve &#x3D; System.getProperty(interfaceName);      &#x2F;&#x2F; @1</span><br><span class="line">String resolveFile &#x3D; null;</span><br><span class="line">if (resolve &#x3D;&#x3D; null || resolve.length() &#x3D;&#x3D; 0) &#123;                       &#x2F;&#x2F; @2</span><br><span class="line">     resolveFile &#x3D; System.getProperty(&quot;dubbo.resolve.file&quot;);    &#x2F;&#x2F; @3 start</span><br><span class="line">     if (resolveFile &#x3D;&#x3D; null || resolveFile.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">          File userResolveFile &#x3D; new File(new File(System.getProperty(&quot;user.home&quot;)), &quot;dubbo-resolve.properties&quot;);</span><br><span class="line">          if (userResolveFile.exists()) &#123;</span><br><span class="line">               resolveFile &#x3D; userResolveFile.getAbsolutePath();</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;    &#x2F;&#x2F; @3 end</span><br><span class="line">     if (resolveFile !&#x3D; null &amp;&amp; resolveFile.length() &gt; 0) &#123;    &#x2F;&#x2F; @4</span><br><span class="line">          Properties properties &#x3D; new Properties();</span><br><span class="line">          FileInputStream fis &#x3D; null;</span><br><span class="line">          try &#123;</span><br><span class="line">               fis &#x3D; new FileInputStream(new File(resolveFile));</span><br><span class="line">               properties.load(fis);</span><br><span class="line">           &#125; catch (IOException e) &#123;</span><br><span class="line">               throw new IllegalStateException(&quot;Unload &quot; + resolveFile + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">           &#125; finally &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                    if (null !&#x3D; fis) fis.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    logger.warn(e.getMessage(), e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">          resolve &#x3D; properties.getProperty(interfaceName);</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> if (resolve !&#x3D; null &amp;&amp; resolve.length() &gt; 0) &#123;  &#x2F;&#x2F; @5</span><br><span class="line">      url &#x3D; resolve;</span><br><span class="line">      if (logger.isWarnEnabled()) &#123;</span><br><span class="line">         if (resolveFile !&#x3D; null &amp;&amp; resolveFile.length() &gt; 0) &#123;</span><br><span class="line">             logger.warn(&quot;Using default dubbo resolve file &quot; + resolveFile + &quot; replace &quot; + interfaceName + &quot;&quot; + resolve + &quot; to p2p invoke remote service.&quot;);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            logger.warn(&quot;Using -D&quot; + interfaceName + &quot;&#x3D;&quot; + resolve + &quot; to p2p invoke remote service.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step5：处理dubbo服务消费端resolve机制，也就是说消息消费者只连服务提供者，绕过注册中心。</p><ul><li>代码@1：从系统属性中获取该接口的直连服务提供者，如果存在 -Dinterface=dubbo://127.0.0.1:20880,其中interface为dubbo:reference interface属性的值。</li><li>代码@2：如果未指定-D属性，尝试从resolve配置文件中查找，从这里看出-D的优先级更高。</li><li>代码@3：首先尝试获取resolve配置文件的路径，其来源可以通过-Ddubbo.resolve.file=文件路径名来指定，如果未配置该系统参数，则默认从${user.home}/dubbo-resolve.properties,如果过文件存在，则设置resolveFile的值，否则resolveFile为null。</li><li>代码@4：如果resolveFile不为空，则加载resolveFile文件中内容，然后通过interface获取其配置的直连服务提供者URL。</li><li>代码@5：如果resolve不为空，则填充ReferenceBean的url属性为resolve(点对点服务提供者URL)，打印日志，点对点URL的来源（系统属性、resolve配置文件）。</li></ul><p>ReferenceConfig#init</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">checkApplication();</span><br><span class="line">checkStubAndMock(interfaceClass);</span><br></pre></td></tr></table></figure><p>Step6：校验ReferenceBean的application是否为空,如果为空，new 一个application，并尝试从系统属性（优先）、资源文件中填充其属性；同时校验stub、mock实现类与interface的兼容性。系统属性、资源文件属性的配置如下：<br>application     dubbo.application.属性名，例如    dubbo.application.name</p><p>ReferenceConfig#init</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map &#x3D; new HashMap&lt;String, String&gt;();</span><br><span class="line">Map&lt;Object, Object&gt; attributes &#x3D; new HashMap&lt;Object, Object&gt;();</span><br><span class="line">map.put(Constants.SIDE_KEY, Constants.CONSUMER_SIDE);</span><br><span class="line">map.put(Constants.DUBBO_VERSION_KEY, Version.getVersion());</span><br><span class="line">map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">if (ConfigUtils.getPid() &gt; 0) &#123;</span><br><span class="line">     map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step7：构建Map,封装服务消费者引用服务提供者URL的属性，这里主要填充side:consume（消费端)、dubbo：2.0.0(版本)、timestamp、pid:进程ID。</p><p>ReferenceConfig#init</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (!isGeneric()) &#123;</span><br><span class="line">    String revision &#x3D; Version.getVersion(interfaceClass, version);</span><br><span class="line">    if (revision !&#x3D; null &amp;&amp; revision.length() &gt; 0) &#123;</span><br><span class="line">         map.put(&quot;revision&quot;, revision);</span><br><span class="line">    &#125;</span><br><span class="line">    String[] methods &#x3D; Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">    if (methods.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">           logger.warn(&quot;NO method found in service interface &quot; + interfaceClass.getName());</span><br><span class="line">           map.put(&quot;methods&quot;, Constants.ANY_VALUE);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">          map.put(&quot;methods&quot;, StringUtils.join(new HashSet&lt;String&gt;(Arrays.asList(methods)), &quot;,&quot;));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step8：如果不是泛化引用，增加methods:interface的所有方法名，多个用逗号隔开。<br>ReferenceConfig#init</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map.put(Constants.INTERFACE_KEY, interfaceName);</span><br><span class="line">appendParameters(map, application);</span><br><span class="line">appendParameters(map, module);</span><br><span class="line">appendParameters(map, consumer, Constants.DEFAULT_KEY);</span><br><span class="line">appendParameters(map, this);</span><br></pre></td></tr></table></figure><p>Step9：用Map存储application配置、module配置、默认消费者参数(ConsumerConfig)、服务消费者dubbo:reference的属性。<br>ReferenceConfig#init</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String prefix &#x3D; StringUtils.getServiceKey(map);</span><br><span class="line">if (methods !&#x3D; null &amp;&amp; !methods.isEmpty()) &#123;</span><br><span class="line">    for (MethodConfig method : methods) &#123;</span><br><span class="line">         appendParameters(map, method, method.getName());</span><br><span class="line">         String retryKey &#x3D; method.getName() + &quot;.retry&quot;;</span><br><span class="line">         if (map.containsKey(retryKey)) &#123;</span><br><span class="line">              String retryValue &#x3D; map.remove(retryKey);</span><br><span class="line">              if (&quot;false&quot;.equals(retryValue)) &#123;</span><br><span class="line">                  map.put(method.getName() + &quot;.retries&quot;, &quot;0&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         appendAttributes(attributes, method, prefix + &quot;.&quot; + method.getName());</span><br><span class="line">         checkAndConvertImplicitConfig(method, map, attributes);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step10：获取服务键值 /{group}/interface:版本，如果group为空，则为interface:版本,其值存为prifex，然后将dubbo:method的属性名称也填入map中，键前缀为dubbo.method.methodname.属性名。dubbo:method的子标签dubbo:argument标签的属性也追加到attributes map中，键为 prifex + methodname.属性名。</p><p>ReferenceConfig#init</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String hostToRegistry &#x3D; ConfigUtils.getSystemProperty(Constants.DUBBO_IP_TO_REGISTRY);</span><br><span class="line">if (hostToRegistry &#x3D;&#x3D; null || hostToRegistry.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      hostToRegistry &#x3D; NetUtils.getLocalHost();</span><br><span class="line">&#125; else if (isInvalidLocalHost(hostToRegistry)) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;Specified invalid registry ip from property:&quot; + Constants.DUBBO_IP_TO_REGISTRY + &quot;, value:&quot; + </span><br><span class="line">           hostToRegistry);</span><br><span class="line">&#125;</span><br><span class="line">map.put(Constants.REGISTER_IP_KEY, hostToRegistry);</span><br></pre></td></tr></table></figure><p>Step11：填充register.ip属性，该属性是消息消费者连接注册中心的IP，并不是注册中心自身的IP。<br>ReferenceConfig#init</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref &#x3D; createProxy(map);</span><br></pre></td></tr></table></figure><p>Step12：调用createProxy方法创建消息消费者代理，下面详细分析其实现细节。<br>ReferenceConfig#init</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConsumerModel consumerModel &#x3D; new ConsumerModel(getUniqueServiceName(), this, ref, interfaceClass.getMethods());</span><br><span class="line">ApplicationModel.initConsumerModel(getUniqueServiceName(), consumerModel);</span><br></pre></td></tr></table></figure><p>Step13：将消息消费者缓存在ApplicationModel中。</p><h4 id="1-2-1-源码分析ReferenceConfig-createProxy方法"><a href="#1-2-1-源码分析ReferenceConfig-createProxy方法" class="headerlink" title="1.2.1 源码分析ReferenceConfig#createProxy方法"></a>1.2.1 源码分析ReferenceConfig#createProxy方法</h4><p>ReferenceConfig#createProxy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">URL tmpUrl &#x3D; new URL(&quot;temp&quot;, &quot;localhost&quot;, 0, map);</span><br><span class="line">final boolean isJvmRefer;</span><br><span class="line">if (isInjvm() &#x3D;&#x3D; null) &#123;</span><br><span class="line">    if (url !&#x3D; null &amp;&amp; url.length() &gt; 0) &#123; &#x2F;&#x2F; if a url is specified, don&#39;t do local reference</span><br><span class="line">          isJvmRefer &#x3D; false;</span><br><span class="line">    &#125; else if (InjvmProtocol.getInjvmProtocol().isInjvmRefer(tmpUrl)) &#123;</span><br><span class="line">         &#x2F;&#x2F; by default, reference local service if there is</span><br><span class="line">         isJvmRefer &#x3D; true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">         isJvmRefer &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    isJvmRefer &#x3D; isInjvm().booleanValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step1：判断该消费者是否是引用本(JVM)内提供的服务。<br>如果dubbo:reference标签的injvm(已过期，被local属性替换)如果不为空，则直接取该值，如果该值未配置，则判断ReferenceConfig的url属性是否为空，如果不为空，则isJvmRefer =false，表明该服务消费者将直连该URL的服务提供者；如果url属性为空，则判断该协议是否是isInjvm，其实现逻辑：获取dubbo:reference的scop属性，根据其值判断：</p><ul><li>如果为空，isJvmRefer为false。</li><li>如果协议为injvm，就是表示为本地协议，既然提供了本地协议的实现，则无需配置isJvmRefer该标签为true，故，isJvmRerfer=false。</li><li> 如果scope=local或injvm=true，isJvmRefer=true。</li><li>如果scope=remote，isJvmRefer设置为false。</li><li>如果是泛化引用，isJvmRefer设置为false。</li><li>其他默认情况，isJvmRefer设置为true。</li></ul><p>ReferenceConfig#createProxy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (isJvmRefer) &#123;</span><br><span class="line">   URL url &#x3D; new URL(Constants.LOCAL_PROTOCOL, NetUtils.LOCALHOST, 0, interfaceClass.getName()).addParameters(map);</span><br><span class="line">   invoker &#x3D; refprotocol.refer(interfaceClass, url);</span><br><span class="line">   if (logger.isInfoEnabled()) &#123;</span><br><span class="line">         logger.info(&quot;Using injvm service &quot; + interfaceClass.getName());</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>Step2：如果消费者引用本地JVM中的服务，则利用InjvmProtocol创建Invoker，dubbo中的invoker主要负责服务调用的功能，是其核心实现，后续会在专门的章节中详细分析，在这里我们需要知道，会创建于协议相关的Invoker即可。</p><p>ReferenceConfig#createProxy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if (url !&#x3D; null &amp;&amp; url.length() &gt; 0) &#123; &#x2F;&#x2F; user specified URL, could be peer-to-peer address, or register center&#39;s address.</span><br><span class="line">     String[] us &#x3D; Constants.SEMICOLON_SPLIT_PATTERN.split(url);   &#x2F;&#x2F; @1</span><br><span class="line">     if (us !&#x3D; null &amp;&amp; us.length &gt; 0) &#123;</span><br><span class="line">           for (String u : us) &#123;</span><br><span class="line">                  URL url &#x3D; URL.valueOf(u);</span><br><span class="line">                  if (url.getPath() &#x3D;&#x3D; null || url.getPath().length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                       url &#x3D; url.setPath(interfaceName);</span><br><span class="line">                  &#125;</span><br><span class="line">                 if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;   &#x2F;&#x2F; @2</span><br><span class="line">                      urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                      urls.add(ClusterUtils.mergeUrl(url, map));  &#x2F;&#x2F; @3</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>Step3：处理直连情况，与step2互斥。</p><ul><li>代码@1：对直连URL进行分割，多个直连URL用分号隔开，如果URL中不包含path属性，则为URL设置path属性为interfaceName。</li><li>代码@2：如果直连提供者的协议为registry，则对url增加refer属性，其值为消息消费者所有的属性。(表示从注册中心发现服务提供者)</li><li>代码@3：如果是其他协议提供者，则合并服务提供者与消息消费者的属性，并移除服务提供者默认属性。以default开头的属性。</li></ul><p>ReferenceConfig#createProxy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;URL&gt; us &#x3D; loadRegistries(false);   &#x2F;&#x2F; @1</span><br><span class="line">if (us !&#x3D; null &amp;&amp; !us.isEmpty()) &#123;</span><br><span class="line">     for (URL u : us) &#123;</span><br><span class="line">           URL monitorUrl &#x3D; loadMonitor(u);   &#x2F;&#x2F; @2</span><br><span class="line">           if (monitorUrl !&#x3D; null) &#123;</span><br><span class="line">                 map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));   &#x2F;&#x2F; @3</span><br><span class="line">            &#125;</span><br><span class="line">            urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));  &#x2F;&#x2F; @4</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line">if (urls &#x3D;&#x3D; null || urls.isEmpty()) &#123;</span><br><span class="line">       throw new IllegalStateException(&quot;No such any registry to reference &quot; + interfaceName + &quot; on the consumer &quot; + NetUtils.getLocalHost() + &quot; use dubbo version &quot; + Version.getVersion() + &quot;, please config &lt;dubbo:registry </span><br><span class="line">          address&#x3D;\&quot;...\&quot; &#x2F;&gt; to your spring config.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step4：普通消息消费者，从注册中心订阅服务。</p><ul><li>代码@1：获取所有注册中心URL，其中参数false表示消费端，需要排除dubbo:registry subscribe=false的注册中心，其值为false表示不接受订阅。</li><li>代码@2：根据注册中心URL，构建监控中心URL。</li><li>代码@3：如果监控中心不为空，在注册中心URL后增加属性monitor。</li><li>代码@4：在注册中心URL中，追加属性refer，其值为消费端的所有配置组成的URL。</li></ul><p>ReferenceConfig#createProxy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if (urls.size() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">    invoker &#x3D; refprotocol.refer(interfaceClass, urls.get(0));     &#x2F;&#x2F; @1</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    List&lt;Invoker&lt;?&gt;&gt; invokers &#x3D; new ArrayList&lt;Invoker&lt;?&gt;&gt;();    &#x2F;&#x2F; @2,多个服务提供者URL，集群模式</span><br><span class="line">    URL registryURL &#x3D; null;</span><br><span class="line">    for (URL url : urls) &#123;</span><br><span class="line">         invokers.add(refprotocol.refer(interfaceClass, url));    &#x2F;&#x2F; @2</span><br><span class="line">         if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">               registryURL &#x3D; url; &#x2F;&#x2F; use last registry url</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     if (registryURL !&#x3D; null) &#123; &#x2F;&#x2F; registry url is available</span><br><span class="line">          &#x2F;&#x2F; use AvailableCluster only when register&#39;s cluster is available</span><br><span class="line">          URL u &#x3D; registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);</span><br><span class="line">          invoker &#x3D; cluster.join(new StaticDirectory(u, invokers));    &#x2F;&#x2F; @3</span><br><span class="line">     &#125; else &#123; &#x2F;&#x2F; not a registry url</span><br><span class="line">          invoker &#x3D; cluster.join(new StaticDirectory(invokers));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>Step5：根据URL获取对应协议的Invoker。</p><ul><li>代码@1：如果只有一个服务提供者URL,则直接根据协议构建Invoker，具体有如下协议：<br><img src="https://img-blog.csdn.net/20180608122049691?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li>代码@2：如果有多个服务提供者，则众多服务提供者构成一个集群。<br>首先根据协议构建服务Invoker，默认Dubbo基于服务注册于发现，在服务消费端不会指定url属性，从注册中心获取服务提供者列表，此时的URL：registry://开头，url中会包含register属性，其值为注册中心的类型，例如zookeeper，将使用RedisProtocol构建Invoker，该方法将自动发现注册在注册中心的服务提供者，后续文章将会zookeeper注册中心为例，详细分析其实现原理。</li><li>代码@3：返回集群模式实现的Invoker，Dubbo中的Invoker类继承体系如下：<br><img src="https://img-blog.csdn.net/20180608122123696?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>集群模式的Invoker和单个协议Invoker一样实现Invoker接口，然后在集群Invoker中利用Directory保证一个一个协议的调用器，十分的巧妙，在后续章节中将重点分析Dubbo Invoker实现原理，包含集群实现机制。</li></ul><p>ReferenceConfig#createProxy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Boolean c &#x3D; check;</span><br><span class="line">if (c &#x3D;&#x3D; null &amp;&amp; consumer !&#x3D; null) &#123;</span><br><span class="line">      c &#x3D; consumer.isCheck();</span><br><span class="line">&#125;</span><br><span class="line">if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">      c &#x3D; true; &#x2F;&#x2F; default true</span><br><span class="line">&#125;</span><br><span class="line">if (c &amp;&amp; !invoker.isAvailable()) &#123;</span><br><span class="line">       throw new IllegalStateException(&quot;Failed to check the status of the service &quot; + interfaceName + &quot;. No provider available for the service &quot; + (group   </span><br><span class="line">              &#x3D;&#x3D; null ? &quot;&quot; : group + &quot;&#x2F;&quot;) + interfaceName + (version &#x3D;&#x3D; null ? &quot;&quot; : &quot;:&quot; + version) + &quot; from the url &quot; + invoker.getUrl() + &quot; to the consumer &quot; + </span><br><span class="line">             NetUtils.getLocalHost() + &quot; use dubbo version &quot; + Version.getVersion());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码@4：如果dubbo:referecnce的check=true或默认为空，则需要判断服务提供者是否存在。</li></ul><p>ReferenceConfig#createProxy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">return (T) proxyFactory.getProxy(invoker);</span><br><span class="line">AbstractProxyFactory#getProxy</span><br><span class="line">public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">        Class&lt;?&gt;[] interfaces &#x3D; null;</span><br><span class="line">        String config &#x3D; invoker.getUrl().getParameter(&quot;interfaces&quot;);     &#x2F;&#x2F; @1</span><br><span class="line">        if (config !&#x3D; null &amp;&amp; config.length() &gt; 0) &#123;</span><br><span class="line">            String[] types &#x3D; Constants.COMMA_SPLIT_PATTERN.split(config);</span><br><span class="line">            if (types !&#x3D; null &amp;&amp; types.length &gt; 0) &#123;</span><br><span class="line">                interfaces &#x3D; new Class&lt;?&gt;[types.length + 2];</span><br><span class="line">                interfaces[0] &#x3D; invoker.getInterface();</span><br><span class="line">                interfaces[1] &#x3D; EchoService.class;        &#x2F;&#x2F; @2</span><br><span class="line">                for (int i &#x3D; 0; i &lt; types.length; i++) &#123;</span><br><span class="line">                    interfaces[i + 1] &#x3D; ReflectUtils.forName(types[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (interfaces &#x3D;&#x3D; null) &#123;</span><br><span class="line">            interfaces &#x3D; new Class&lt;?&gt;[]&#123;invoker.getInterface(), EchoService.class&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        return getProxy(invoker, interfaces);    &#x2F;&#x2F; @3</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>根据invoker获取代理类，其实现逻辑如下：</p><ul><li>代码@1：从消费者URL中获取interfaces的值，用,分隔出单个服务应用接口。</li><li>代码@2：增加默认接口EchoService接口。</li><li>代码@3:根据需要实现的接口，使用jdk或Javassist创建代理类。<br>最后给出消息消费者启动时序图：<br><img src="https://img-blog.csdn.net/20180608122248962?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>本节关于Dubbo服务消费者（服务调用者）的启动流程就梳理到这里，下一篇将重点关注Invoker（服务调用相关的实现细节）。</li></ul></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过前面文章详解，我们知道Dubbo服务消费者标签dubbo:reference最终会在Spring容器中创建一个对应的ReferenceBean实例，而ReferenceBean实现了Spring生命周期接口：InitializingBean，接下来应该看一下其afterPropertiesSet方法的实现。&lt;/p&gt;</summary>
    
    
    
    <category term="dubbo" scheme="http://example.com/categories/dubbo/"/>
    
    
    <category term="dubbo" scheme="http://example.com/tags/dubbo/"/>
    
    <category term="启动" scheme="http://example.com/tags/%E5%90%AF%E5%8A%A8/"/>
    
    <category term="服务消费者" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    
  </entry>
  
  <entry>
    <title>源码分析Dubbo服务提供者启动流程-下篇</title>
    <link href="http://example.com/posts/380ae8bd.html"/>
    <id>http://example.com/posts/380ae8bd.html</id>
    <published>2020-12-12T14:53:01.000Z</published>
    <updated>2020-12-12T15:44:36.442Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文继续上文Dubbo服务提供者启动流程，在上篇文章中详细梳理了基于dubbo spring文件的配置方式，Dubbo是如何加载配置文件，服务提供者dubbo:service标签服务暴露全流程，本节重点关注RegistryProtocol#export中调用doLocalExport方法，其实主要是根据各自协议，服务提供者建立网络服务器，在特定端口建立监听，监听来自消息消费端服务的请求。</p><a id="more"></a><p>RegistryProtocol#doLocalExport:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private &lt;T&gt; ExporterChangeableWrapper&lt;T&gt; doLocalExport(final Invoker&lt;T&gt; originInvoker) &#123;</span><br><span class="line">        String key &#x3D; getCacheKey(originInvoker);</span><br><span class="line">        ExporterChangeableWrapper&lt;T&gt; exporter &#x3D; (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class="line">        if (exporter &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized (bounds) &#123;</span><br><span class="line">                exporter &#x3D; (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class="line">                if (exporter &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    final Invoker&lt;?&gt; invokerDelegete &#x3D; new InvokerDelegete&lt;T&gt;(originInvoker, getProviderUrl(originInvoker));   &#x2F;&#x2F; @1</span><br><span class="line">                    exporter &#x3D; new ExporterChangeableWrapper&lt;T&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegete), originInvoker);    &#x2F;&#x2F; @2</span><br><span class="line">                    bounds.put(key, exporter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return exporter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果服务提供者以dubbo协议暴露服务，getProviderUrl(originInvoker)返回的URL将以dubbo://开头。<br>代码@2：根据Dubbo内置的SPI机制，将调用DubboProtocol#export方法。</p><h2 id="1、源码分析DubboProtocol-export"><a href="#1、源码分析DubboProtocol-export" class="headerlink" title="1、源码分析DubboProtocol#export"></a>1、源码分析DubboProtocol#export</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">        URL url &#x3D; invoker.getUrl();     &#x2F;&#x2F; @1</span><br><span class="line">        &#x2F;&#x2F; export service.</span><br><span class="line">        String key &#x3D; serviceKey(url);      &#x2F;&#x2F; @2</span><br><span class="line">        DubboExporter&lt;T&gt; exporter &#x3D; new DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">        exporterMap.put(key, exporter);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;export an stub service for dispatching event</span><br><span class="line">        Boolean isStubSupportEvent &#x3D; url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);    &#x2F;&#x2F;@3  start</span><br><span class="line">        Boolean isCallbackservice &#x3D; url.getParameter(Constants.IS_CALLBACK_SERVICE, false);                                                  </span><br><span class="line">        if (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;                                                                                                                        </span><br><span class="line">            String stubServiceMethods &#x3D; url.getParameter(Constants.STUB_EVENT_METHODS_KEY);</span><br><span class="line">            if (stubServiceMethods &#x3D;&#x3D; null || stubServiceMethods.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                if (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(new IllegalStateException(&quot;consumer [&quot; + url.getParameter(Constants.INTERFACE_KEY) +</span><br><span class="line">                            &quot;], has set stubproxy support event ,but no stub methods founded.&quot;));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);                                                                      </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   &#x2F;&#x2F; @3 end</span><br><span class="line"></span><br><span class="line">        openServer(url);   &#x2F;&#x2F; @4</span><br><span class="line">        optimizeSerialization(url);  &#x2F;&#x2F; @5</span><br><span class="line">        return exporter;                </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：获取服务提供者URL，以协议名称，这里是dubbo://开头。<br>代码@2：从服务提供者URL中获取服务名，key: interface:port，例如：com.alibaba.dubbo.demo.DemoService:20880。<br>代码@3：是否将转发事件导出成stub。<br>代码@4：根据url打开服务，下面将详细分析其实现。<br>代码@5：根据url优化器序列化方式。</p><h2 id="2、源码分析DubboProtocol-openServer"><a href="#2、源码分析DubboProtocol-openServer" class="headerlink" title="2、源码分析DubboProtocol#openServer"></a>2、源码分析DubboProtocol#openServer</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void openServer(URL url) &#123;</span><br><span class="line">        &#x2F;&#x2F; find server.</span><br><span class="line">        String key &#x3D; url.getAddress();    &#x2F;&#x2F; @1</span><br><span class="line">        &#x2F;&#x2F;client can export a service which&#39;s only for server to invoke</span><br><span class="line">        boolean isServer &#x3D; url.getParameter(Constants.IS_SERVER_KEY, true);</span><br><span class="line">        if (isServer) &#123;</span><br><span class="line">            ExchangeServer server &#x3D; serverMap.get(key);           &#x2F;&#x2F; @2</span><br><span class="line">            if (server &#x3D;&#x3D; null) &#123;</span><br><span class="line">                serverMap.put(key, createServer(url));                    &#x2F;&#x2F;@3</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; server supports reset, use together with override</span><br><span class="line">                server.reset(url);                                                       &#x2F;&#x2F;@4</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：根据url获取网络地址：ip:port，例如：192.168.56.1:20880，服务提供者IP与暴露服务端口号。<br>代码@2：根据key从服务器缓存中获取，如果存在，则执行代码@4，如果不存在，则执行代码@3.<br>代码@3：根据URL创建一服务器，Dubbo服务提供者服务器实现类为ExchangeServer。<br>代码@4：如果服务器已经存在，用当前URL重置服务器，这个不难理解，因为一个Dubbo服务中，会存在多个dubbo:service标签，这些标签都会在服务台提供者的同一个IP地址、端口号上暴露服务。</p><h3 id="2-1-源码分析DubboProtocol-createServer"><a href="#2-1-源码分析DubboProtocol-createServer" class="headerlink" title="2.1 源码分析DubboProtocol#createServer"></a>2.1 源码分析DubboProtocol#createServer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private ExchangeServer createServer(URL url) &#123;</span><br><span class="line">        &#x2F;&#x2F; send readonly event when server closes, it&#39;s enabled by default</span><br><span class="line">        url &#x3D; url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString());    &#x2F;&#x2F; @1</span><br><span class="line">        &#x2F;&#x2F; enable heartbeat by default</span><br><span class="line">        url &#x3D; url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));     &#x2F;&#x2F; @2</span><br><span class="line">        String str &#x3D; url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);  &#x2F;&#x2F; @3</span><br><span class="line"></span><br><span class="line">        if (str !&#x3D; null &amp;&amp; str.length() &gt; 0 &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str))    &#x2F;&#x2F; @4</span><br><span class="line">            throw new RpcException(&quot;Unsupported server type: &quot; + str + &quot;, url: &quot; + url);</span><br><span class="line"></span><br><span class="line">        url &#x3D; url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);       &#x2F;&#x2F; @5</span><br><span class="line">        ExchangeServer server;</span><br><span class="line">        try &#123;</span><br><span class="line">            server &#x3D; Exchangers.bind(url, requestHandler);    &#x2F;&#x2F; @6</span><br><span class="line">        &#125; catch (RemotingException e) &#123;</span><br><span class="line">            throw new RpcException(&quot;Fail to start server(url: &quot; + url + &quot;) &quot; + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        str &#x3D; url.getParameter(Constants.CLIENT_KEY);     &#x2F;&#x2F;@7</span><br><span class="line">        if (str !&#x3D; null &amp;&amp; str.length() &gt; 0) &#123;</span><br><span class="line">            Set&lt;String&gt; supportedTypes &#x3D; ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();</span><br><span class="line">            if (!supportedTypes.contains(str)) &#123;</span><br><span class="line">                throw new RpcException(&quot;Unsupported client type: &quot; + str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return server;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：为服务提供者url增加channel.readonly.sent属性，默认为true，表示在发送请求时，是否等待将字节写入socket后再返回，默认为true。<br>代码@2：为服务提供者url增加heartbeat属性，表示心跳间隔时间，默认为60*1000，表示60s。<br>代码@3：为服务提供者url增加server属性，可选值为netty,mina等等，默认为netty。<br>代码@4：根据SPI机制，判断server属性是否支持。<br>代码@5：为服务提供者url增加codec属性，默认值为dubbo，协议编码方式。<br>代码@6：根据服务提供者URI,服务提供者命令请求处理器requestHandler构建ExchangeServer实例。requestHandler的实现具体在以后详细分析Dubbo服务调用时再详细分析。<br>代码@7：验证客户端类型是否可用。</p><h4 id="2-1-1-源码分析Exchangers-bind-根据URL、ExchangeHandler构建服务器"><a href="#2-1-1-源码分析Exchangers-bind-根据URL、ExchangeHandler构建服务器" class="headerlink" title="2.1.1 源码分析Exchangers.bind 根据URL、ExchangeHandler构建服务器"></a>2.1.1 源码分析Exchangers.bind 根据URL、ExchangeHandler构建服务器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException &#123;</span><br><span class="line">        if (url &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;url &#x3D;&#x3D; null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (handler &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;handler &#x3D;&#x3D; null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        url &#x3D; url.addParameterIfAbsent(Constants.CODEC_KEY, &quot;exchange&quot;);</span><br><span class="line">        return getExchanger(url).bind(url, handler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述代码不难看出，首先根据url获取Exchanger实例，然后调用bind方法构建ExchangeServer，Exchanger接口如下<br><img src="https://img-blog.csdn.net/20180605225624607?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><ul><li>ExchangeServer bind(URL url, ExchangeHandler handler) : 服务提供者调用。</li><li>ExchangeClient connect(URL url, ExchangeHandler handler):服务消费者调用。</li></ul><p>dubbo提供的实现类为：HeaderExchanger，其bind方法如下：</p><p>HeaderExchanger#bind</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException &#123;</span><br><span class="line">        return new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出，端口的绑定由Transporters的bind方法实现。</p><h4 id="2-1-2-源码分析Transporters-bind方法"><a href="#2-1-2-源码分析Transporters-bind方法" class="headerlink" title="2.1.2 源码分析Transporters.bind方法"></a>2.1.2 源码分析Transporters.bind方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static Server bind(URL url, ChannelHandler... handlers) throws RemotingException &#123;</span><br><span class="line">        if (url &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;url &#x3D;&#x3D; null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (handlers &#x3D;&#x3D; null || handlers.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;handlers &#x3D;&#x3D; null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        ChannelHandler handler;</span><br><span class="line">        if (handlers.length &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            handler &#x3D; handlers[0];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            handler &#x3D; new ChannelHandlerDispatcher(handlers);</span><br><span class="line">        &#125;</span><br><span class="line">        return getTransporter().bind(url, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public static Transporter getTransporter() &#123;</span><br><span class="line">        return ExtensionLoader.getExtensionLoader(Transporter.class).getAdaptiveExtension();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里得知，Dubbo网络传输的接口有Transporter接口实现，其继承类图所示：<br><img src="https://img-blog.csdn.net/20180605225739594?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>本文以netty版本来查看一下Transporter实现。</p><p>NettyTransporter源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class NettyTransporter implements Transporter &#123;</span><br><span class="line"></span><br><span class="line">    public static final String NAME &#x3D; &quot;netty&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Server bind(URL url, ChannelHandler listener) throws RemotingException &#123;</span><br><span class="line">        return new NettyServer(url, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Client connect(URL url, ChannelHandler listener) throws RemotingException &#123;</span><br><span class="line">        return new NettyClient(url, listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NettyServer建立网络连接的实现方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">protected void doOpen() throws Throwable &#123;</span><br><span class="line">        NettyHelper.setNettyLoggerFactory();</span><br><span class="line">        ExecutorService boss &#x3D; Executors.newCachedThreadPool(new NamedThreadFactory(&quot;NettyServerBoss&quot;, true));</span><br><span class="line">        ExecutorService worker &#x3D; Executors.newCachedThreadPool(new NamedThreadFactory(&quot;NettyServerWorker&quot;, true));</span><br><span class="line">        ChannelFactory channelFactory &#x3D; new NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));</span><br><span class="line">        bootstrap &#x3D; new ServerBootstrap(channelFactory);</span><br><span class="line"></span><br><span class="line">        final NettyHandler nettyHandler &#x3D; new NettyHandler(getUrl(), this);      &#x2F;&#x2F; @1</span><br><span class="line">        channels &#x3D; nettyHandler.getChannels();</span><br><span class="line">        &#x2F;&#x2F; https:&#x2F;&#x2F;issues.jboss.org&#x2F;browse&#x2F;NETTY-365</span><br><span class="line">        &#x2F;&#x2F; https:&#x2F;&#x2F;issues.jboss.org&#x2F;browse&#x2F;NETTY-379</span><br><span class="line">        &#x2F;&#x2F; final Timer timer &#x3D; new HashedWheelTimer(new NamedThreadFactory(&quot;NettyIdleTimer&quot;, true));</span><br><span class="line">        bootstrap.setPipelineFactory(new ChannelPipelineFactory() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public ChannelPipeline getPipeline() &#123;</span><br><span class="line">                NettyCodecAdapter adapter &#x3D; new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);</span><br><span class="line">                ChannelPipeline pipeline &#x3D; Channels.pipeline();</span><br><span class="line">                &#x2F;*int idleTimeout &#x3D; getIdleTimeout();</span><br><span class="line">                if (idleTimeout &gt; 10000) &#123;</span><br><span class="line">                    pipeline.addLast(&quot;timer&quot;, new IdleStateHandler(timer, idleTimeout &#x2F; 1000, 0, 0));</span><br><span class="line">                &#125;*&#x2F;</span><br><span class="line">                pipeline.addLast(&quot;decoder&quot;, adapter.getDecoder());</span><br><span class="line">                pipeline.addLast(&quot;encoder&quot;, adapter.getEncoder());</span><br><span class="line">                pipeline.addLast(&quot;handler&quot;, nettyHandler);     &#x2F;&#x2F; @2</span><br><span class="line">                return pipeline;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F; bind</span><br><span class="line">        channel &#x3D; bootstrap.bind(getBindAddress());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>熟悉本方法需要具备Netty的知识，有关源码：<a href="https://blog.csdn.net/prestigeding/article/details/53977445">阅读Netty系列文章</a>，这里不对每一行代码进行解读，对于与网络相关的参数，将在后续文章中详细讲解，本方法@1、@2引起了我的注意，首先创建NettyServer必须传入一个服务提供者URL，但从DubboProtocol#createServer中可以看出，Server是基于网络套接字（ip:port）缓存的，一个JVM应用中，必然会存在多个dubbo:server标签，就会有多个URL，这里为什么可以这样做呢？从DubboProtocol#createServer中可以看出，在解析第二个dubbo:service标签时并不会调用createServer,而是会调用Server#reset方法，是不是这个方法有什么魔法，在reset方法时能将URL也注册到Server上，那接下来分析NettyServer#reset方法是如何实现的。</p><h3 id="2-2源码分析DdubboProtocol-reset"><a href="#2-2源码分析DdubboProtocol-reset" class="headerlink" title="2.2源码分析DdubboProtocol#reset"></a>2.2源码分析DdubboProtocol#reset</h3><p>reset方法最终将用Server的reset方法，同样还是以netty版本的NettyServer为例，查看reset方法的实现原理。NettyServer#reset—&gt;父类(AbstractServer)</p><p>AbstractServer#reset</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public void reset(URL url) &#123;</span><br><span class="line">        if (url &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;                                                                                                       &#x2F;&#x2F; @1 start</span><br><span class="line">            if (url.hasParameter(Constants.ACCEPTS_KEY)) &#123;</span><br><span class="line">                int a &#x3D; url.getParameter(Constants.ACCEPTS_KEY, 0);</span><br><span class="line">                if (a &gt; 0) &#123;</span><br><span class="line">                    this.accepts &#x3D; a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            logger.error(t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (url.hasParameter(Constants.IDLE_TIMEOUT_KEY)) &#123;</span><br><span class="line">                int t &#x3D; url.getParameter(Constants.IDLE_TIMEOUT_KEY, 0);</span><br><span class="line">                if (t &gt; 0) &#123;</span><br><span class="line">                    this.idleTimeout &#x3D; t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            logger.error(t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (url.hasParameter(Constants.THREADS_KEY)</span><br><span class="line">                    &amp;&amp; executor instanceof ThreadPoolExecutor &amp;&amp; !executor.isShutdown()) &#123;</span><br><span class="line">                ThreadPoolExecutor threadPoolExecutor &#x3D; (ThreadPoolExecutor) executor;</span><br><span class="line">                int threads &#x3D; url.getParameter(Constants.THREADS_KEY, 0);</span><br><span class="line">                int max &#x3D; threadPoolExecutor.getMaximumPoolSize();</span><br><span class="line">                int core &#x3D; threadPoolExecutor.getCorePoolSize();</span><br><span class="line">                if (threads &gt; 0 &amp;&amp; (threads !&#x3D; max || threads !&#x3D; core)) &#123;</span><br><span class="line">                    if (threads &lt; core) &#123;</span><br><span class="line">                        threadPoolExecutor.setCorePoolSize(threads);</span><br><span class="line">                        if (core &#x3D;&#x3D; max) &#123;</span><br><span class="line">                            threadPoolExecutor.setMaximumPoolSize(threads);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        threadPoolExecutor.setMaximumPoolSize(threads);</span><br><span class="line">                        if (core &#x3D;&#x3D; max) &#123;</span><br><span class="line">                            threadPoolExecutor.setCorePoolSize(threads);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            logger.error(t.getMessage(), t);</span><br><span class="line">        &#125;              &#x2F;&#x2F; @1 end</span><br><span class="line">        super.setUrl(getUrl().addParameters(url.getParameters()));    &#x2F;&#x2F; @2</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先是调整线程池的相关线程数量，这个好理解。、<br>代码@2：然后设置调用setUrl覆盖原先NettyServer的private volatile URL url的属性，那为什么不会影响原先注册的dubbo:server呢？<br>原来NettyHandler上加了注解：@Sharable，由该注解去实现线程安全。</p><p>Dubbo服务提供者启动流程将分析到这里了，本文并未对网络细节进行详细分析，旨在梳理出启动流程，有关Dubbo服务网络实现原理将在后续章节中详细分析，敬请期待。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文继续上文Dubbo服务提供者启动流程，在上篇文章中详细梳理了基于dubbo spring文件的配置方式，Dubbo是如何加载配置文件，服务提供者dubbo:service标签服务暴露全流程，本节重点关注RegistryProtocol#export中调用doLocalExport方法，其实主要是根据各自协议，服务提供者建立网络服务器，在特定端口建立监听，监听来自消息消费端服务的请求。&lt;/p&gt;</summary>
    
    
    
    <category term="dubbo" scheme="http://example.com/categories/dubbo/"/>
    
    
    <category term="dubbo" scheme="http://example.com/tags/dubbo/"/>
    
    <category term="服务提供者" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85/"/>
    
    <category term="启动" scheme="http://example.com/tags/%E5%90%AF%E5%8A%A8/"/>
    
    <category term="网络监听" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%9B%91%E5%90%AC/"/>
    
  </entry>
  
  <entry>
    <title>源码分析Dubbo前置篇-寻找注册中心、服务提供者、服务消费者功能入口</title>
    <link href="http://example.com/posts/62f3002e.html"/>
    <id>http://example.com/posts/62f3002e.html</id>
    <published>2020-12-12T14:40:01.000Z</published>
    <updated>2020-12-12T15:44:36.432Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p> 本节主要阐述如下两个问题：</p><ol><li><p>Dubbo自定义标签实现。</p></li><li><p>dubbo通过Spring加载配置文件后，是如何触发注册中心、服务提供者、服务消费者按照Dubbo的设计执行相关的功能。</p><p>所谓的执行相关功能如下：</p></li></ol><ul><li><p>注册中心启动，监听消息提供者的注册服务、接收消息消费者的服务订阅（服务注册与发现机制）。</p></li><li><p>服务提供者向注册中心注册服务。</p></li><li><p>服务消费者向注册中心订阅服务。</p><p>接下来从使用dubbo的角度，从配置文件入手：</p></li></ul><h2 id="1、Dubbo服务提供者的一般配置如下："><a href="#1、Dubbo服务提供者的一般配置如下：" class="headerlink" title="1、Dubbo服务提供者的一般配置如下："></a>1、Dubbo服务提供者的一般配置如下：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span><br><span class="line">&lt;dubbo:application name&#x3D;&quot;uop&quot; owner&#x3D;&quot;uce&quot;&#x2F;&gt;</span><br><span class="line">&lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt;</span><br><span class="line">&lt;dubbo:registry protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;zookeeper:&#x2F;&#x2F;192.168.xx.xx:2181?backup&#x3D;192.168.xx.xx:2182,192.168.xx.xx:2183&quot; &#x2F;&gt;</span><br><span class="line">&lt;!--dubbox中引入Kryo和FST这两种高效Java序列化实现，来逐步取代原生dubbo中的hessian2,如果使用kryo记得添加依赖 --&gt;</span><br><span class="line">&lt;dubbo:protocol name&#x3D;&quot;dubbo&quot; serialization&#x3D;&quot;kryo&quot;  port&#x3D;&quot;20990&quot;  &#x2F;&gt;</span><br><span class="line">&lt;!-- 定义服务提供者默认属性值 --&gt;</span><br><span class="line">&lt;dubbo:provider timeout&#x3D;&quot;5000&quot; threadpool&#x3D;&quot;fixed&quot;  threads&#x3D;&quot;100&quot; accepts&#x3D;&quot;1000&quot; token&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">&lt;!-- 暴露服务接口 一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心--&gt;</span><br><span class="line">&lt;!--Provider上尽量多配置Consumer端的属性，让Provider实现者一开始就思考Provider服务特点、服务质量的问题--&gt;</span><br><span class="line">&lt;dubbo:service interface&#x3D;&quot;com.yingjun.dubbox.api.UserService&quot; ref&#x3D;&quot;userService&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>上面通过dubbo提供的dubbo:application、dubbo:registry、dubbo:protocol、dubbo:provider、dubbo:service分别定义dubbo应用程序名、注册中心、协议、服务提供者参数默认值、服务提供者，这些配置后面的实现原理是什么呢？是如何启动并发挥相关作用的呢？</p><a id="more"></a><h2 id="2、Spring自定义标签即命令空间实现"><a href="#2、Spring自定义标签即命令空间实现" class="headerlink" title="2、Spring自定义标签即命令空间实现"></a>2、Spring自定义标签即命令空间实现</h2><p>dubbo自定义标签与命名空间其实现代码在模块dubbo-config中，其核心实现如下：</p><h3 id="2-1-DubboNamespaceHandler"><a href="#2-1-DubboNamespaceHandler" class="headerlink" title="2.1 DubboNamespaceHandler"></a>2.1 DubboNamespaceHandler</h3><p>dubbo 命名空间实现 handler，其全路径：com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler，其源码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class DubboNamespaceHandler extends NamespaceHandlerSupport &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        Version.checkDuplicate(DubboNamespaceHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        registerBeanDefinitionParser(&quot;application&quot;, new DubboBeanDefinitionParser(ApplicationConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;module&quot;, new DubboBeanDefinitionParser(ModuleConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;registry&quot;, new DubboBeanDefinitionParser(RegistryConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;monitor&quot;, new DubboBeanDefinitionParser(MonitorConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;provider&quot;, new DubboBeanDefinitionParser(ProviderConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;consumer&quot;, new DubboBeanDefinitionParser(ConsumerConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;protocol&quot;, new DubboBeanDefinitionParser(ProtocolConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;service&quot;, new DubboBeanDefinitionParser(ServiceBean.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;reference&quot;, new DubboBeanDefinitionParser(ReferenceBean.class, false));</span><br><span class="line">        registerBeanDefinitionParser(&quot;annotation&quot;, new AnnotationBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出，dubbo自定义的标签主要包括：application、module、registry、monitor、provider、consumer、protocol、service、reference、annotation，其具体解析实现类主要包括：DubboBeanDefinitionParser(基于xml配置文件)、AnnotationBeanDefinitionParser(基于注解)，下文会详细分析上述两个解析类的实现。</p><h3 id="2-2-定义dubbo-xsd-文件"><a href="#2-2-定义dubbo-xsd-文件" class="headerlink" title="2.2 定义dubbo.xsd 文件"></a>2.2 定义dubbo.xsd 文件</h3><p> 在dubbo-config-spring模块下的 src/main/resouce/META-INF中分别定义dubbo.xsd、spring.handlers、spring.schemas。<br> 关于Spring如何新增命名空间与标签，在源码分析ElasticJob时已经详细介绍过，再这里就不做 过多重复，如需了解，请查看：<a href="https://blog.csdn.net/prestigeding/article/details/79751023">https://blog.csdn.net/prestigeding/article/details/79751023</a></p><h2 id="3、Bean解析机制-Spring基础知识"><a href="#3、Bean解析机制-Spring基础知识" class="headerlink" title="3、Bean解析机制(Spring基础知识)"></a>3、Bean解析机制(Spring基础知识)</h2><p> 我们应该知道，Spirng的配置支持xml配置文件与注解的方式,故Dubbo也支持两种配置方式，xml与注解方式。</p><h3 id="3-1-xml配置方式解析"><a href="#3-1-xml配置方式解析" class="headerlink" title="3.1 xml配置方式解析"></a>3.1 xml配置方式解析</h3><p><img src="https://img-blog.csdn.net/20180528231944883?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br> BeanDefinitionParser：Spring定义的bean解析器，要实现自定义标签，则需要实现该接口，然后通过NamespaceHandlerSupport将Bean定义解析器注册到Spring bean解析器中。从接口中可以看出，其终极目标就是将Element element(xml节点)解析成BeanDefinition，有关于Spring BeanDefinition，请参考：<a href="https://blog.csdn.net/prestigeding/article/details/80490206">https://blog.csdn.net/prestigeding/article/details/80490206</a><br> DubboBeanDefinitionParser构造函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public DubboBeanDefinitionParser(Class&lt;?&gt; beanClass, boolean required) &#123;</span><br><span class="line">        this.beanClass &#x3D; beanClass;</span><br><span class="line">        this.required &#x3D; required;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> beanClass：该xml标签节点最终会被Spring实例化的类名。<br> required：该标签的ID是否必须。<br>| 标签名称          |       类名        |<br>| —————– | :—————: |<br>| dubbo:application | ApplicationConfig |<br>| dubbo:module      |   ModuleConfig    |<br>| dubbo:registry    |  RegistryConfig   |<br>| dubbo:monitor     |   MonitorConfig   |<br>| dubbo:provider    |  ProviderConfig   |<br>| dubbo:consumer    |  ConsumerConfig   |<br>| dubbo:protocol    |  ProtocolConfig   |<br>| dubbo:service     |    ServiceBean    |<br>| dubbo:reference   |   ReferenceBean   |<br> 注，包名：com.alibaba.dubbo.config<br> bean解析器的主要目的就是将上述标签，解析成对应的BeanDifinition，以便Spring构建上述类的实例。<br>本节不拷贝DubboBeanDefinitionParser根据xml定义的标签与属性转换成BeanDefinitionParser的每一行代码，本节只给出其大体关键点。<br> Step1：解析id属性，如果DubboBeanDefinitionParser对象的required属性为true，如果id为空，则根据如下规则构建一个id。</p><ul><li><p>如果name属性不为空，则取name的值，如果已存在，则为 name + 序号,例如  name,name1,name2。</p></li><li><p>如果name属性为空，如果是dubbo:protocol标签，则取protocol属性，其他的则取interface属性，如果不为空，则取该值，但如果已存在，和name处理相同，在后面追加序号。</p></li><li><p>如果第二步还未空，则取beanClass的名称，如果已存在，则追加序号。</p><p>Step2：根据不同的标签解析特殊属性。</p></li><li><p>dubbo:protocol,添加protocol属性(BeanDefinition)。</p></li><li><p>dubbo:service,添加ref属性。</p></li><li><p>dubbo:provider，嵌套解析,dubbo:provider标签有两个可选的子标签,dubbo:service、dubbo:parameter,这里需要嵌套解析dubbo:service标签<br>知识点：dubbo:provider是配置服务提供者的默认参数，在dubbo spring配置文件中可以配置多个dubbo:provider,那dubbo:service标签如何选取一个合适的dubbo:provider作为其默认参数呢？有两种办法：</p></li></ul><ol><li>将dubbo:service标签直接声明在dubbo:provider方法</li><li>在dubbo:service中通过provider属性指定一个provider配置，如果不填，并且存在多个dubbo:provider配置，则会抛出错误。</li></ol><ul><li>dubbo:customer：解析嵌套标签，其原理与dubbo:provider解析一样。</li></ul><p>Step3：解析标签，将属性与值填充到BeanDefinition的propertyValues中。最终返回BeanDefinition实例，供Spring实例化Bean。</p><p>上述已经解答了Dubbo自定义标签的解析实现，主要完成了ApplicationConfig、RegistryConfig、ServiceBean、ReferenceBean实例的初始化，那什么时候构建与注册中心的连接、服务提供者什么时候会向注册中心注册服务，服务消费者向注册中心订阅服务呢？</p><p>通过上述步骤，我们已经知道已经成功解析注册中心、服务提供者、服务消费者的配置元信息，并将其实例化，按照我们的思路，配置对象生成后，下一步应该是实现Dubbo服务的注册与发现机制，但代码中无法找到相关代码。</p><p>据我目前所掌握的知识，Spring在对象实例化，一般有两种方式来对Bean做一些定制化处理。</p><ol><li><p>实现BeanPostProcessor Spring后置处理器，在Bean初始化前后执行相关操作。</p></li><li><p>Bean实现InitializingBean接口(init-method)</p><p>浏览表格中所有Bean的声明，发现了两个类非常特殊：<br><img src="https://img-blog.csdn.net/20180528232923748?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>ServiceBean(服务提供者)与ReferenceBean(服务消费者)比较特殊，实现了Spring与Bean生命周期相关的接口。</p></li></ol><ul><li>InitializingBean，其声明的接口为afterPropertiesSet方法，顾名思义，就是在bean初始化所有属性之后调用。</li><li>DisposableBean：其声明的接口为destroy()方法，在Spring BeanFactory销毁一个单例实例之前调用。</li><li>ApplicationContextAware：其声明的接口为void setApplicationContext(ApplicationContext applicationContext)，实现了该接口，Spring容器在初始化Bean时会调用该方法，注入ApplicationContext，已方便该实例可以直接调用applicationContext获取其他Bean。</li><li>ApplicationListener&lt; ContextRefreshedEvent&gt;：容器重新刷新时执行事件函数。</li><li>BeanNameAware：其声明的接口为：void setBeanName(String name)，实现该接口的Bean，其实例可以获取该实例在BeanFactory的id或name。</li><li>FactoryBean：Spring初始化Bean的另外一种方式，例如dubbo:reference，需要返回的对象并不是ReferenceBean,而是要返回ref指定的代理类来执行业务操作，故这里使用FactoryBean非常合适，FactoryBean定义了如下三个方法：<ul><li>T getObject() throws Exception：获取需要返回的结果对象。</li><li>Class&lt;?&gt; getObjectType()：获取返回对象的类型。</li><li>boolean isSingleton()：返回是否是单例。</li></ul></li></ul><p>看到这里，不免有一点小激动，似乎已经摸到Dubbo服务注册与发现机制（Dubbo服务提供者、Dubbo服务消费者、注册中心的启动流程入口点了，下一步就是分析ServiceBean、ReferenceBean的实现原理，试图揭开Dubbo服务注册与发现机制，该部分内容将在下一篇中详细分析。</p><h3 id="3-2-注解配置方式解析"><a href="#3-2-注解配置方式解析" class="headerlink" title="3.2 注解配置方式解析"></a>3.2 注解配置方式解析</h3><p>注解配置方式的解析入口类：AnnotationBeanDefinitionParser，也是基于Spring注解解析逻辑，这部分在将在未来《Spring系列进阶篇-源码分析注解解析实现原理》中详细分析，目前暂未深究，读者朋友们，如果有兴趣，可以以AnnotationBeanDefinitionParser为入口，进行进一步的分析。</p><p>本节就讲解到这里了，下一篇将重点分析ServiceBean(服务提供者启动流程)。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt; 本节主要阐述如下两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Dubbo自定义标签实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;dubbo通过Spring加载配置文件后，是如何触发注册中心、服务提供者、服务消费者按照Dubbo的设计执行相关的功能。&lt;/p&gt;
&lt;p&gt;所谓的执行相关功能如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;注册中心启动，监听消息提供者的注册服务、接收消息消费者的服务订阅（服务注册与发现机制）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务提供者向注册中心注册服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务消费者向注册中心订阅服务。&lt;/p&gt;
&lt;p&gt;接下来从使用dubbo的角度，从配置文件入手：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1、Dubbo服务提供者的一般配置如下：&quot;&gt;&lt;a href=&quot;#1、Dubbo服务提供者的一般配置如下：&quot; class=&quot;headerlink&quot; title=&quot;1、Dubbo服务提供者的一般配置如下：&quot;&gt;&lt;/a&gt;1、Dubbo服务提供者的一般配置如下：&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!-- 提供方应用信息，用于计算依赖关系 --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dubbo:application name&amp;#x3D;&amp;quot;uop&amp;quot; owner&amp;#x3D;&amp;quot;uce&amp;quot;&amp;#x2F;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!-- 使用zookeeper注册中心暴露服务地址 --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dubbo:registry protocol&amp;#x3D;&amp;quot;zookeeper&amp;quot; address&amp;#x3D;&amp;quot;zookeeper:&amp;#x2F;&amp;#x2F;192.168.xx.xx:2181?backup&amp;#x3D;192.168.xx.xx:2182,192.168.xx.xx:2183&amp;quot; &amp;#x2F;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!--dubbox中引入Kryo和FST这两种高效Java序列化实现，来逐步取代原生dubbo中的hessian2,如果使用kryo记得添加依赖 --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dubbo:protocol name&amp;#x3D;&amp;quot;dubbo&amp;quot; serialization&amp;#x3D;&amp;quot;kryo&amp;quot;  port&amp;#x3D;&amp;quot;20990&amp;quot;  &amp;#x2F;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!-- 定义服务提供者默认属性值 --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dubbo:provider timeout&amp;#x3D;&amp;quot;5000&amp;quot; threadpool&amp;#x3D;&amp;quot;fixed&amp;quot;  threads&amp;#x3D;&amp;quot;100&amp;quot; accepts&amp;#x3D;&amp;quot;1000&amp;quot; token&amp;#x3D;&amp;quot;true&amp;quot;&amp;#x2F;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!-- 暴露服务接口 一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心--&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!--Provider上尽量多配置Consumer端的属性，让Provider实现者一开始就思考Provider服务特点、服务质量的问题--&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dubbo:service interface&amp;#x3D;&amp;quot;com.yingjun.dubbox.api.UserService&amp;quot; ref&amp;#x3D;&amp;quot;userService&amp;quot; &amp;#x2F;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面通过dubbo提供的dubbo:application、dubbo:registry、dubbo:protocol、dubbo:provider、dubbo:service分别定义dubbo应用程序名、注册中心、协议、服务提供者参数默认值、服务提供者，这些配置后面的实现原理是什么呢？是如何启动并发挥相关作用的呢？&lt;/p&gt;</summary>
    
    
    
    <category term="dubbo" scheme="http://example.com/categories/dubbo/"/>
    
    
    <category term="dubbo" scheme="http://example.com/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>源码分析Dubbo服务提供者启动流程-上篇</title>
    <link href="http://example.com/posts/80b68fd8.html"/>
    <id>http://example.com/posts/80b68fd8.html</id>
    <published>2020-12-12T14:40:01.000Z</published>
    <updated>2020-12-12T15:44:36.442Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本节将详细分析Dubbo服务提供者的启动流程，请带着如下几个疑问进行本节的阅读，因为这几个问题将是接下来几篇文章分析的重点内容。</p><ol><li>什么时候建立与注册中心的连接。</li><li>服务提供者什么时候向注册中心注册服务。</li><li>服务提供者与注册中心的心跳机制。</li></ol><a id="more"></a><p>从上文中我们得知，服务提供者启动的核心入口为ServiceBean,本节将从源码级别详细剖析ServcieBean的实现原理，即Dubbo服务提供者的启动流程，ServiceBean的继承层次如图所示，dubbo:service标签的所有属性都被封装在此类图结构中。<br><img src="https://img-blog.csdn.net/20180601130421654?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h2 id="1、源码分析ServiceBean-afterPropertiesSet"><a href="#1、源码分析ServiceBean-afterPropertiesSet" class="headerlink" title="1、源码分析ServiceBean#afterPropertiesSet"></a>1、源码分析ServiceBean#afterPropertiesSet</h2><p> ServiceBean#afterPropertiesSet</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (getProvider() &#x3D;&#x3D; null) &#123;  &#x2F;&#x2F; @1</span><br><span class="line">    Map&lt;String, ProviderConfig&gt; provide</span><br><span class="line">             ConfigMap &#x3D; applicationContext &#x3D;&#x3D; null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProviderConfig.class,   false, false); &#x2F;&#x2F; @2</span><br><span class="line">              &#x2F;&#x2F; ......  具体解析代码省略。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step1：如果provider为空，说明dubbo:service标签未设置provider属性，如果一个dubbo:provider标签，则取该实例，如果存在多个dubbo:provider配置则provider属性不能为空，否则抛出异常：”Duplicate provider configs”。</p><p>ServiceBean#afterPropertiesSet</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (getApplication() &#x3D;&#x3D; null</span><br><span class="line">        &amp;&amp; (getProvider() &#x3D;&#x3D; null || getProvider().getApplication() &#x3D;&#x3D; null)) &#123;</span><br><span class="line">      Map&lt;String, ApplicationConfig&gt; applicationConfigMap &#x3D; applicationContext &#x3D;&#x3D; null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, </span><br><span class="line">                 ApplicationConfig.class, false, false);</span><br><span class="line">       &#x2F;&#x2F; ...省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step2：如果application为空,则尝试从BeanFactory中查询dubbo:application实例，如果存在多个dubbo:application配置，则抛出异常：”Duplicate application configs”。</p><p>Step3：如果ServiceBean的module为空，则尝试从BeanFactory中查询dubbo:module实例，如果存在多个dubbo:module，则抛出异常：”Duplicate module configs: “。</p><p>Step4：尝试从BeanFactory中加载所有的注册中心，注意ServiceBean的List&lt; RegistryConfig&gt; registries属性，为注册中心集合。</p><p>Step5：尝试从BeanFacotry中加载一个监控中心，填充ServiceBean的MonitorConfig monitor属性，如果存在多个dubbo:monitor配置，则抛出”Duplicate monitor configs: “。</p><p>Step6：尝试从BeanFactory中加载所有的协议，注意：ServiceBean的List&lt; ProtocolConfig&gt; protocols是一个集合，也即一个服务可以通过多种协议暴露给消费者。</p><p>ServiceBean#afterPropertiesSet</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (getPath() &#x3D;&#x3D; null || getPath().length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">       if (beanName !&#x3D; null &amp;&amp; beanName.length() &gt; 0 &amp;&amp; getInterface() !&#x3D; null &amp;&amp; getInterface().length() &gt; 0  &amp;&amp; beanName.startsWith(getInterface())) &#123;</span><br><span class="line">                setPath(beanName);</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>Step7：设置ServiceBean的path属性，path属性存放的是dubbo:service的beanName（dubbo:service id)。</p><p>ServiceBean#afterPropertiesSet</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!isDelay()) &#123;</span><br><span class="line">     export();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step8：如果为启用延迟暴露机制，则调用export暴露服务。首先看一下isDelay的实现，然后重点分析export的实现原理（服务暴露的整个实现原理）。</p><p>ServiceBean#isDelay</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private boolean isDelay() &#123;</span><br><span class="line">        Integer delay &#x3D; getDelay();</span><br><span class="line">        ProviderConfig provider &#x3D; getProvider();</span><br><span class="line">        if (delay &#x3D;&#x3D; null &amp;&amp; provider !&#x3D; null) &#123;</span><br><span class="line">            delay &#x3D; provider.getDelay();</span><br><span class="line">        &#125;</span><br><span class="line">        return supportedApplicationListener &amp;&amp; (delay &#x3D;&#x3D; null || delay &#x3D;&#x3D; -1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果有设置dubbo:service或dubbo:provider的属性delay，或配置delay为-1,都表示启用延迟机制，单位为毫秒，设置为-1，表示等到Spring容器初始化后再暴露服务。从这里也可以看出，Dubbo暴露服务的处理入口为ServiceBean#export—》ServiceConfig#export。</p><h3 id="1-1-源码分析ServiceConfig-export-暴露服务"><a href="#1-1-源码分析ServiceConfig-export-暴露服务" class="headerlink" title="1.1 源码分析ServiceConfig#export 暴露服务"></a>1.1 源码分析ServiceConfig#export 暴露服务</h3><p>调用链：ServiceBean#afterPropertiesSet——&gt;ServiceConfig#export</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void export() &#123;</span><br><span class="line">        if (provider !&#x3D; null) &#123;</span><br><span class="line">            if (export &#x3D;&#x3D; null) &#123;</span><br><span class="line">                export &#x3D; provider.getExport();</span><br><span class="line">            &#125;</span><br><span class="line">            if (delay &#x3D;&#x3D; null) &#123;</span><br><span class="line">                delay &#x3D; provider.getDelay();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (export !&#x3D; null &amp;&amp; !export) &#123;   &#x2F;&#x2F; @1</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (delay !&#x3D; null &amp;&amp; delay &gt; 0) &#123;    &#x2F;&#x2F; @2</span><br><span class="line">            delayExportExecutor.schedule(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    doExport();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, delay, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            doExport();    &#x2F;&#x2F;@3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：判断是否暴露服务，由dubbo:service export=”true|false”来指定。<br>代码@2：如果启用了delay机制，如果delay大于0，表示延迟多少毫秒后暴露服务，使用ScheduledExecutorService延迟调度，最终调用doExport方法。<br>代码@3：执行具体的暴露逻辑doExport，需要大家留意：delay=-1的处理逻辑（基于Spring事件机制触发）。</p><h3 id="1-2-源码分析ServiceConfig-doExport暴露服务"><a href="#1-2-源码分析ServiceConfig-doExport暴露服务" class="headerlink" title="1.2 源码分析ServiceConfig#doExport暴露服务"></a>1.2 源码分析ServiceConfig#doExport暴露服务</h3><p>调用链：ServiceBean#afterPropertiesSet—调用——&gt;ServiceConfig#export——&gt;ServiceConfig#doExport</p><p>ServiceConfig#checkDefault</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void checkDefault() &#123;</span><br><span class="line">        if (provider &#x3D;&#x3D; null) &#123;</span><br><span class="line">            provider &#x3D; new ProviderConfig();</span><br><span class="line">        &#125;</span><br><span class="line">        appendProperties(provider);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>Step1:如果dubbo:servce标签也就是ServiceBean的provider属性为空，调用appendProperties方法，填充默认属性，其具体加载顺序：</p><ol><li>从系统属性加载对应参数值，参数键：dubbo.provider.属性名，System.getProperty。</li><li>加载属性配置文件的值。属性配置文件，可通过系统属性：dubbo.properties.file，如果该值未配置，则默认取dubbo.properties属性配置文件。</li></ol><p>ServiceConfig#doExport</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if (ref instanceof GenericService) &#123;</span><br><span class="line">      interfaceClass &#x3D; GenericService.class;</span><br><span class="line">      if (StringUtils.isEmpty(generic)) &#123;</span><br><span class="line">           generic &#x3D; Boolean.TRUE.toString();</span><br><span class="line">      &#125;</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">            interfaceClass &#x3D; Class.forName(interfaceName, true, Thread.currentThread()</span><br><span class="line">                        .getContextClassLoader());</span><br><span class="line">       &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            throw new IllegalStateException(e.getMessage(), e);</span><br><span class="line">       &#125;</span><br><span class="line">       checkInterfaceAndMethods(interfaceClass, methods);</span><br><span class="line">       checkRef();</span><br><span class="line">       generic &#x3D; Boolean.FALSE.toString();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>Step2：校验ref与interface属性。如果ref是GenericService，则为dubbo的泛化实现，然后验证interface接口与ref引用的类型是否一致。</p><p>ServiceConfig#doExport</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (local !&#x3D; null) &#123;</span><br><span class="line">      if (&quot;true&quot;.equals(local)) &#123;</span><br><span class="line">            local &#x3D; interfaceName + &quot;Local&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">      Class&lt;?&gt; localClass;</span><br><span class="line">      try &#123;</span><br><span class="line">             localClass &#x3D; ClassHelper.forNameWithThreadContextClassLoader(local);</span><br><span class="line">       &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            throw new IllegalStateException(e.getMessage(), e);</span><br><span class="line">       &#125;</span><br><span class="line">      if (!interfaceClass.isAssignableFrom(localClass)) &#123;</span><br><span class="line">           throw new IllegalStateException(&quot;The local implementation class &quot; + localClass.getName() + &quot; not implement interface &quot; + interfaceName);</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>Step3：dubbo:service local机制，已经废弃，被stub属性所替换。<br>Step4：处理本地存根Stub，&lt;dubbo:service 的stub属性，可以设置为true，此时Stub的类名为：interface+Stub，stub也可以指定自定义的全类名。本地存根说明如图所示（Dubbo官方文档）<br><img src="https://img-blog.csdn.net/2018060113090393?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>ServiceConfig#doExport</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">checkApplication();</span><br><span class="line">checkRegistry();</span><br><span class="line">checkProtocol();</span><br><span class="line">appendProperties(this);</span><br></pre></td></tr></table></figure><p>Step5：校验ServiceBean的application、registry、protocol是否为空，并从系统属性（优先）、资源文件中填充其属性。<br> 系统属性、资源文件属性的配置如下：<br> application     dubbo.application.属性名，例如    dubbo.application.name<br> registry          dubbo.registry.属性名，例如    dubbo.registry.address<br> protocol         dubbo.protocol.属性名，例如 dubbo.protocol.port<br> service           dubbo.service.属性名，例如 dubbo.service.stub</p><p>ServiceConfig#doExport</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checkStubAndMock(interfaceClass);</span><br></pre></td></tr></table></figure><p>Step6：校验stub、mock类的合理性，是否是interface的实现类。</p><p>ServiceConfig#doExport</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doExportUrls();</span><br></pre></td></tr></table></figure><p>Step7：执行doExportUrls()方法暴露服务，接下来会重点分析该方法。</p><p> ServiceConfig#doExport</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProviderModel providerModel &#x3D; new ProviderModel(getUniqueServiceName(), this, ref);</span><br><span class="line">ApplicationModel.initProviderModel(getUniqueServiceName(), providerModel);</span><br></pre></td></tr></table></figure><p>Step8：将服务提供者信息注册到ApplicationModel实例中。</p><h3 id="1-3-源码分析ServiceConfig-doExportUrls暴露服务具体实现逻辑"><a href="#1-3-源码分析ServiceConfig-doExportUrls暴露服务具体实现逻辑" class="headerlink" title="1.3 源码分析ServiceConfig#doExportUrls暴露服务具体实现逻辑"></a>1.3 源码分析ServiceConfig#doExportUrls暴露服务具体实现逻辑</h3><p> 调用链：ServiceBean#afterPropertiesSet——&gt;ServiceConfig#export——&gt;ServiceConfig#doExport</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void doExportUrls() &#123;</span><br><span class="line">        List&lt;URL&gt; registryURLs &#x3D; loadRegistries(true);  &#x2F;&#x2F; @1</span><br><span class="line">        for (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">            doExportUrlsFor1Protocol(protocolConfig, registryURLs);    &#x2F;&#x2F; @2</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先遍历ServiceBean的List&lt; RegistryConfig&gt; registries（所有注册中心的配置信息），然后将地址封装成URL对象，关于注册中心的所有配置属性，最终转换成url的属性(?属性名=属性值)，loadRegistries(true)，参数的意思：true，代表服务提供者，false：代表服务消费者，如果是服务提供者，则检测注册中心的配置，如果配置了register=”false”，则忽略该地址，如果是服务消费者，并配置了subscribe=”false”则表示不从该注册中心订阅服务，故也不返回，一个注册中心URL示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry:&#x2F;&#x2F;127.0.0.1:2181&#x2F;com.alibaba.dubbo.registry.RegistryService?application&#x3D;demo-provider&amp;dubbo&#x3D;2.0.0&amp;pid&#x3D;7072&amp;qos.port&#x3D;22222&amp;registry&#x3D;zookeeper&amp;timestamp&#x3D;1527308268041</span><br></pre></td></tr></table></figure><p> 代码@2：然后遍历配置的所有协议，根据每个协议，向注册中心暴露服务，接下来重点分析doExportUrlsFor1Protocol方法的实现细节。</p><h3 id="1-4-源码分析doExportUrlsFor1Protocol"><a href="#1-4-源码分析doExportUrlsFor1Protocol" class="headerlink" title="1.4 源码分析doExportUrlsFor1Protocol"></a>1.4 源码分析doExportUrlsFor1Protocol</h3><p> 调用链：ServiceBean#afterPropertiesSet——&gt;ServiceConfig#export——&gt;ServiceConfig#doExport——&gt;ServiceConfig#doExportUrlsFor1Protocol<br> ServiceConfig#doExportUrlsFor1Protocol</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String name &#x3D; protocolConfig.getName();</span><br><span class="line">if (name &#x3D;&#x3D; null || name.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">     name &#x3D; &quot;dubbo&quot;;</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;String, String&gt; map &#x3D; new HashMap&lt;String, String&gt;();</span><br><span class="line">map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);</span><br><span class="line">map.put(Constants.DUBBO_VERSION_KEY, Version.getVersion());</span><br><span class="line">map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">if (ConfigUtils.getPid() &gt; 0) &#123;</span><br><span class="line">    map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">&#125;</span><br><span class="line">appendParameters(map, application);</span><br><span class="line">appendParameters(map, module);</span><br><span class="line">appendParameters(map, provider, Constants.DEFAULT_KEY);</span><br><span class="line">appendParameters(map, protocolConfig);</span><br><span class="line">appendParameters(map, this);</span><br></pre></td></tr></table></figure><p>Step1：用Map存储该协议的所有配置参数，包括协议名称、dubbo版本、当前系统时间戳、进程ID、application配置、module配置、默认服务提供者参数(ProviderConfig)、协议配置、服务提供Dubbo:service的属性。</p><p> ServiceConfig#doExportUrlsFor1Protocol</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">if (methods !&#x3D; null &amp;&amp; !methods.isEmpty()) &#123;</span><br><span class="line">            for (MethodConfig method : methods) &#123;</span><br><span class="line">                appendParameters(map, method, method.getName());</span><br><span class="line">                String retryKey &#x3D; method.getName() + &quot;.retry&quot;;</span><br><span class="line">                if (map.containsKey(retryKey)) &#123;</span><br><span class="line">                    String retryValue &#x3D; map.remove(retryKey);</span><br><span class="line">                    if (&quot;false&quot;.equals(retryValue)) &#123;</span><br><span class="line">                        map.put(method.getName() + &quot;.retries&quot;, &quot;0&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                List&lt;ArgumentConfig&gt; arguments &#x3D; method.getArguments();</span><br><span class="line">                if (arguments !&#x3D; null &amp;&amp; !arguments.isEmpty()) &#123;</span><br><span class="line">                    for (ArgumentConfig argument : arguments) &#123;</span><br><span class="line">                        &#x2F;&#x2F; convert argument type</span><br><span class="line">                        if (argument.getType() !&#x3D; null &amp;&amp; argument.getType().length() &gt; 0) &#123;</span><br><span class="line">                            Method[] methods &#x3D; interfaceClass.getMethods();</span><br><span class="line">                            &#x2F;&#x2F; visit all methods</span><br><span class="line">                            if (methods !&#x3D; null &amp;&amp; methods.length &gt; 0) &#123;</span><br><span class="line">                                for (int i &#x3D; 0; i &lt; methods.length; i++) &#123;</span><br><span class="line">                                    String methodName &#x3D; methods[i].getName();</span><br><span class="line">                                    &#x2F;&#x2F; target the method, and get its signature</span><br><span class="line">                                    if (methodName.equals(method.getName())) &#123;</span><br><span class="line">                                        Class&lt;?&gt;[] argtypes &#x3D; methods[i].getParameterTypes();</span><br><span class="line">                                        &#x2F;&#x2F; one callback in the method</span><br><span class="line">                                        if (argument.getIndex() !&#x3D; -1) &#123;</span><br><span class="line">                                            if (argtypes[argument.getIndex()].getName().equals(argument.getType())) &#123;</span><br><span class="line">                                                appendParameters(map, argument, method.getName() + &quot;.&quot; + argument.getIndex());</span><br><span class="line">                                            &#125; else &#123;</span><br><span class="line">                                                throw new IllegalArgumentException(&quot;argument config error : the index attribute and type attribute not match :index :&quot; + argument.getIndex() + &quot;, type:&quot; + </span><br><span class="line">                                                      argument.getType());</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125; else &#123;</span><br><span class="line">                                            &#x2F;&#x2F; multiple callbacks in the method</span><br><span class="line">                                            for (int j &#x3D; 0; j &lt; argtypes.length; j++) &#123;</span><br><span class="line">                                                Class&lt;?&gt; argclazz &#x3D; argtypes[j];</span><br><span class="line">                                                if (argclazz.getName().equals(argument.getType())) &#123;</span><br><span class="line">                                                    appendParameters(map, argument, method.getName() + &quot;.&quot; + j);</span><br><span class="line">                                                    if (argument.getIndex() !&#x3D; -1 &amp;&amp; argument.getIndex() !&#x3D; j) &#123;</span><br><span class="line">                                                        throw new IllegalArgumentException(&quot;argument config error : the index attribute and type attribute not match :index :&quot; + argument.getIndex() + &quot;, </span><br><span class="line">                                                             type:&quot; + argument.getType());</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                                &#125;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; else if (argument.getIndex() !&#x3D; -1) &#123;</span><br><span class="line">                            appendParameters(map, argument, method.getName() + &quot;.&quot; + argument.getIndex());</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            throw new IllegalArgumentException(&quot;argument config must set index or type attribute.eg: &lt;dubbo:argument index&#x3D;&#39;0&#39; ...&#x2F;&gt; or &lt;dubbo:argument type&#x3D;xxx ...&#x2F;&gt;&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; &#x2F;&#x2F; end of methods for</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>Step2：如果dubbo:service有dubbo:method子标签，则dubbo:method以及其子标签的配置属性，都存入到Map中，属性名称加上对应的方法名作为前缀。dubbo:method的子标签dubbo:argument,其键为方法名.参数序号。</p><p>ServiceConfig#doExportUrlsFor1Protocol</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if (ProtocolUtils.isGeneric(generic)) &#123;</span><br><span class="line">      map.put(Constants.GENERIC_KEY, generic);</span><br><span class="line">      map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">      String revision &#x3D; Version.getVersion(interfaceClass, version);</span><br><span class="line">      if (revision !&#x3D; null &amp;&amp; revision.length() &gt; 0) &#123;</span><br><span class="line">          map.put(&quot;revision&quot;, revision);</span><br><span class="line">      &#125;</span><br><span class="line">      String[] methods &#x3D; Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">      if (methods.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">           logger.warn(&quot;NO method found in service interface &quot; + interfaceClass.getName());</span><br><span class="line">           map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">           map.put(Constants.METHODS_KEY, StringUtils.join(new HashSet&lt;String&gt;(Arrays.asList(methods)), &quot;,&quot;));</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step3：添加methods键值对，存放dubbo:service的所有方法名，多个方法名用,隔开，如果是泛化实现，填充genric=true,methods为”*”；</p><p>ServiceConfig#doExportUrlsFor1Protocol</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (!ConfigUtils.isEmpty(token)) &#123;</span><br><span class="line">      if (ConfigUtils.isDefault(token)) &#123;</span><br><span class="line">            map.put(Constants.TOKEN_KEY, UUID.randomUUID().toString());</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">            map.put(Constants.TOKEN_KEY, token);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step4:根据是否开启令牌机制，如果开启，设置token键，值为静态值或uuid。</p><p>ServiceConfig#doExportUrlsFor1Protocol</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (Constants.LOCAL_PROTOCOL.equals(protocolConfig.getName())) &#123;</span><br><span class="line">       protocolConfig.setRegister(false);</span><br><span class="line">       map.put(&quot;notify&quot;, &quot;false&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step5:如果协议为本地协议(injvm)，则设置protocolConfig#register属性为false，表示不向注册中心注册服务，在map中存储键为notify,值为false,表示当注册中心监听到服务提供者发送变化（服务提供者增加、服务提供者减少等事件时不通知。</p><p>ServiceConfig#doExportUrlsFor1Protocol</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; export service</span><br><span class="line">String contextPath &#x3D; protocolConfig.getContextpath();</span><br><span class="line">if ((contextPath &#x3D;&#x3D; null || contextPath.length() &#x3D;&#x3D; 0) &amp;&amp; provider !&#x3D; null) &#123;</span><br><span class="line">     contextPath &#x3D; provider.getContextpath();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step6:设置协议的contextPath,如果未配置，默认为/interfacename</p><p>ServiceConfig#doExportUrlsFor1Protocol</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String host &#x3D; this.findConfigedHosts(protocolConfig, registryURLs, map);</span><br><span class="line">Integer port &#x3D; this.findConfigedPorts(protocolConfig, name, map);</span><br></pre></td></tr></table></figure><p>Step7：解析服务提供者的IP地址与端口。<br>服务IP地址解析顺序：（序号越小越优先）</p><ol><li>系统环境变量，变量名：DUBBO_DUBBO_IP_TO_BIND  </li><li>系统属性,变量名：DUBBO_DUBBO_IP_TO_BIND</li><li>系统环境变量，变量名：DUBBO_IP_TO_BIND</li><li>系统属性，变量名：DUBBO_IP_TO_BIND</li><li>dubbo:protocol 标签的host属性  –》 dubbo:provider 标签的host属性</li><li>默认网卡IP地址，通过InetAddress.getLocalHost().getHostAddress()获取，如果IP地址不符合要求，继续下一个匹配。</li></ol><p>判断IP地址是否符合要求的标准是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isInvalidLocalHost(String host) &#123;</span><br><span class="line">     return host &#x3D;&#x3D; null</span><br><span class="line">             || host.length() &#x3D;&#x3D; 0</span><br><span class="line">             || host.equalsIgnoreCase(&quot;localhost&quot;)</span><br><span class="line">             || host.equals(&quot;0.0.0.0&quot;)</span><br><span class="line">             || (LOCAL_IP_PATTERN.matcher(host).matches());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="7"><li><p>选择第一个可用网卡，其实现方式是建立socket，连接注册中心，获取socket的IP地址。其代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Socket socket &#x3D; new Socket();</span><br><span class="line">        try &#123;</span><br><span class="line">              SocketAddress addr &#x3D; new InetSocketAddress(registryURL.getHost(), registryURL.getPort());</span><br><span class="line">              socket.connect(addr, 1000);</span><br><span class="line">              hostToBind &#x3D; socket.getLocalAddress().getHostAddress();</span><br><span class="line">              break;</span><br><span class="line">         &#125; finally &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                      socket.close();</span><br><span class="line">              &#125; catch (Throwable e) &#123;</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>服务提供者端口解析顺序：（序号越小越优先）</p></li><li><p>系统环境变量，变量名：DUBBO_DUBBO_PORT_TO_BIND</p></li><li><p>系统属性，变量名：DUBBO_DUBBO_PORT_TO_BIND</p></li><li><p>系统环境变量，变量名：DUBBO_PORT_TO_BIND</p></li><li><p>系统属性，变量名DUBBO_PORT_TO_BIND</p></li><li><p>dubbo:protocol标签port属性、dubbo:provider标签的port属性。</p></li><li><p>随机选择一个端口。</p><p>ServiceConfig#doExportUrlsFor1Protocol</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URL url &#x3D; new URL(name, host, port, (contextPath &#x3D;&#x3D; null || contextPath.length() &#x3D;&#x3D; 0 ? &quot;&quot; : contextPath + &quot;&#x2F;&quot;) + path, map);</span><br></pre></td></tr></table></figure><p> Step8：根据协议名称、协议host、协议端口、contextPath、相关配置属性（application、module、provider、protocolConfig、service及其子标签）构建服务提供者URI。<br> URL运行效果图:<br><img src="https://img-blog.csdn.net/20180601131950233?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br> 以dubbo协议为例，展示最终服务提供者的URL信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dubbo:&#x2F;&#x2F;192.168.56.1:20880&#x2F;com.alibaba.dubbo.demo.DemoService?anyhost&#x3D;true&amp;application&#x3D;demo-provider&amp;bind.ip&#x3D;192.168.56.1&amp;bind.port&#x3D;20880&amp;dubbo&#x3D;2.0.0&amp;generic&#x3D;false&amp;interface&#x3D;com.alibaba.dubbo.demo.DemoService&amp;methods&#x3D;sayHello&amp;pid&#x3D;5916&amp;qos.port&#x3D;22222&amp;side&#x3D;provider&amp;timestamp&#x3D;1527168070857</span><br></pre></td></tr></table></figure><p> ServiceConfig#doExportUrlsFor1Protocol</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String scope &#x3D; url.getParameter(Constants.SCOPE_KEY);</span><br><span class="line">&#x2F;&#x2F; don&#39;t export when none is configured</span><br><span class="line">if (!Constants.SCOPE_NONE.toString().equalsIgnoreCase(scope)) &#123;</span><br><span class="line">     &#x2F;&#x2F; 接口暴露实现逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step9：获取dubbo:service标签的scope属性，其可选值为none(不暴露)、local(本地)、remote(远程)，如果配置为none，则不暴露。默认为local。</p><p> ServiceConfig#doExportUrlsFor1Protocol</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; export to local if the config is not remote (export to remote only when config is remote)</span><br><span class="line">if (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) &#123;     &#x2F;&#x2F; @1</span><br><span class="line">       exportLocal(url);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; export to remote if the config is not local (export to local only when config is local)</span><br><span class="line">if (!Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope)) &#123;     &#x2F;&#x2F; @2</span><br><span class="line">        if (logger.isInfoEnabled()) &#123;</span><br><span class="line">              logger.info(&quot;Export dubbo service &quot; + interfaceClass.getName() + &quot; to url &quot; + url);</span><br><span class="line">         &#125;</span><br><span class="line">        if (registryURLs !&#x3D; null &amp;&amp; !registryURLs.isEmpty()) &#123;   &#x2F;&#x2F; @3</span><br><span class="line">              for (URL registryURL : registryURLs) &#123;</span><br><span class="line">                    url &#x3D; url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));  &#x2F;&#x2F; @4</span><br><span class="line">                    URL monitorUrl &#x3D; loadMonitor(registryURL);       &#x2F;&#x2F; @5</span><br><span class="line">                    if (monitorUrl !&#x3D; null) &#123;</span><br><span class="line">                        url &#x3D; url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());  </span><br><span class="line">                    &#125;</span><br><span class="line">                    if (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(&quot;Register dubbo service &quot; + interfaceClass.getName() + &quot; url &quot; + url + &quot; to registry &quot; + registryURL);</span><br><span class="line">                    &#125;</span><br><span class="line">                   Invoker&lt;?&gt; invoker &#x3D; proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));  &#x2F;&#x2F; @6</span><br><span class="line">                   DelegateProviderMetaDataInvoker wrapperInvoker &#x3D; new DelegateProviderMetaDataInvoker(invoker, this);    </span><br><span class="line">                   Exporter&lt;?&gt; exporter &#x3D; protocol.export(wrapperInvoker);    &#x2F;&#x2F; @7</span><br><span class="line">                   exporters.add(exporter);</span><br><span class="line">               &#125;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">               Invoker&lt;?&gt; invoker &#x3D; proxyFactory.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line">               DelegateProviderMetaDataInvoker wrapperInvoker &#x3D; new DelegateProviderMetaDataInvoker(invoker, this);</span><br><span class="line">               Exporter&lt;?&gt; exporter &#x3D; protocol.export(wrapperInvoker);</span><br><span class="line">               exporters.add(exporter);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step10：根据scope来暴露服务，如果scope不配置，则默认本地与远程都会暴露，如果配置成local或remote，那就只能是二选一。</p><ul><li><p>代码@1：如果scope不为remote，则先在本地暴露(injvm):，具体暴露服务的具体实现，将在remote 模式中详细分析。</p></li><li><p>代码@2：如果scope不为local,则将服务暴露在远程。 </p></li><li><p>代码@3：remote方式，检测当前配置的所有注册中心，如果注册中心不为空，则遍历注册中心，将服务依次在不同的注册中心进行注册。</p></li><li><p>代码@4：如果dubbo:service的dynamic属性未配置， 尝试取dubbo:registry的dynamic属性，该属性的作用是否启用动态注册，如果设置为false，服务注册后，其状态显示为disable，需要人工启用，当服务不可用时，也不会自动移除，同样需要人工处理，此属性不要在生产环境上配置。</p></li><li><p>代码@5：根据注册中心url(注册中心url)，构建监控中心的URL，如果监控中心URL不为空，则在服务提供者URL上追加monitor，其值为监控中心url(已编码)。</p></li><li><p>如果dubbo spring xml配置文件中没有配置监控中心(dubbo:monitor),如果从系统属性-Ddubbo.monitor.address，-Ddubbo.monitor.protocol构建MonitorConfig对象，否则从dubbo的properties配置文件中寻找这个两个参数，如果没有配置，则返回null。</p></li><li><p>如果有配置，则追加相关参数，dubbo:monitor标签只有两个属性：address、protocol，其次会追加interface(MonitorService)、协议等。</p></li><li><p>代码@6：通过动态代理机制创建Invoker，dubbo的远程调用实现类。<br><img src="https://img-blog.csdn.net/20180601132122916?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br> Dubbo远程调用器如何构建，这里不详细深入，重点关注WrapperInvoker的url为:registry://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&amp;dubbo=2.0.0&amp;export=dubbo%3A%2F%2F192.168.56.1%3A20880%2Fcom.alibaba.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddemo-provider%26bind.ip%3D192.168.56.1%26bind.port%3D20880%26dubbo%3D2.0.0%26generic%3Dfalse%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D6328%26qos.port%3D22222%26side%3Dprovider%26timestamp%3D1527255510215&amp;pid=6328&amp;qos.port=22222&amp;registry=zookeeper&amp;timestamp=1527255510202，这里有两个重点值得关注：</p></li><li><p>path属性：com.alibaba.dubbo.registry.RegistryService，注册中心也类似于服务提供者。</p></li><li><p>export属性：值为服务提供者的URL，为什么需要关注这个URL呢？请看代码@7，protocol属性为Protocol$Adaptive，Dubbo在加载组件实现类时采用SPI(插件机制，有关于插件机制，在该专题后续文章将重点分析)，在这里我们只需要知道，根据URL冒号之前的协议名将会调用相应的方法。<br><img src="https://img-blog.csdn.net/20180601132156636?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br> 其映射关系(列出与服务启动相关协议实现类)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dubbo&#x3D;com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol       &#x2F;&#x2F;文件位于dubbo-rpc-dubbo&#x2F;src&#x2F;main&#x2F;resources&#x2F;META-INF&#x2F;dubbo&#x2F;internal&#x2F;com.alibaba.dubbo.rpc.Protocol</span><br><span class="line">registry&#x3D;com.alibaba.dubbo.registry.integration.RegistryProtocol   &#x2F;&#x2F;文件位于dubbo-registry-api&#x2F;src&#x2F;main&#x2F;resources&#x2F;META-INF&#x2F;dubbo&#x2F;internal&#x2F;com.alibaba.dubbo.rpc.Protocol</span><br></pre></td></tr></table></figure><p> 代码@7：根据代码@6的分析，将调用RegistryProtocol#export方法。</p></li></ul><h3 id="1-5-源码分析RegistryProtocol-export方法"><a href="#1-5-源码分析RegistryProtocol-export方法" class="headerlink" title="1.5 源码分析RegistryProtocol#export方法"></a>1.5 源码分析RegistryProtocol#export方法</h3><p> 调用链：ServiceBean#afterPropertiesSet——&gt;ServiceConfig#export——&gt;ServiceConfig#doExport——&gt;ServiceConfig#doExportUrlsFor1Protocol——&gt;RegistryProtocol#export</p><p> RegistryProtocol#export</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public &lt;T&gt; Exporter&lt;T&gt; export(final Invoker&lt;T&gt; originInvoker) throws RpcException &#123;</span><br><span class="line">        &#x2F;&#x2F;export invoker</span><br><span class="line">        final ExporterChangeableWrapper&lt;T&gt; exporter &#x3D; doLocalExport(originInvoker);   &#x2F;&#x2F; @1</span><br><span class="line"></span><br><span class="line">        URL registryUrl &#x3D; getRegistryUrl(originInvoker);       &#x2F;&#x2F; @2</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;registry provider</span><br><span class="line">        final Registry registry &#x3D; getRegistry(originInvoker);                          &#x2F;&#x2F; @3</span><br><span class="line">        final URL registedProviderUrl &#x3D; getRegistedProviderUrl(originInvoker);     &#x2F;&#x2F; @4start</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;to judge to delay publish whether or not</span><br><span class="line">        boolean register &#x3D; registedProviderUrl.getParameter(&quot;register&quot;, true);  </span><br><span class="line"></span><br><span class="line">        ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registedProviderUrl);</span><br><span class="line"></span><br><span class="line">        if (register) &#123;  </span><br><span class="line">            register(registryUrl, registedProviderUrl);      &#x2F;&#x2F; @4 end</span><br><span class="line">            ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(true);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Subscribe the override data</span><br><span class="line">        &#x2F;&#x2F; FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call the same service. Because the subscribed is cached key with the name of the service, it causes the subscription information to cover.</span><br><span class="line">        final URL overrideSubscribeUrl &#x3D; getSubscribedOverrideUrl(registedProviderUrl);          &#x2F;&#x2F; @5 start</span><br><span class="line">        final OverrideListener overrideSubscribeListener &#x3D; new OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">        overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">        registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);            &#x2F;&#x2F; @5 end</span><br><span class="line">        &#x2F;&#x2F;Ensure that a new exporter instance is returned every time export</span><br><span class="line">        return new DestroyableExporter&lt;T&gt;(exporter, originInvoker, overrideSubscribeUrl, registedProviderUrl);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：启动服务提供者服务，监听指定端口，准备服务消费者的请求，这里其实就是从WrapperInvoker中的url(注册中心url)中提取export属性，描述服务提供者的url，然后启动服务提供者。<br><img src="https://img-blog.csdn.net/20180601132318446?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>从上图中，可以看出，将调用DubboProtocol#export完成dubbo服务的启动，利用netty构建一个微型服务端，监听端口，准备接受服务消费者的网络请求，本节旨在梳理其启动流程，具体实现细节，将在后续章节中详解，这里我们只要知道，&lt; dubbo:protocol name=”dubbo” port=”20880” /&gt;,会再此次监听该端口，然后将dubbo:service的服务handler加入到命令处理器中，当有消息消费者连接该端口时，通过网络解包，将需要调用的服务和参数等信息解析处理后，转交给对应的服务实现类处理即可。<br> 代码@2：获取真实注册中心的URL,例如zookeeper注册中心的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URL:zookeeper:&#x2F;&#x2F;127.0.0.1:2181&#x2F;com.alibaba.dubbo.registry.RegistryService?application&#x3D;demo-provider&amp;dubbo&#x3D;2.0.0&amp;export&#x3D;dubbo%3A%2F%2F192.168.56.1%3A20880%2Fcom.alibaba.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddemo-provider%26bind.ip%3D192.168.56.1%26bind.port%3D20880%26dubbo%3D2.0.0%26generic%3Dfalse%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D10252%26qos.port%3D22222%26side%3Dprovider%26timestamp%3D1527263060882&amp;pid&#x3D;10252&amp;qos.port&#x3D;22222&amp;timestamp&#x3D;1527263060867</span><br></pre></td></tr></table></figure><p>代码@3：根据注册中心URL，从注册中心工厂中获取指定的注册中心实现类：zookeeper注册中心的实现类为：ZookeeperRegistry</p><p>代码@4：获取服务提供者URL中的register属性，如果为true,则调用注册中心的ZookeeperRegistry#register方法向注册中心注册服务（实际由其父类FailbackRegistry实现）。</p><p>代码@5：服务提供者向注册中心订阅自己，主要是为了服务提供者URL发送变化后重新暴露服务，当然，会将dubbo:reference的check属性设置为false。</p><p>到这里就对文章开头提到的问题1，问题2做了一个解答，其与注册中心的心跳机制等将在后续章节中详细分析。</p><p>文字看起来可能不是很直观，现整理一下Dubbo服务提供者启动流程图如下：<br><img src="https://img-blog.csdn.net/20180601132342644?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>本文重点梳理了Dubbo服务提供者启动流程，其中Dubbo服务提供者在指定端口监听服务的启动流程将在下一节中详细分析。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本节将详细分析Dubbo服务提供者的启动流程，请带着如下几个疑问进行本节的阅读，因为这几个问题将是接下来几篇文章分析的重点内容。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么时候建立与注册中心的连接。&lt;/li&gt;
&lt;li&gt;服务提供者什么时候向注册中心注册服务。&lt;/li&gt;
&lt;li&gt;服务提供者与注册中心的心跳机制。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="dubbo" scheme="http://example.com/categories/dubbo/"/>
    
    
    <category term="dubbo" scheme="http://example.com/tags/dubbo/"/>
    
    <category term="ServcieBean" scheme="http://example.com/tags/ServcieBean/"/>
    
  </entry>
  
  <entry>
    <title>MySQL技术内幕-InnoDB存储引擎读写笔记(性能调优)</title>
    <link href="http://example.com/posts/5b656c60.html"/>
    <id>http://example.com/posts/5b656c60.html</id>
    <published>2020-12-12T14:35:01.000Z</published>
    <updated>2020-12-12T15:44:36.432Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="1、CPU"><a href="#1、CPU" class="headerlink" title="1、CPU"></a>1、CPU</h2><p>数据库一般是IO密集型的，其性能瓶颈在于IO。数据库服务器的选购偏内存，CPU可以适当降低其要求。</p><p>InnoDB存储引擎相关后台线程：</p><p>show engine innodb status\G;</p><p>  <img src="https://img-blog.csdn.net/20170717201302449?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlc3RpZ2VkaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><ul><li><p>插入缓冲区线程 <a href="http://www.cnblogs.com/yuyue2014/p/3802779.html">http://www.cnblogs.com/yuyue2014/p/3802779.html</a><br>InnoDB insert buffer thread 线程主要是更新非唯一索引的索引数据，避免频繁随机的读写索引文件。（索引数据存放在表默认表空间中）</p></li><li><p>log thread : InnoDB的默认指的就是redo日志,log thread 就是写 redo 日志的线程。</p></li><li><p>read thread | write thread 读、写日志线程（文件 《—-》内存）</p><p>根据CPU适当调节innodb_read_io_threads与innodb_write_io_threads</p></li></ul><h2 id="2、内存"><a href="#2、内存" class="headerlink" title="2、内存"></a>2、内存</h2><p>内存的大小最能直接反应数据库的性能。InnoDB存储引擎既缓存数据，又缓存索引（存放在数据文件中，表空间），并放入一个很大的缓冲池中(InnoDB Buffer Pool)。</p><p>innodb_buffer_pool的大小如果能等于数据文件的大小，则能缓存所有的数据文件，性能会得到极高的提升（innodb_buffer_pool_size）,如何判断当前数据库的内存是否达到了瓶颈了呢。</p><p>mysql提供  show global status 命令查看系统运行状况监控，（INFORMATION_SCHEMA GLOBAL_STATUS临时表）。</p><p><img src="https://img-blog.csdn.net/20170717201359777?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlc3RpZ2VkaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>关注如下参数：</p><ul><li><p>innodb_buffer_pool_reads: 从物理磁盘读取页的次数</p></li><li><p>innodb_buffer_pool_read_ahead:预读的次数</p></li><li><p>innodb_buffer_pool_read_ahead_evicted:预读的页，但没有被读取就从缓冲区被替换的也的数量，一般用来判断预读的效率。</p></li><li><p>innodb_buffer_pool_read_requests:从缓冲池中读取页的次数（可以理解为缓冲命中次数）</p></li><li><p>innodb_data_read:总共读入的字节数</p></li><li><p>innodb_data_reads:发起读请求的次数</p><a id="more"></a></li></ul><p>预读的效率：(1 -  (innodb_buffer_pool_read_ahead / innodb_buffer_pool_read)) * 100 %</p><p>InnoDB缓存命中率： innodb_buffer_pool_read_requests /  ( innodb_buffer_pool_read_requests + innodb_buffer_pool_reads  + innodb_buffer_pool_read_ahead )  * 100 %</p><p>InnoDB缓存命中率通常要保持在99%以上，才表明内存无压力，这样性能杠杠的。</p><p>平均每次读取的字节数= innodb_data_read/innodb_data_reads</p><p>内存大于数据文件，并不意味着没有IO操作，Innodb会定时刷脏（将被修改的页刷写到数据文件），并且每次事务提交，会写redo日志。</p><h2 id="3、磁盘对数据库性能的影响"><a href="#3、磁盘对数据库性能的影响" class="headerlink" title="3、磁盘对数据库性能的影响"></a>3、磁盘对数据库性能的影响</h2><p>数据库是IO密集型应用，推荐使用raid10(磁盘冗余阵列)</p><h2 id="4、SQL语句优化"><a href="#4、SQL语句优化" class="headerlink" title="4、SQL语句优化"></a>4、SQL语句优化</h2><p>SQL语句的优化点基本上会落到是否能利用索引这个问题上来。</p><ul><li>养成好的SQL使用习惯</li></ul><p>​      a、禁止使用 select *，应写需要的数据字段。</p><p>​      b、尽量使用exists代替in</p><ul><li>尽量利用索引来加速SQL数据的查询效率</li></ul><p>以下情况将无法利用索引： </p><ul><li><p>不支持 != 表达式，如果使用不等于，无法利用到索引。索引的存储结构是B+树，支持等值查询与范围查询。</p></li><li><p>like ‘%a%’无法利用索引，但’a%’可以使用索引。<br>原因分析，索引的存储结构是B+树，叶子节点存放数据，数据本身是排序的，输入值必须是一个明确的值，方便对比，a%开头的查询，是可以用a当查询关键字首先定位记录的，但%a%无法定位。</p></li><li><p>复合索引，查询条件必须包含第一列（最左列）<br>道理是一样的，索引的优势就是天生是排序的，查询类似于二分查询（每比较一次，就会缩短查询范围）。<br>例如有两列的复合索引类似(  1, 1  ) (  1, 3  ) (  2, 1  )  (  2, 5  )  (  3, 1  ) 只有包含第一列，整个二元序列就是有序的，但如果剔除第一列，那序列为  1,3,1,5,1，无序序列的查找，复杂度为o(n)。</p></li><li><p>对字段使用表达式或函数允许，将无法使用索引<br>索引建立原则</p><ul><li>列高选择性（重复率低）</li><li>频繁查询的列</li><li>order by 或 group by字段（利用索引的有序性）</li></ul></li></ul><h2 id="5、MySQL执行计划解读"><a href="#5、MySQL执行计划解读" class="headerlink" title="5、MySQL执行计划解读"></a>5、MySQL执行计划解读</h2><p>MySQL提供explain查看查询语句的执行计划，使用案例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT</span><br><span class="line">  t.id,</span><br><span class="line">  t.order_no,</span><br><span class="line">  t.total_price,</span><br><span class="line">  t.seller_id,</span><br><span class="line">  t.creator,</span><br><span class="line">  t.create_time</span><br><span class="line">FROM</span><br><span class="line">  (</span><br><span class="line">   SELECT a.id,</span><br><span class="line">      a.order_no,</span><br><span class="line">      a.total_price,</span><br><span class="line">      a.seller_id,</span><br><span class="line">      a.creator,</span><br><span class="line">      a.create_time</span><br><span class="line">    FROM</span><br><span class="line">      es_order a</span><br><span class="line">    WHERE</span><br><span class="line">     a.seller_id &#x3D; 24</span><br><span class="line">    LIMIT 20,</span><br><span class="line">    10</span><br><span class="line">  ) t</span><br><span class="line"></span><br><span class="line">INNER JOIN es_order_item b ON b.order_id &#x3D; t.id</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20170717201612086?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlc3RpZ2VkaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">相关字段：id、select_type、table、type、prossible_keys、key、ken_len、ref、rows、Extr</p><ul><li><p>id : 执行顺序，数字越大，先执行。</p></li><li><p>select_type: (只是标记为查询类型)</p><ul><li>simple : 查询中不包含子查询或union</li><li>primary:若查询中包含任何复杂的子查询，最外层查询标记为：PRIMARY</li><li>subquery:子查询</li><li>derived:驱动表，不是真实的物理表，但不同于临时表</li><li>union:</li><li>union result</li></ul></li><li><p>type:访问类型，重点关注<br>取值如下：all、index、range、ref、  eq_ref、  const system、null</p><ul><li>all : 全表扫描</li><li>index: Full Index Scan,index与all的区别为index只遍历索引树。<br>例如：(select a.id from es_order a)</li><li>range:索引范围扫描，常见于索引字段上的  between &gt; &lt;  like( like ‘a%’)</li><li>ref : 非唯一索引的等值匹配，例如a.seller_id=24 (seller_id上建有索引)</li><li>eq_ref:唯一索引的等值匹配</li><li>const、system:当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问explain select a.id,a.name from es_order a where a.id=8078</li><li>null : 不需要访问表，索引等。</li></ul></li><li><p>possible_keys</p><p> 指出mysql能使用哪个索引能在表中找到行，查询涉及到的字段若存在索引，则会列出，但不一定使用</p></li><li><p>key （重点关注）<br>使用到的索引</p></li><li><p>key_len (索引用到的长度)</p></li><li><p>ref 索引匹配的情况（列）【无需太关注】</p></li><li><p>rows<br>本次查询，预计需要扫描的行数</p></li><li><p>Extra  额外的说明信息</p></li><li><p>using index (covering Index)</p></li><li><p>using where<br>表示mysql服务器从存储引擎收到记录后，进行“后过滤”，如果未使用索引，提醒</p></li><li><p>Using temporary</p></li></ul><p>​      表示使用了临时表空间（排序、分组）</p><ul><li>Using filesort</li></ul><p>​      Mysql中无法利用索引完成的排序操作成为文件排序。</p><h2 id="6、数据库设计心得"><a href="#6、数据库设计心得" class="headerlink" title="6、数据库设计心得"></a>6、数据库设计心得</h2><p>1、数据库的表的设计方法论为理解ER关系</p><p>   一对一、一对多、多对对（分拆成两个1对多关系，也就是引入一个关系实体）</p><p>2）适当打破数据库第三范式<br>适当增加冗余字段，减少表的连接操作。<br>举例：订单表中有商品ID，由于订单反映的当时下单时商品的信息，我们完成可以增加一个冗余字段，商品名称goods_name,这样在展示订单信息时，无需join商品信息表。（冗余字段的增加可能会带来数据的不一致性，所以要结合实际情况，不能为了冗余而冗余）</p><p>3）数据库字段类型选择</p><p>尽量选择满足需求的最小长度。比如订单状态，可以使用tinyint,而无需使用int。这样的直接好处就是减少数据行的长度，每页能存储更多的数据行，IO效率得到提高。（性能是一个积累的过程）</p><p>4）表的垂直分割<br>将一个表的信息分割成多个表，这样主要是保证频繁使用的主表每行的数据尽量少，每页存放更多数据行，提高IO读效率。表分割后，如果每次查询主表，都需要连接查询从表，那就没有必要进行垂直分割。</p><p>举例：比如一条资讯信息，咨询的内容使用的类型为(text)，在实际使用时，一般是先出资讯列表，然后点击到每一条资讯时，才去查询资讯内容，此时可以将咨询内容单独分割出一张表，在咨询主表中冗余一个字段（摘要），存放咨询内容的部分信息，用于列表展示。</p><p>反例：<br>比如一条评论，有评论内容，类型为text,此时就没必要单独将评论内容抽取出来，因为每次显示评论时，基本上都要查看全部的评论内容，如果分开，会进行多边连接，性能反而受影响。</p><p>5）表设计阶段应该考虑索引的建立</p><p>应根据系统相关需求，在创建表时建立必要的索引。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1、CPU&quot;&gt;&lt;a href=&quot;#1、CPU&quot; class=&quot;headerlink&quot; title=&quot;1、CPU&quot;&gt;&lt;/a&gt;1、CPU&lt;/h2&gt;&lt;p&gt;数据库一般是IO密集型的，其性能瓶颈在于IO。数据库服务器的选购偏内存，CPU可以适当降低其要求。&lt;/p&gt;
&lt;p&gt;InnoDB存储引擎相关后台线程：&lt;/p&gt;
&lt;p&gt;show engine innodb status\G;&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img-blog.csdn.net/20170717201302449?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlc3RpZ2VkaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;img&quot;&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;点击并拖拽以移动&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;插入缓冲区线程 &lt;a href=&quot;http://www.cnblogs.com/yuyue2014/p/3802779.html&quot;&gt;http://www.cnblogs.com/yuyue2014/p/3802779.html&lt;/a&gt;&lt;br&gt;InnoDB insert buffer thread 线程主要是更新非唯一索引的索引数据，避免频繁随机的读写索引文件。（索引数据存放在表默认表空间中）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;log thread : InnoDB的默认指的就是redo日志,log thread 就是写 redo 日志的线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;read thread | write thread 读、写日志线程（文件 《—-》内存）&lt;/p&gt;
&lt;p&gt;根据CPU适当调节innodb_read_io_threads与innodb_write_io_threads&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2、内存&quot;&gt;&lt;a href=&quot;#2、内存&quot; class=&quot;headerlink&quot; title=&quot;2、内存&quot;&gt;&lt;/a&gt;2、内存&lt;/h2&gt;&lt;p&gt;内存的大小最能直接反应数据库的性能。InnoDB存储引擎既缓存数据，又缓存索引（存放在数据文件中，表空间），并放入一个很大的缓冲池中(InnoDB Buffer Pool)。&lt;/p&gt;
&lt;p&gt;innodb_buffer_pool的大小如果能等于数据文件的大小，则能缓存所有的数据文件，性能会得到极高的提升（innodb_buffer_pool_size）,如何判断当前数据库的内存是否达到了瓶颈了呢。&lt;/p&gt;
&lt;p&gt;mysql提供  show global status 命令查看系统运行状况监控，（INFORMATION_SCHEMA GLOBAL_STATUS临时表）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20170717201359777?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlc3RpZ2VkaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;img&quot;&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;点击并拖拽以移动&quot;&gt;&lt;/p&gt;
&lt;p&gt;关注如下参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;innodb_buffer_pool_reads: 从物理磁盘读取页的次数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;innodb_buffer_pool_read_ahead:预读的次数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;innodb_buffer_pool_read_ahead_evicted:预读的页，但没有被读取就从缓冲区被替换的也的数量，一般用来判断预读的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;innodb_buffer_pool_read_requests:从缓冲池中读取页的次数（可以理解为缓冲命中次数）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;innodb_data_read:总共读入的字节数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;innodb_data_reads:发起读请求的次数&lt;/p&gt;</summary>
    
    
    
    <category term="mysql" scheme="http://example.com/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://example.com/tags/mysql/"/>
    
    <category term="innodb" scheme="http://example.com/tags/innodb/"/>
    
    <category term="性能优化" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL技术内幕-InnoDB存储引擎读书笔记(MySQL日志文件)</title>
    <link href="http://example.com/posts/3f9b27cb.html"/>
    <id>http://example.com/posts/3f9b27cb.html</id>
    <published>2020-12-12T14:09:01.000Z</published>
    <updated>2020-12-12T15:44:36.432Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>MySQL日志文件主要包含错误日志，慢查询日志，查询日志，binlog、与事务日志(redo,undo)。</p><p>本文为了突出重点，将日志文件分成如下两类：普通日志、重点日志（binlog,redo,undo)</p><h2 id="1、普通日志"><a href="#1、普通日志" class="headerlink" title="1、普通日志"></a>1、普通日志</h2><h3 id="1-1、错误日志"><a href="#1-1、错误日志" class="headerlink" title="1.1、错误日志"></a>1.1、错误日志</h3><p>错误文件，默认为 ${mysql_home}/data/主机名.err</p><p>配置日志文件的参数为 log_error</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;%log_error%&#39;;</span><br></pre></td></tr></table></figure><h3 id="1-2、慢查询日志"><a href="#1-2、慢查询日志" class="headerlink" title="1.2、慢查询日志"></a>1.2、慢查询日志</h3><p>MySQL判断语句执行慢的参考如下：</p><ol><li><p>执行时间不能超过 long_query_time(单位为秒，支持到微妙，通过小数点表示)</p></li><li><p>是否使用了索引开关( log_queries_not_using_indexes 如果设置为1或on,表示如果没有使用索引的语句认为是慢查询 )</p></li><li><p>本次查询扫描的行数如果小于min_examined_row_limit ,如果本次查收扫描的行数小于该配置值，则不写</p></li></ol><p>​       入慢查询日志。</p><ol start="4"><li>如果没有使用索引，可以控制每分钟出现多少次后才写入一条到慢查询日志中。</li></ol><blockquote><p>参数为： log_throttle_queries_not_using_indexes，默认为0表示不做限制</p></blockquote><a id="more"></a><p>官方文档关于慢查询日志链接：<a href="https://dev.mysql.com/doc/refman/5.6/en/slow-query-log.html">https://dev.mysql.com/doc/refman/5.6/en/slow-query-log.html</a></p><p>根据使用经验，可以使用如下命令查看与慢查询相关的配置属性：</p><p><img src="https://img-blog.csdn.net/20170709102229138?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlc3RpZ2VkaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdn.net/20170709102305468?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlc3RpZ2VkaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdn.net/20170709102338525?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlc3RpZ2VkaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdn.net/20170709102404515?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlc3RpZ2VkaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="1-3、查询日志"><a href="#1-3、查询日志" class="headerlink" title="1.3、查询日志"></a>1.3、查询日志</h3><p>查询日志官方说明：<a href="https://dev.mysql.com/doc/refman/5.6/en/query-log.html">https://dev.mysql.com/doc/refman/5.6/en/query-log.html</a></p><p>查询日志，详细的记录了所有查询语句对应mysql通信协议语句类型(COM_QUERY)相关的语句执行情况，非常适合定位问题，但生产环境下必须禁用该属性，不然会严重影响性能。查询日志相关的两个属性如下：</p><p><img src="https://img-blog.csdn.net/20170709102446664?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlc3RpZ2VkaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>既然是COM_QUERY类型的，也包含update,insert语句。</p><h2 id="2、binlog、redo、undo"><a href="#2、binlog、redo、undo" class="headerlink" title="2、binlog、redo、undo"></a>2、binlog、redo、undo</h2><p>接下来重点讨论binlog、redo、undo日志</p><p>基于InnoDB存储引擎来讨论binlog,redo,undo。</p><h3 id="2-1-binlog"><a href="#2-1-binlog" class="headerlink" title="2.1 binlog"></a>2.1 binlog</h3><p>mysql二进制日志，在mysql服务层面记录mysql数据的变化轨迹，其存储格式为基于SQL语句（statement）、基于数据行变化(row)、混合方式(mixed)，其作用主要用来做主从同步。横向类比（Redis主从复制）。</p><p>写入时机：下文与redo时一起讨论。</p><h4 id="2-1-1-binglog相关参数与解读"><a href="#2-1-1-binglog相关参数与解读" class="headerlink" title="2.1.1 binglog相关参数与解读"></a>2.1.1 binglog相关参数与解读</h4><p>binlog相关的配置参数如下：</p><ul><li><p>log-bin=mysql-bin  (指定binlog的日志名，默认路径为${mysql_home}/data)</p></li><li><p>binlog_format 指定binglog的存放格式，statement,row,mixed</p></li><li><p>max_binlog_size</p></li><li><p>binlog_cache_size</p></li><li><p>sync_binlog<br>涉及文件操作，一般的做法是先缓存（内存中），然后隔一段时间将缓存写入到文件中。</p><p>binlog的写入同样如此，mysql会为binlog提供一个写缓存区，每个会话将binglog,首先会写入到写缓存区，然后按某种机制刷写到磁盘。</p><p>通过max_binlog_size设置单个binlog文件的大小，默认为1G，一个文件达到上限后，再新建一个文件,.index记录了所有的binlog文件。binlog_cache_size,是会话级别的参数，设置binlog的内存缓存区大小，默认为32K。</p><p>如果一个会话内的产生的binlog日志超过32K后，mysql会将binglog写入临时的日志文件。mysql提供两个运行时变量binlog_cache_use、binlog_cache_disk_use来记录利用内存缓存和文件缓存的次数。</p><p>sync_binlog用来设置输入缓存的频率，表示多少次写缓存区后刷新到磁盘。我们知道，在事务允许过程中，首先会将产生的binlog写入到会话内的缓存区（内存缓存区），然后在事务提交后，将内存缓存区的数据写入到mysql binlog的写缓存区，然后刷写到磁盘，sync_binlog=1表示事务提交时（发出commit之前会先写binlog,但不一定会落盘,InnoDB1.2之后，提交阶段写redo,binlog日志为两阶段提交，见下文详解），将缓存区中的数据立即刷写到磁盘（落盘）。</p><p>生产环境下sync_binlog设置为1，保证其数据一致性。但还存在这样一种情况，如果发出事务comit操作，binlog已经被写入，但事务提交过程中，mysql服务器down了，此时会引起主从数据不一致性，该怎么办呢？innodb存储引擎提供了innodb_support_xa=1来解决binlog与innodb存储引擎日志文件不一致的问题（二阶段提交），下午redo,undo部分再详细解读。</p></li><li><p>binlog-do-db      指定需要同步的数据库(schema)</p></li><li><p>binlog-ignore-db   指定需要同步（记录binlog）日志的数据库(schema)</p></li><li><p>log-slave-update   设置从服务器是否也写binglog日志，默认是关闭的,log-slave-update=1表示开启。</p></li></ul><h4 id="2-1-2-binglog工具"><a href="#2-1-2-binglog工具" class="headerlink" title="2.1.2 binglog工具"></a>2.1.2 binglog工具</h4><p>mysql提供了官方的binlog查看工具，mysqlbinlog</p><h3 id="2-2-redo与undo日志"><a href="#2-2-redo与undo日志" class="headerlink" title="2.2 redo与undo日志"></a>2.2 redo与undo日志</h3><p>redo与undo是mysql存储引擎级别的日志，俗称事务日志，与事务的实现息息相关。那我们从事务的ACID属性开始说起：</p><ul><li><p>原子性（Atomicity）<br>事务内的操作要么全部执行，要么全部不执行。</p></li><li><p>一致性（Consistency）<br>在事务开始之前和事务开始之后，数据库的完整性约束没有被破坏。</p></li><li><p>隔离性<br>两个事务的执行互不干扰，sql定义了4种隔离级别（读未提交、读已提交、可重复读、串行话读）</p></li><li><p>持久性（Durability）<br>事务成功执行后，该事务所对数据库所做的变更持久的保存在数据库之中。</p></li></ul><p>redo 重做日志，主要用来保证事务的持久性。</p><p>undo 回滚日志，在InnoDB中，将undo看成是数据，并不是日志，存放在数据文件中(innodb表空间文件中ibdata1)。</p><h4 id="2-2-1-redo-undo日志基础"><a href="#2-2-1-redo-undo日志基础" class="headerlink" title="2.2.1 redo,undo日志基础"></a>2.2.1 redo,undo日志基础</h4><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_log_buffer_size">https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_log_buffer_size</a> 官方文档关于InnoDB参数</p><p>undo 取消操作，用于事务回滚，将数据恢复到修改之前的状态，InnoDB的多版本并发控制（MVCC）就是基于undo来实现的。undo严格意义上来说，InnoDB将undo信息当成数据，存放在数据文件。数据文件相关的参数如下：</p><ul><li>innodb_data_home_dir :数据文件的路径，在my.cnf中对应 data_dir</li><li>innodb_data_file_path:数据文件名（默认表空间文件）,默认为ibdata1:12M:autoextend</li><li>innodb_file_per_table : 支持每个表单独一个表空间文件（数据文件）</li><li>innodb_tmpdir      :临时表空间路径</li><li>innodb_temp_data_file_path:临时表空间文件，默认为ibtmp1:12M:autoextend</li><li>innodb_undo_directory : undo独立目录（undo独立表空间）</li><li>innodb_undo_log_truncate:默认为off,undo日志是否支持压缩，删除已经落盘的信</li><li>innodb_undo_logs:128,默认为128个undo段，其中0号回滚段存在于默认表空间中，1-32号表空间位于临时表空间。</li><li>innodb_undo_tablespaces:默认为0，表示不开启独立的undo表空间。</li></ul><h5 id="2-2-1-1-redo日志"><a href="#2-2-1-1-redo日志" class="headerlink" title="2.2.1.1 redo日志"></a>2.2.1.1 redo日志</h5><p>重做日志，用来实现服务器异常时的数据恢复，实现事务的持久性。</p><p>redo日志的核心思想是使用顺序IO(事务提交时主要写redo日志，操作一个顺序的联系的IO文件)来代替每个事务提交时大量的随机IO去更新数据文件。也就是对数据的修改不会立马刷写到数据文件，而是写入redo文件，然后使用一定的机制，将内存中的脏页异步写入到数据文件，提高事务的执行效率与并发能力。</p><p>redo相关的配置参数：</p><ul><li><p>innodb_log_buffer_size : 一般根据页的大小（8K,16K）设置为8M,16M,写redo日志的缓冲区大小</p></li><li><p>innodb_log_file_size:单个redo日志文件的大小，默认为48M</p></li><li><p>innodb_log_files_in_group:默认为2，表示一个redo日志组中包含多少个文件，默认为2个。进行循环覆盖写- </p></li><li><p>innodb_log_write_ahead_size,每次追加写到redo日志文件的大小，默认为页的大小。8K或16K</p></li><li><p>innodb_log_group_home_dir:redo日志文件目录，默认为数据文件路径${mysql_home}\data</p></li></ul><h5 id="2-2-1-2-binlog、undo、redo日志写入时机"><a href="#2-2-1-2-binlog、undo、redo日志写入时机" class="headerlink" title="2.2.1.2 binlog、undo、redo日志写入时机"></a>2.2.1.2 binlog、undo、redo日志写入时机</h5><p>redo,重做日志，其引入的目的就是能够回复InnoDB的事务，达到恢复数据的目的。（持久性）</p><p>undo回滚日志，其引入的目的就是事务内的回滚(rollback)。（原子性）</p><p>redo日志引入的技术性原理分析：</p><ul><li><p>数据库存储其底层是文件系统，也就是数据库的数据最终存放在文件中,称之为数据文件。其持久性最通俗的要求就是事务执行后变更要能反馈到数据文件中即可。</p><p>操作数据库数据的逻辑一般是这样的：</p></li><li><p>从数据库文件中找到记录，文件一般是按照一种特定的格式存放，比如页，然后加载整页数据到内存，在内存中进行数据的操作（脏页）然后将脏页同步回文件，一般不会立即将脏页刷回到磁盘，这样会产生大量的随机IO操作，性能低下，如果不立即刷回磁盘，那么当服务器挂掉后，存放在内存中的数据会丢失，造成数据的不一致性，也就无从持久化。为了解决这一矛盾，引入了redo日志。</p></li><li><p>redo日志的引入核心一个思想是采用对redo日志文件的顺序IO来替换频繁的随机IO(更新数据文件)，redo文件使用循环覆写方式。redo一般会有两个文件ib_log0与ib_log1。引入redo日志后，数据库修改数据的通常逻辑为，从数据文件中找到数据页并加载到内存，在内存中修改数据，在事务提交之前先写redo日志，确保redo日志落盘，然后提交事务。数据库中的脏页使用一定的机制，统一刷写到数据文件。这样就将每次事务提交的时候，将随机访问数据文件变成顺序写redo日志。这样就提高了效率。</p></li></ul><p>接下来我们以示例来分析，redo,undo是如何写入的。</p><ul><li>update语句<br>我们知道，InnoDB使用多版本控制并发控制协议(MVCC)来实现无锁的并发读控制，MVCC,就是借助于undo日志。根据MVCC的实现方式，update语句执行逻辑为，先复制一份老的数据，请删除版本号设置为当前的事务ID，然后插入一条新的数据，更新版本号为当前事务。这里复制老的数据这一个步骤完全与undo的引入非常吻合，可以利用undo来恢复数据。那么MVCC结合undo关于update的实现：<ul><li>首先将数据（数据行）拷贝一份，将其删除版本号设置为当前事务ID，申请回滚段(undo),记录undo日志,undo日志的存储方式是一条链表（双链表）并且按照事务ID后排序。因为InnoDB把undo日志当成是数据，存放于表空间中，故在写undo之前，需要先写redo日志，redo日志将包含undo信息（可以根据redo日志重建undo日志链）,也就是undo是受redo日志保护的。</li><li>然后用插入一条数据，将数据行的更新版本号设置为当前事务。此时继续写redo日志。然后提交事务，此时redo日志落盘，undo日志与数据文件可能还保存在内存中，innodb会按照一定的策略将undo日志和数据脏页写入到磁盘。</li></ul></li></ul><p><strong>事务内的查询可见性机制：</strong></p><p>我想在事务内根据主键ID查询一条数据应该是先从数据文件中加载该数据，然后判断根据版本号与当前事务ID判断其可见性，如果不可见，则需要从undo链去找，数据文件行中存储了该记录所在的回滚段与偏移量。沿着回滚链找到向前找到第一个符合可见性的记录。</p><p>binlog、redo日志的写入关系。</p><p>在innodb_support_xa=1与sync_binlog=1时，,innodb会使用二阶段协议来写binlog与redo日志。[innodb_flush_log_at_trx_commit=1]</p><p>在mysql服务层发出commit命令后：</p><ul><li><p>prepare阶段：先写redo日志并落盘(redo日志信息包含undo信息)，状态为prepare。</p></li><li><p>commit阶段：写binlog文件并落盘</p></li><li><p>写redo日志并落盘（commit信息）</p></li></ul><p><img src="https://img-blog.csdn.net/20170709102605771?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlc3RpZ2VkaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>状态1: Redo Log里存在，Binary Log里也存在 –正常情况，crash恢复时需要commit</p><p>状态2: Redo Log里存在，Binary Log里不存在 –prepare完毕后发生crash，恢复时需要rollback</p><p>状态3: Redo Log里不存在，Binary Log里也不存在 –提交失败，无需处理</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;MySQL日志文件主要包含错误日志，慢查询日志，查询日志，binlog、与事务日志(redo,undo)。&lt;/p&gt;
&lt;p&gt;本文为了突出重点，将日志文件分成如下两类：普通日志、重点日志（binlog,redo,undo)&lt;/p&gt;
&lt;h2 id=&quot;1、普通日志&quot;&gt;&lt;a href=&quot;#1、普通日志&quot; class=&quot;headerlink&quot; title=&quot;1、普通日志&quot;&gt;&lt;/a&gt;1、普通日志&lt;/h2&gt;&lt;h3 id=&quot;1-1、错误日志&quot;&gt;&lt;a href=&quot;#1-1、错误日志&quot; class=&quot;headerlink&quot; title=&quot;1.1、错误日志&quot;&gt;&lt;/a&gt;1.1、错误日志&lt;/h3&gt;&lt;p&gt;错误文件，默认为 ${mysql_home}/data/主机名.err&lt;/p&gt;
&lt;p&gt;配置日志文件的参数为 log_error&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;show variables like &amp;#39;%log_error%&amp;#39;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;1-2、慢查询日志&quot;&gt;&lt;a href=&quot;#1-2、慢查询日志&quot; class=&quot;headerlink&quot; title=&quot;1.2、慢查询日志&quot;&gt;&lt;/a&gt;1.2、慢查询日志&lt;/h3&gt;&lt;p&gt;MySQL判断语句执行慢的参考如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;执行时间不能超过 long_query_time(单位为秒，支持到微妙，通过小数点表示)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;是否使用了索引开关( log_queries_not_using_indexes 如果设置为1或on,表示如果没有使用索引的语句认为是慢查询 )&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;本次查询扫描的行数如果小于min_examined_row_limit ,如果本次查收扫描的行数小于该配置值，则不写&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​       入慢查询日志。&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;如果没有使用索引，可以控制每分钟出现多少次后才写入一条到慢查询日志中。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;参数为： log_throttle_queries_not_using_indexes，默认为0表示不做限制&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="mysql" scheme="http://example.com/categories/mysql/"/>
    
    
    <category term="binlog" scheme="http://example.com/tags/binlog/"/>
    
    <category term="mysql" scheme="http://example.com/tags/mysql/"/>
    
    <category term="慢查询日志" scheme="http://example.com/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/"/>
    
    <category term="redo" scheme="http://example.com/tags/redo/"/>
    
    <category term="undo" scheme="http://example.com/tags/undo/"/>
    
  </entry>
  
  <entry>
    <title>Canal binlog 日志 Dump 流程分析</title>
    <link href="http://example.com/posts/aeb9a46c.html"/>
    <id>http://example.com/posts/aeb9a46c.html</id>
    <published>2020-12-12T14:05:01.000Z</published>
    <updated>2020-12-12T15:44:36.432Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>Canal 的 dump 支持串行和并行模式两种模式，本篇重点梳理 dump 的核心流程，以便对 dump 过程有一个充分的了解，更好的理解 Canal 的实现原理与细节，下一篇中将重点关注Canal是如何引入并行模式来提高dump的性能，即并行编程相关的技巧。</p><p>从前面的文章我们得知 Canal binlog 日志解析的基本流程如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200809175601739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>解析来重点梳理一下 dump 命令的发送逻辑，特别是日志的处理流程，一些基本的日志格式。</p><h2 id="1、-dump-流程分析"><a href="#1、-dump-流程分析" class="headerlink" title="1、 dump 流程分析"></a>1、 dump 流程分析</h2><p>在 Canal 中 dump 方法声明如下：<br><img src="https://img-blog.csdnimg.cn/20200809175612589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>带有参数 MultiStageCoprocessor 为并行处理模式，底层使用了disruptor 高性能并发框架，下文将重点关注学习。我们今天重点来看一下串行dump的实现，其方法声明如下：<img src="https://img-blog.csdnimg.cn/20200809175625678.png#pic_center" alt="在这里插入图片描述">其方法参数说明如下：</p><ul><li>String binlogfilename<pre><code> binlog 文件名称，例如  mysql-bin.000038。</code></pre></li><li>Long binlogPosition<br>在文件中的偏移量。</li><li>SinkFunction func<br>每解析出一条binlog日志的处理函数。</li></ul><p>接下来我们直奔主题，一起来看一下 MysqlConnection 关于 dump 的实现流程。</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20200809175645466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="MysqlConnection#dump"><br>Step1：在发送dump之前先设置相关的参数。</p><ul><li>set wait_timeout=9999999<br>连接空闲超时时间，默认为8消息，用于 Canal Slave 的等待超时时间远大于默认值。</li><li>set net_write_timeout=1800<br>网络写请求超时时间，针对正在进行数据读写的连接，该值默认为 60s。</li><li>set net_read_timeout=1800<br>网络读请求超时时间，针对正在进行数据读写的连接，该值默认为 30s。</li><li>set names ‘binary’<br>设置服务端返回结果时不做编码转化，直接按照数据库的二进制编码进行发送，由客户端自己根据需求进行编码转化。</li><li>set @master_binlog_checksum= @@global.binlog_checksum<br>设置master_binlog_checksum，因为在mysql5.6之后为binlog引入了checksum机制，例如crc32，canal作为mysql slave，需要与服务端相关参数保持一致。</li><li>set @slave_uuid=uuid()<br>canal相对与mysql数据库服务而言就是一个从服务器，这个指令用于设置server_id，使用uuid，避免server_id重复。</li><li>SET @master_heartbeat_period=15<br>设置客户端与服务端心跳发送间隔，默认为15s。<br><img src="https://img-blog.csdnimg.cn/20200809175657119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="MysqlConnection#dump"><br>Step2：从主库查询binlog checksum，具体向主库发送 select @@global.binlog_checksum 语句。<br><img src="https://img-blog.csdnimg.cn/20200809175707476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="MysqlConnection#dump"><br>Step3：向MySQL Master 注册从节点，告知客户端的host、port、用户名与密码、serverId，具体实现是发送命令CODE为 0x15。<br><img src="https://img-blog.csdnimg.cn/20200809175717357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="MysqlConnection#dump"><br>Step4：向 MySQL Master 发送 dump 请求，MySQL是基于请求与应答模式，发送请求命令后，就会向网络通道中写入响应请求。（在这里大家不妨先大概思考一下如何读取 dump 命令的返回值，这部分虽然涉及到网络相关的知识，我在这边会稍微简单提一下）。<br><img src="https://img-blog.csdnimg.cn/20200809175726519.png#pic_center" alt="MysqlConnection#dump"><br>Step5：构建 DirectLogFetcher对象，实现基于 socket 的日志拉取服务，并构建 LogDecoder 对象，用于解析 binlog 日志。<br><img src="https://img-blog.csdnimg.cn/20200809175748490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="MysqlConnection#dump"><br>Step6：使用 while 循环反复拉取消息，通过通过 LogDecoder 对二进制流进行解析，提取一条完整的binlog事件，交给 SinkFunction 去处理，并且如果开启了半同步机制，则需要向master发送ACK。既然是while循环，该方法的退出条件还是值的我们关注的：</li><li>fetch.fetch()方法返回 false</li><li>SinkFunction 的 sink 方法 false，SinkFunction的详细处理流程将在下文介绍，这里先告知返回false的情况是 binlog 日志解析线程已停止运行。</li></ul><p>上面粗略的介绍了 dump 命令的几个核心关键步骤，要想详细掌握其实现细节，我们必须继续深入探讨如下几个问题：</p><ul><li>DirectLogFetcher 内部工作机制</li><li>LogDecoder binlog 日志解析</li><li>发送Dump底层网实现思路</li></ul><h2 id="2、DirectLogFetcher-内部工作机制"><a href="#2、DirectLogFetcher-内部工作机制" class="headerlink" title="2、DirectLogFetcher 内部工作机制"></a>2、DirectLogFetcher 内部工作机制</h2><h4 id="2-1-DirectLogFetcher-类图"><a href="#2-1-DirectLogFetcher-类图" class="headerlink" title="2.1 DirectLogFetcher 类图"></a>2.1 DirectLogFetcher 类图</h4><p><img src="https://img-blog.csdnimg.cn/20200809175803860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>DirectLogFetcher的类继承体系如上图所示，我们来看一下其关键点：</p><ul><li>LogBuffer<br>日志buffer，主要定义如下属性：</li><li>byte[] buffer<br>缓存区中数据容器。</li><li>int origin<br>当前buffer中的读指针</li><li>int limit<br>当前buffer的最大可读可写指针</li><li>int position<br>当前buffer的写指针。</li><li>int semival<br>是否需要发送ACK(用于半同步)。<br>LogBuffer封装了字节相关的操作，不仅定义了上面的属性，也定义了字节读取相关众多API，其截图如下：<br><img src="https://img-blog.csdnimg.cn/20200809175816470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>LogFetcher<br>binlog日志抓取抽象类，定义了如下关键属性与抽象方法。<ul><li>int DEFAULT_INITIAL_CAPACITY<br>LogBuffer中的初始容量，默认为8K。</li><li>float DEFAULT_GROWTH_FACTOR<br>容量增长因子，默认为 2.0。</li><li>int   BIN_LOG_HEADER_SIZE<br>binlog日志条目 header 的长度，固定为4字节。</li><li>float  factor<br>  增长因子。</li><li>public abstract boolean fetch()<br>抓取binlog日志。</li><li>public abstract void close() <pre><code>    关闭 Fetch。</code></pre></li></ul></li><li>DirectLogFetcher<br>Canal LogFetcher模式实现类，其核心属性如下：<ul><li>SocketChannel channel<br>网络通道，用于发送dump请求的网络通道。</li><li>boolean issemi = false<br>是否开启半同步。</li></ul></li></ul><h4 id="2-2-fetch流程详解"><a href="#2-2-fetch流程详解" class="headerlink" title="2.2 fetch流程详解"></a>2.2 fetch流程详解</h4><p>接下来我们重点剖析 DirectLogFetcher 的 fetch 方法，来探究其实现原理。<br>在研究DirectLogFetcher的fetch方法之前，我们先重点跟踪一下其内部网络读写方法fetch0方法，该方法是具体与网络读写相关的实现。<br><img src="https://img-blog.csdnimg.cn/20200809175830366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="DirectLogFetcher#fetch0"><br>在详细介绍该方法之前先来介绍一下其参数的含义：</p><ul><li>int off<br>从通道中读取到的内容放入到buffer中的起始位置</li><li>int len<br>期望从通道中读取的字节长度。</li></ul><p>该方法的实现关键点如下：</p><ul><li>首先先确保接收缓存区有足够的剩余空间，如果空间不足，则进行扩容。</li><li>然后从通道中读取指定长度的字节。</li></ul><p>接下来我们来重点看一下DirectLogFetcher的fetch的实现流程。<br><img src="https://img-blog.csdnimg.cn/20200809175842606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="DirectLogFetcher#fetch"><br>Step1：尝试从网络通道中读取４个字节（即读取协议的头部），如果通道中还没有可读取内容，返回false，造成的效果是一次 dump 请求结束。<br><img src="https://img-blog.csdnimg.cn/202008091758523.png#pic_center" alt="DirectLogFetcher#fetch"><br>Step2：从上文读到的４个字节分别读出该网络包的总长度以及当前包的序号，从这里可以看成MySQL协议头为４字节，前３个字节为网络包的总长度，第４个字节为包的序列号。再取出数据包的长度后，继续向通道中读取netlen个字节，即读取一个完整的数据包到buffer中。<br><img src="https://img-blog.csdnimg.cn/2020080917590177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="DirectLogFetcher#fetch"><br>Step3：继续从数据包中读取一个字节，判断该包的状态码，是否是一个成功的响应，如果是错误的响应，会向外抛出一次，Canal 会记录dump命令执行错误的次数。<br><img src="https://img-blog.csdnimg.cn/20200809175910291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="DirectLogFetcher#fetch"><br>Step４：如果一个包的长度为允许的最大包长度，则继续读取，这个主要是根据MySQL协议做的处理，即读取到一个数据包，然后返回true，表示拉取到一条日志，然后通过LogDecoder解码，然后传入到sink方法中，进行日志的后续处理。<br><img src="https://img-blog.csdnimg.cn/2020080917592088.png#pic_center" alt="DirectLogFetcher#fetch"><br>Step5：这一步的目的，就是将buffer中的当前指针指向数据的开始位置。这样一次 fetch就结束了。</p><p>从上面的流程来看，DirectLogFetcher#fetch 方法结束后，就将进入到LogDecoder中。经过一次DirectLogFetcher#fetch方法后，即取回一条binlog日志，即二进制流，接下来就根据binlog协议对其解析。本文暂不深入该方法，如果大家想深入数据库中间件方面，可以作为一个很好的示例，面向MySQL通信协议进行编程。</p><h2 id="３、SinkFunction"><a href="#３、SinkFunction" class="headerlink" title="３、SinkFunction"></a>３、SinkFunction</h2><p>通过 LogDecoder从中解析一个事件后，会调用SinkFunction的sink方法，如果该方法返回 false，一次dump请求将介绍，接下来我们看一下其sink方法。<br><img src="https://img-blog.csdnimg.cn/20200809175932873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="AbstractEventParser＃start"><br>该方法的实现比较简单，这里不打算继续深入，我们重点来看一下 Canal.Entry 的结构：<br><img src="https://img-blog.csdnimg.cn/20200809175945791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这个结构是基于Canal做架构设计，解决顺序消费、数据不丢失一个重要参考依据，没解析一条事务，最终放如到环形缓存区，环形缓存区尽量以一个事务提交到Sink组件，其代码如下：<br><img src="https://img-blog.csdnimg.cn/20200809175956839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这里主要有如下几个关键点：</p><ul><li>首先需要调用EventSink组件将解析出来的数据传入EventSink。</li><li>EventSink组件处理成功后，会提交解析位点。</li></ul><p>本文就介绍到这里了，Dump的流程就分析到这里了。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;Canal 的 dump 支持串行和并行模式两种模式，本篇重点梳理 dump 的核心流程，以便对 dump 过程有一个充分的了解，更好的理解 Canal 的实现原理与细节，下一篇中将重点关注Canal是如何引入并行模式来提高dump的性能，即并行编程相关的技巧。&lt;/p&gt;
&lt;p&gt;从前面的文章我们得知 Canal binlog 日志解析的基本流程如下图所示：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200809175601739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;解析来重点梳理一下 dump 命令的发送逻辑，特别是日志的处理流程，一些基本的日志格式。&lt;/p&gt;
&lt;h2 id=&quot;1、-dump-流程分析&quot;&gt;&lt;a href=&quot;#1、-dump-流程分析&quot; class=&quot;headerlink&quot; title=&quot;1、 dump 流程分析&quot;&gt;&lt;/a&gt;1、 dump 流程分析&lt;/h2&gt;&lt;p&gt;在 Canal 中 dump 方法声明如下：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200809175612589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;带有参数 MultiStageCoprocessor 为并行处理模式，底层使用了disruptor 高性能并发框架，下文将重点关注学习。我们今天重点来看一下串行dump的实现，其方法声明如下：&lt;img src=&quot;https://img-blog.csdnimg.cn/20200809175625678.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;其方法参数说明如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String binlogfilename&lt;pre&gt;&lt;code&gt; binlog 文件名称，例如  mysql-bin.000038。&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;Long binlogPosition&lt;br&gt;在文件中的偏移量。&lt;/li&gt;
&lt;li&gt;SinkFunction func&lt;br&gt;每解析出一条binlog日志的处理函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来我们直奔主题，一起来看一下 MysqlConnection 关于 dump 的实现流程。&lt;/p&gt;</summary>
    
    
    
    <category term="canal" scheme="http://example.com/categories/canal/"/>
    
    
    <category term="canal" scheme="http://example.com/tags/canal/"/>
    
    <category term="数据异构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BC%82%E6%9E%84/"/>
    
    <category term="dump" scheme="http://example.com/tags/dump/"/>
    
    <category term="binlog" scheme="http://example.com/tags/binlog/"/>
    
  </entry>
  
  <entry>
    <title>Canal binlog 日志管理器与GTID简介</title>
    <link href="http://example.com/posts/f051946a.html"/>
    <id>http://example.com/posts/f051946a.html</id>
    <published>2020-12-12T14:03:01.000Z</published>
    <updated>2020-12-12T15:44:36.432Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>正如上文提到的那样，在 Canal Instance 启动的时候，首先会查询日志管理器中查找上一次的同步位点，如果没有查询到，则默认会从最新的位点开始同步，但如果每一次启动Instance都从最后开始同步，其数据完整性无法保证，正确的做法是在数据同步的过程中应该记录位点并持久化，重新启动后按照继续从上一次的位置继续同步，实现真正的增量同步。</p><p>本文就是来详细探讨 Canal的几个日志管理器，并来探究一下MySQL的GTID机制。</p><a id="more"></a><h2 id="1、Canal-位点管理（日志管理器）"><a href="#1、Canal-位点管理（日志管理器）" class="headerlink" title="1、Canal 位点管理（日志管理器）"></a>1、Canal 位点管理（日志管理器）</h2><h3 id="1-1-类图"><a href="#1-1-类图" class="headerlink" title="1.1 类图"></a>1.1 类图</h3><p><img src="https://img-blog.csdnimg.cn/20200726150555918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>整个日志管理器由接口 CanalLogPositionManager定义，主要定义两个方法：</p><ul><li>LogPosition getLatestIndexBy(String destination)<br>根据destination获取同步位点，即在Canal Instance 中同步进度是以源实例为最小维度的。</li><li>void persistLogPosition(String destination, LogPosition logPosition)<br>持久化同步位点。</li></ul><p>Canal 中提供了7种位点管理机制，分别如下：</p><ul><li>MemoryLogPositionManager<br>同步位点存储在内存中，即存放在 Map&lt;String, LogPosition&gt; positions 中，通常用于测试或结合其他位点管理，用来提高性能。</li><li>ZooKeeperLogPositionManager<br>同步位点存储在zookeeper中，是主流的分布式存储方案。</li><li>MetaLogPositionManager<br>Canal中的元数据存储方式，即位点信息与元数据存放在一起。</li><li>MixedLogPositionManager<br>混合日志位点管理器，主要是内存与Zookeeper的混合方式，在存储位点时先存入内存，然后用线程池异步存储到zookeeper中。</li><li>FileMixedLogPositionManager<br>基于内存与本地文件的混合日志管理器，存储位点时首先存入内存，然后定时同步到文件中。</li><li>PeriodMixedLogPositionManager<br>带定时功能的基于内存与zookeeper的混合日志管理器，存储位点时先写入内存，然后定时同步到zookeeper。</li><li>FailbackLogPositionManager<br>待failback机制的日志位点管理器，即可以创建准备两种日志管理器，例如在构建时可以将 ZooKeeperLogPositionManager 当为主管理器，基于 FileMixedLogPositionManager 当备用日志位点管理器，在写入日志位点时，尝试写入主日志管理器，如果抛出异常，则使用备用日志管理器；查询位点时先查主日志<br>管理器，如果未查到，则查备用日志管理器。</li></ul><h3 id="1-2-日志管理器使用方法"><a href="#1-2-日志管理器使用方法" class="headerlink" title="1.2 日志管理器使用方法"></a>1.2 日志管理器使用方法</h3><p>由于Canal日志管理器的实现比较简单，这里就不一一去看源码了，那这里就重点介绍一下其使用方法。</p><p>CanalInstanceWithManager#initLogPositionManager<br><img src="https://img-blog.csdnimg.cn/2020072615072310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">从这里可以看到，Canal 提供了 indexMode 属性来指定使用哪种日志管理器，其可选项：</p><ul><li>MEMORY<br>内存</li><li>ZOOKEEPER<br>基于zookeeper，使用该模式还需要通过 zkClusters 设置 zk 集群的地址。</li><li>MIXED<br>混合模式，基于内存+Zookeeper + Period，即定时存储到 zookeeper 中，使用的实现类为MixedLogPositionManager，默认为每隔1s持久化一次。</li><li>META<br>基于元数据的管理模式。</li><li>MEMORY_META_FAILBACK<br>基于内存与元数据的fallback，其中主日志管理器为 MEMORY。</li></ul><blockquote><p>在生产环境，通常建议使用 MIXED，基于内存与Zookeeper的混合模式。</p></blockquote><h2 id="2、MySQL-GTID-扫盲"><a href="#2、MySQL-GTID-扫盲" class="headerlink" title="2、MySQL GTID 扫盲"></a>2、MySQL GTID 扫盲</h2><p>在MySQL5.6.x中引入了GTID机制，用于优化主从同步机制，本文不打算详细介绍GTID的方方面面，只是初步认识GTID，方面在后续实现数据同步方面思考数据一致性如何保证等方案时具备必要的基础。</p><p>首先我们可以通过如下命令查看与gtid相关的属性。<br><img src="https://img-blog.csdnimg.cn/20200726150842239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>主要的变量的含义如下：</p><ul><li>gtid_executed<br>当前MySQL实现已经执行过的事务。在开启GTID模块时每执行一个事务会产生一个全局唯一的事务ID。再每一台MySQL实例上执行的事务何止上亿，这个字段要存储所有已执行的的事务ID，怎么存储能节省空间就是一个需要解决的问题，稍后再进行展开说明。</li><li>gtid_executed_compression_period<pre><code> 在MySQL5.7版本专门引入了一个系统表：mysql.gtid_executed，gtid_executed_compression_period 参数就是设置每执行多个事务，对这个表进行压缩，默认值为1000。</code></pre></li><li>gtid_mode<br>是否开启gtid模式。</li><li>gtid_purged<br>已不在binlog日志中的事务ID，Mysql并不会永久存储binlog日志，而是通过 expire_logs_days 设置过期时间，单位为天，默认为10天。</li></ul><p>一个GTID由两部分组成：server id uuid 与递增序号，两者之间用英文冒号隔开，例如上图中的：1f0eee4c-a66e-11ea-8999-00dbdfe417b8:1。</p><p>再来回到 gtid_executed 的存储问题上，为了减少存储空间，连续的gtid可以用进行合并，例如  1f0eee4c-a66e-11ea-8999-00dbdfe417b8:1-10，表示连续代表1-10个事务。</p><p>GTID的生成有自动递增与手动执行模式，自动递增模式可以在单个Server集群中保证有序，即GTID值越大，说明事务越后执行，但如果进行了人工干预，GTID就不是越大越先执行了，举例如下：<br><img src="https://img-blog.csdnimg.cn/20200726150942999.png#pic_center" alt="在这里插入图片描述"><br>通过如下命令手动指定gtid：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set gtid_next&#x3D;&#39;1f0eee4c-a66e-11ea-8999-00dbdfe417b8:10&#39;;</span><br><span class="line">begin;</span><br><span class="line">commit;</span><br><span class="line">set gtid_next&#x3D;&#39;AUTOMATIC&#39;;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200726151133619.png#pic_center" alt="在这里插入图片描述"><br>故这里产生了另外一个事件，其gtid 为 10,下一条语句产生的GTID会是 11 还是 4 呢？<br><img src="https://img-blog.csdnimg.cn/20200726151150175.png#pic_center" alt="在这里插入图片描述"><br>从这里看成，会先使用空洞，其binlog记录如下。<br><img src="https://img-blog.csdnimg.cn/20200726151203444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从这里看出，在后续避免数据顺序性方面，使用GTID并不是一个十全的方法，基于binlog的写入时间更为靠谱。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;正如上文提到的那样，在 Canal Instance 启动的时候，首先会查询日志管理器中查找上一次的同步位点，如果没有查询到，则默认会从最新的位点开始同步，但如果每一次启动Instance都从最后开始同步，其数据完整性无法保证，正确的做法是在数据同步的过程中应该记录位点并持久化，重新启动后按照继续从上一次的位置继续同步，实现真正的增量同步。&lt;/p&gt;
&lt;p&gt;本文就是来详细探讨 Canal的几个日志管理器，并来探究一下MySQL的GTID机制。&lt;/p&gt;</summary>
    
    
    
    <category term="canal" scheme="http://example.com/categories/canal/"/>
    
    
    <category term="canal" scheme="http://example.com/tags/canal/"/>
    
    <category term="数据异构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BC%82%E6%9E%84/"/>
    
    <category term="binlog" scheme="http://example.com/tags/binlog/"/>
    
    <category term="gtid" scheme="http://example.com/tags/gtid/"/>
    
  </entry>
  
  <entry>
    <title>Canal 初次启动时如何定位同步位点(文末附流程图)</title>
    <link href="http://example.com/posts/dcbc2c14.html"/>
    <id>http://example.com/posts/dcbc2c14.html</id>
    <published>2020-12-12T14:00:01.000Z</published>
    <updated>2020-12-12T15:44:36.422Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文将详细剖析Canal在初次启动时如何定位同步位点，行为思路先源码，再辅以流程图进行说明，并在总结部分使用思维导图进行总结，试图引发各位的讨论。</p><h2 id="1、Canal定位启动位点"><a href="#1、Canal定位启动位点" class="headerlink" title="1、Canal定位启动位点"></a>1、Canal定位启动位点</h2><p>在一个 Canal Instance 实例启动时，在向 MySQL 发送 dump 命令之前，首先先得计算该从 binlog 的什么位置开始同步，初次启动时如何寻找位点等。其代码如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200719150553488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="AbstractEventParser#start"><br>从这里可以看成，将调用 findStartPosition 方法查找启动时需要从那个位置开始同步 binglog ,该方法是一个抽象方法，具体实现在其子类中，我们将重点关注一下其子类 MysqlEventParser。<br><img src="https://img-blog.csdnimg.cn/20200719150633861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="MysqlEventParser#findStartPostion"><br>在MySQL中定位binlog日志可以分为gtid、binlog文件名+position两种方式，故Canal查找position的方式也分两种情况进行展开，由于篇幅问题，本节将暂不考虑gtid。</p><p>这里主要是调用 findStartPositionInternal 方法进行查找位点，这里还有一个标记 needTransactionPosition，表示查出来的位点是不是一个事务的开始或结束。</p><p>接下来重点探讨 Canal在启动时如何定位解析位点的。</p><a id="more"></a><h4 id="1-1-查找位点"><a href="#1-1-查找位点" class="headerlink" title="1.1 查找位点"></a>1.1 查找位点</h4><p><img src="https://img-blog.csdnimg.cn/20200719150704437.png#pic_center" alt="MysqlEventParser#findStartPositionInternal"><br>Step1：使用位点存储管理器中查看已解析过的位点数据，Canal 提供了多种日志管理实现，这部分稍后会详细展开。<br><img src="https://img-blog.csdnimg.cn/20200719150726743.png#pic_center" alt="MysqlEventParser#findStartPositionInternal">Step2：这里分如下两种情况</p><ul><li>如果日志位点管理器(LogPositionManager)中并未存储相关的位点信息，例如初次启动时的处理逻辑。</li><li>如果日志位点管理器中已存储相关的位点信息的处理逻辑。</li></ul><p>由于初次启动时日志位点管理器并没有存储其位点信息，故我们先看位点管理器并未存储位点的情况。<br><img src="https://img-blog.csdnimg.cn/20200719150813198.png#pic_center" alt="MysqlEventParser#findStartPositionInternal"><br>Step3：如果当前连接的是主节点，则尝试使用 masterPosition，如果当前连接的是从节点（发生了切换），即使用 standbyPosition，那这两个位点信息是从哪来的的呢？原来在 Canal Instance 实例启动之前，可以手动通过 positions 属性手动设置开始解析位点。<br><img src="https://img-blog.csdnimg.cn/20200719150831508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="MysqlEventParser#findStartPositionInternal">Step4：如果在启动时未手动设置初始解析位点，则从当前 binlog 日志最后的位点开始同步，其实现原理是向 MySQL 服务器发送 show master status\G 命令，其命令输出结果如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200719150856825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center"><br>接下来再关注一下如果从日志位点管理器中查找到位点的处理逻辑，在进入该流程的探究之前，先看一下表示位点的实体类，一睹其结构。<br><img src="https://img-blog.csdnimg.cn/20200719150911285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>会在 LogIdentity 中记录该日志位点是由哪个 slaveId 以及所连接的 MySQL 服务器信息。<br><img src="https://img-blog.csdnimg.cn/20200719150952220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="MysqlEventParser#findStartPositionInternal"><br>Step5：如果从日志位点管理器中查询到位点，则需要判断当前连接的服务器地址与日志位点中记录的是否一致，如果不一致则说明发生了故障切换，为了确保数据不丢失，提供了回退时间的机制，其具体实现关键点如下：</p><ul><li>如果解析 dump 出现的次数超过其阔值，可能是基于VIP模式发生了漂移，此时可以根据 serverId 来判断是否发生了切换，如何切换了，则按时间回退来重新寻找位点。</li><li>如果查找到的位点连接的信息与当前连接的信息不符合，说明发生了切换，则需要回退指定的时间，即根据时间区重新定位位点，至于回退多久的时间，可以通过参数 fallbackIntervalInSeconds 进行设置，默认为 60s。</li></ul><p>Canal Instance 启动时如何定位同步位点的流程就介绍到这里了，接下来我们再来看一下 Canal 如何基于时间戳来定位 binlog 位点。</p><p>为了流程的完整性，在学习如何根据时间戳查找binlog位点之前，我们先来看一下从位点管理器中查询到对应的位点信息后的处理流程。<br><img src="https://img-blog.csdnimg.cn/2020071915102882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="MysqlEventParser#findStartPositionInternal">如果从位点管理器中查询到位点信息，首先判断当前连接的MySQL服务器(主或从)与位点信息是否一致，如果不一致，说明发生了主从切换，为了保证数据的完整性，需要对位点进行前移，默认为回退到60s之前的位点，</p><h4 id="1-2-基于时间戳从查找-binlog-位点"><a href="#1-2-基于时间戳从查找-binlog-位点" class="headerlink" title="1.2 基于时间戳从查找 binlog 位点"></a>1.2 基于时间戳从查找 binlog 位点</h4><p>基于时间戳查找 binlog 位点的实现方法为 MysqlEventParser 的　findByStartTimeStamp，接下来我们来看一下其实现原理。<br><img src="https://img-blog.csdnimg.cn/2020071915111442.png#pic_center" alt="MysqlEventParser#findByStartTimeStamp"><br>Step1：首先先查询最大的位点与最小位点，最小位点可发送SQL：show binlog events limit 1。<br><img src="https://img-blog.csdnimg.cn/2020071915113412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="MysqlEventParser#findByStartTimeStamp"><br>Step2：然后从最后一个文件开始，尝试根据开始时间戳进行日志查找，等下会详细介绍如果从一个binlog日志定位 endposition。<br><img src="https://img-blog.csdnimg.cn/2020071915115830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="MysqlEventParser#findByStartTimeStamp"><br>Step3：如果找到一个合适的endposition，则结束寻找。如果没有找到一个合适的endposition，则尝试向前一个文件进行解析，首先解析出要查找的最小文件的名称，例如(mysql-bin.000036)，从文件名称序号，然后减1，再判断该文件名是否小于这次可查找的最小文件名，如果不大于，则向前继续选择，否则结束查找，返回null。</p><p>接下来我们看一下如果在一个binlog文件中根据时间戳查找合适的位点。<br><img src="https://img-blog.csdnimg.cn/20200719152049556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="MysqlEventParser#findAsPerTimestampInSpecificLogFile"><br>通过向 MySQL Master 发送 dump 命令，建立连接，一条一条从 binlog 日志中解析事件，一条日志日志进行匹配，每从master获取一个logevent，调用 SinkFunction 的 seek 方法。<br><img src="https://img-blog.csdnimg.cn/20200719152108279.png#pic_center" alt="在这里插入图片描述"><br>Step1：如果 justForPositionTimestamp 参数为 true，表示在查询位点时只考虑时间戳，并不考虑事务，在按开始时间戳寻找的方法中该参数为 false，即不会进入该方法。<br><img src="https://img-blog.csdnimg.cn/20200719151412889.png#pic_center" alt="SinkFunction#sink"><br>Step2：获取当前日志的基本信息，例如所在的binlog日志文件、日志偏移量、日志写入时间戳、master serverId。<br><img src="https://img-blog.csdnimg.cn/2020071915143632.png#pic_center" alt="SinkFunction#sink"><br>Step3：如果记录日志的时间戳大于等于待查找的时间戳，返回 false，停止在文件中的停止，是否继续查找其他文件取决在在当前文件中是否已查到符合条件的日志(LogEvent)，即是否查找到小于或等于要查找的时间戳。</p><blockquote><p>温馨提示：按照时间戳去查找，其设计理念就是查找小于待查找时间戳中的最大时间戳的LogEvent。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200719151456693.png#pic_center" alt="SinkFunction#sink"><br>Step4：如果当前的解析的日志偏移量小于此次待查找的最大偏移量，同样结束本文件的查找（针对查找的第一个文件）。因为在查询的时候，首先会查询当前最大偏移量，即查找时的快照，新的内容不在本次查找范围内。<br><img src="https://img-blog.csdnimg.cn/20200719152416688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step5：重点查找事件类型为TRANSACTIONEND与TRANSACTIONBEGIN ，即事务结束与事务开始的事件，并将其存储在 logPostion 中，表示该文件中满足查找条件的事件，但并不是只要找到一条就退出，而是继续向后找，直到找到最合适的事件。</p><p>由于源码剖析不够直观，为了更好的理解按照时间戳查找日志位点，再给出其流程图，如下：<br><img src="https://img-blog.csdnimg.cn/20200719152451570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="2、总结"><a href="#2、总结" class="headerlink" title="2、总结"></a>2、总结</h2><p>阅读源码不那么直观，故先来一张流程图对其进行一个总结，辅助大家了解定位位点的核心步骤。<br><img src="https://img-blog.csdnimg.cn/20200719152508266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将详细剖析Canal在初次启动时如何定位同步位点，行为思路先源码，再辅以流程图进行说明，并在总结部分使用思维导图进行总结，试图引发各位的讨论。&lt;/p&gt;
&lt;h2 id=&quot;1、Canal定位启动位点&quot;&gt;&lt;a href=&quot;#1、Canal定位启动位点&quot; class=&quot;headerlink&quot; title=&quot;1、Canal定位启动位点&quot;&gt;&lt;/a&gt;1、Canal定位启动位点&lt;/h2&gt;&lt;p&gt;在一个 Canal Instance 实例启动时，在向 MySQL 发送 dump 命令之前，首先先得计算该从 binlog 的什么位置开始同步，初次启动时如何寻找位点等。其代码如下图所示：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200719150553488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;AbstractEventParser#start&quot;&gt;&lt;br&gt;从这里可以看成，将调用 findStartPosition 方法查找启动时需要从那个位置开始同步 binglog ,该方法是一个抽象方法，具体实现在其子类中，我们将重点关注一下其子类 MysqlEventParser。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200719150633861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;MysqlEventParser#findStartPostion&quot;&gt;&lt;br&gt;在MySQL中定位binlog日志可以分为gtid、binlog文件名+position两种方式，故Canal查找position的方式也分两种情况进行展开，由于篇幅问题，本节将暂不考虑gtid。&lt;/p&gt;
&lt;p&gt;这里主要是调用 findStartPositionInternal 方法进行查找位点，这里还有一个标记 needTransactionPosition，表示查出来的位点是不是一个事务的开始或结束。&lt;/p&gt;
&lt;p&gt;接下来重点探讨 Canal在启动时如何定位解析位点的。&lt;/p&gt;</summary>
    
    
    
    <category term="canal" scheme="http://example.com/categories/canal/"/>
    
    
    <category term="canal" scheme="http://example.com/tags/canal/"/>
    
    <category term="数据异构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BC%82%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Canal 如何实现数据库库事务的一致性</title>
    <link href="http://example.com/posts/d0c99696.html"/>
    <id>http://example.com/posts/d0c99696.html</id>
    <published>2020-12-12T13:59:01.000Z</published>
    <updated>2020-12-12T15:44:36.432Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文将主要介绍在 EventParser binlog 日志同步流程中关于环形缓存区的使用技巧。</p><h2 id="1、环形缓存区"><a href="#1、环形缓存区" class="headerlink" title="1、环形缓存区"></a>1、环形缓存区</h2><p>关系型数据库讲究的是ACID 4个特性，故引入了数据库事务的概念，一个数据库事务中的多条SQL引发的多条数据变更要么全部成功，要么全部失败，即数据的一致性，那同样在数据同步的场景，在解析一个事务的 binlog 日志时，一次数据同步应该至少以事务为单位，一个事务内的所有 Event 应该作为一个批次提交到数据消费端，让消费端有能力一次同步一个事务中的数据，而不是一条一条变更日志的处理，这样容易造成数据不一致。</p><p>环形缓存区的引用就是为了解决将一个事务的完整数据一次提交到消费端，既然是多条消息，故一定需要用到缓存，环形缓存区就在这样的背景下被引入。</p><p>在 Canal 中关于事务 Event 的环形缓存区实现类为 EventTransactionBuffer。</p><a id="more"></a><h4 id="1-1-类图"><a href="#1-1-类图" class="headerlink" title="1.1 类图"></a>1.1 类图</h4><p>EventTransactionBuffer 的类图如下：<br><img src="https://img-blog.csdnimg.cn/2020071215153646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>根据类图我们可以到其存储结构还是比较简单的。</p><ul><li>int bufferSize环形缓存区的长度，默认为 1024，该长度必须为 2 的幂次方，因为对位运算非常友好。</li><li>int indexMask环形缓存区下标掩码，其值为 bufferSize - 1 ，sequence * indexMask 能快速定位序号 sequence 所在环形缓存区中的具体下标。</li><li>CannalEntry.Entry[] entries环形缓存区数据数组，即缓存区实际存储数据的内存区域，为数组结构，长度为 bufferSize。</li><li>AtomicLong putSequence当前写入的序号，每调用 add 方法添加一条数据，该值增加一，可超过缓存区的实际长度。</li><li>AtomicLong flushSequence当前已处理的数据序号，flushSequence &lt;= putSequence，（putSequence - flushSequence）表示未处理的数据，即缓存区累积的有效数据。</li><li>TransactionFlushCallback flushCallbackflush 回调函数，这个和环形缓存区本身关系不大，这个与 Canal 特定业务的，环形缓存区中收集到一个完整的事务变更日志列表后，将这部分内容传入业务回调方法，并重新利用这些缓存空间。</li></ul><p><strong>环形缓存区的重大要义就是循环利用。</strong></p><h4 id="1-2-环形缓存区存储实现"><a href="#1-2-环形缓存区存储实现" class="headerlink" title="1.2 环形缓存区存储实现"></a>1.2 环形缓存区存储实现</h4><p>接下来我们通过其 add 方法来看一下环形缓存区的，在研究环形缓存区之前，将结合8个元素的环形缓存区进行讲解。<br><img src="https://img-blog.csdnimg.cn/20200712151715438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>EventTransactionBuffer 的 add 方法代码如下：<br><img src="https://img-blog.csdnimg.cn/20200712151726412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>首先根据 binlog 事件类型来决定是否调用 flush 方法，这个就是实现将一个事务的事务一起提交到消费端，回到环形缓存区的具体实现，我们重点关注 put 方法 与 flush 方法的实现。<br>EventTransactionBuffer#put<br><img src="https://img-blog.csdnimg.cn/20200712152102435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其实现的核心步骤：</p><ol><li><p>检测当前环形缓存区是否已满，如果未满，则向缓存区中添加一条数据。添加数据的具体逻辑：</p><ul><li><p>获取下一个写入的序号 next，等于当前已写入的序号 + 1，即 putSequence + 1。</p></li><li><p>通过 next &amp; indexMask 取得放入 CannalEntry.Entry[] entries 中的下标，与 next % bufferSize 效果等同。</p></li></ul></li><li><p>如果已满，则首先将缓存区中的数据刷新，即将未处理的数据全部抽取，提交到数据消费方，然后释放缓存区，继续添加数据。</p></li></ol><p>关键在于如何判断环形缓存区已满，具体算法如下：<br>EventTransactionBuffer#checkFreeSlotAt<br><img src="https://img-blog.csdnimg.cn/20200712152142683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>为了加强对这段代码的理解，我举一个示例，在一个8个元素的环形缓存区中，假设一个事务包含5条日志，首先依次写入5条日志，其环形缓存区如下：<br><img src="https://img-blog.csdnimg.cn/20200712152158449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>此时 putSequence 为 4，flushSequence 为 -1 ，我们应该能发现，在第一轮时，由于 sequeue 小于 bufferSize ，如果不执行 flush 操作，连续写入 8条数据，sequence = 7 时，sequence - bufferSize &gt; flushSequence 这个表达式都不会满足，即代表缓存区未满，但在写入第9条消息时，sequence = 8 ，此时 sequence - bufferSize &gt; flushSequence 已满足，即缓存区已满，需要先刷新数据，然后才能再填充。</p><p>再回到本示例中，一个事务只包含5条日志，在写满 5条日志后会即调用 flush 方法，将环形缓存区中下标为 0~4 的消息传入数据消费方，在 Canal 中会将这批消息一次传入 EventSink 组件。执行完 flush 方法后，flushSequence 等于4，其环形缓存区如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200712152209765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>此时 putSequence = flushSequence = 4，那这个时候环形缓存区的容量是多少呢？其实就是又恢复到 bufferSize 了，那我们怎么计算环形缓存区当前已写入的消息呢？其实很简单，putSequence - flushSequence 表示已写入的元素数量。那当前剩余容量就等于 bufferSize - (putSequence - flushSequence )，即只需要 bufferSize - (putSequence - flushSequence ) &gt; 0 就表示有剩余空闲。有了这一层思路，就能明白 checkFreeSlotAt 的算法，这也是环形缓存区的核心所在。</p><blockquote><p>思考，Canal 基于环形缓存区的实现，一定能保证一个事务的所有变更日志都一次提交到 EventSink 组件吗，大家可以简单思考一下，在文末的总结部分有笔者的思考。</p></blockquote><p>答案是否定的，如果一个事务包含的日志条目超过了环形缓存区的长度，为了保证数据不丢失，会首先将环形缓存区的数据全部提交，然后接收新的数据，这样一个事务中的消息会被分成多次提交到 EventSink。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将主要介绍在 EventParser binlog 日志同步流程中关于环形缓存区的使用技巧。&lt;/p&gt;
&lt;h2 id=&quot;1、环形缓存区&quot;&gt;&lt;a href=&quot;#1、环形缓存区&quot; class=&quot;headerlink&quot; title=&quot;1、环形缓存区&quot;&gt;&lt;/a&gt;1、环形缓存区&lt;/h2&gt;&lt;p&gt;关系型数据库讲究的是ACID 4个特性，故引入了数据库事务的概念，一个数据库事务中的多条SQL引发的多条数据变更要么全部成功，要么全部失败，即数据的一致性，那同样在数据同步的场景，在解析一个事务的 binlog 日志时，一次数据同步应该至少以事务为单位，一个事务内的所有 Event 应该作为一个批次提交到数据消费端，让消费端有能力一次同步一个事务中的数据，而不是一条一条变更日志的处理，这样容易造成数据不一致。&lt;/p&gt;
&lt;p&gt;环形缓存区的引用就是为了解决将一个事务的完整数据一次提交到消费端，既然是多条消息，故一定需要用到缓存，环形缓存区就在这样的背景下被引入。&lt;/p&gt;
&lt;p&gt;在 Canal 中关于事务 Event 的环形缓存区实现类为 EventTransactionBuffer。&lt;/p&gt;</summary>
    
    
    
    <category term="canal" scheme="http://example.com/categories/canal/"/>
    
    
    <category term="canal" scheme="http://example.com/tags/canal/"/>
    
    <category term="数据异构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BC%82%E6%9E%84/"/>
    
    <category term="事务的一致性" scheme="http://example.com/tags/%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
    <category term="环形缓存区" scheme="http://example.com/tags/%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%AD%98%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>探究 Canal EventParser 的设计与实现奥妙</title>
    <link href="http://example.com/posts/7d86d97a.html"/>
    <id>http://example.com/posts/7d86d97a.html</id>
    <published>2020-12-12T13:57:01.000Z</published>
    <updated>2020-12-12T15:44:36.442Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文将从三个方面深度剖析 EventParser 组件。</p><ul><li>从官方文档看 EventParser 的设计思想</li><li>从 EventParser 初始化了解内部的是可配置项</li><li>从 EventParser 的启动窥探其工作实现原理</li></ul><blockquote><p>温馨提示：本篇篇幅较长，如果耐心阅读一定会有不错的收获，为了提高阅读体验，本文所有源码都是通过截图方式，大家可以重点阅读对应的文字说明，并在文末进行了总结。</p></blockquote><h2 id="1、官方文档看-EventParser"><a href="#1、官方文档看-EventParser" class="headerlink" title="1、官方文档看 EventParser"></a>1、官方文档看 EventParser</h2><p>首先我们先从官方文档来看 EventParser 的整体设计，其架构设计图如下所示：<br><img src="https://img-blog.csdnimg.cn/20200705153423275.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>上述图罗列出了 EventParser 的整体工作流程图，其关键步骤如下：</p><ol><li>从 Log Position 管理器中获取上一次解析的日志位点。</li><li>向 Mysql Master 节点发送 BINLOG_DUMP 请求。</li><li>Mysql Master 节点从 Slave 端传入的日志位点开始向从节点推送 binlog 日志。</li><li>Slave 接收 binlog 日志，调用 BinlogParser 解析 binlog日志。</li><li>将解析后的结构化数据传入到 EventSink 组件。</li><li>定时记录解析 binlog 的日志，以便重启后继续进行增量订阅。</li><li>上图中还罗列一个HA 特性，即需要同步的 Master 如果宕机，可以从它的其他从节点继续同步 binlog 日志，避免单点故障。</li></ol><p>官方文档有助于理解 EventParser 组件的实现原理，但关于如何使用 EventParser 的篇幅较少，故接下来将从源码的角度来反推 EventParser 的特性以及详细的工作实现原理，以便指导我们如何更好的使用 EventParser。</p><a id="more"></a><h2 id="2、源码剖析-EventParser-初始化"><a href="#2、源码剖析-EventParser-初始化" class="headerlink" title="2、源码剖析 EventParser 初始化"></a>2、源码剖析 EventParser 初始化</h2><p>从上篇文章我们即可得知，EventParser 组件是 Canal Instance 的四大核心组件之一，那本节的故事就从 CanalInstanceWithManager 的 initEventParser 方法开始。</p><p>CanalInstanceWithManager#initEventParser<br><img src="https://img-blog.csdnimg.cn/20200705153640787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step1：获取数据库的连接信息，上面的代码就是集合的基本操作，但从上面的代码可以窥探如何配置数据库相关的地址信息。<br>配置 canal instance 中 数据库的地址，用户名密码有如下几种方式（CanalParamter）：</p><ul><li>单库场景配置方式一：CanalParmeter 中提供了 masterAddress、masterUsername、masterPassword、standbyAddress、standbyUsername、standbyPassword 6 个属性分别用来指定主库与从库的信息，配置了从库的目的是提供 HA 机制。</li><li>单库场景配置方式二：CanalParamter 提供的 List<InetSocketAddress>  dbAddresses 方式进行配置，该集合的第一个元素为主库地址、第二个元素为从库地址，其数据库用户名通过 dbUsername、dbPassword 来配置。</li><li>多库场景：CanalParmeter 提供了 List&lt; List&lt; DataSourcing&gt;&gt; groupDbAddresses 属性用来设置 mysql 组，例如 MySQL 分库分表。groupDbAddresses 的第一个元素为主库的地址列表，第二个元素为从库的地址列表。</li></ul><blockquote><p>温馨提示：这里的用户名与密码是在对应服务器用于进行 binlog 日志同步的账号信息。</p></blockquote><p>关于多库场景的配置，再详细举例如下：<br><img src="https://img-blog.csdnimg.cn/20200705153927828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其对应的初始化代码如下：<br><img src="https://img-blog.csdnimg.cn/20200705154029569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>CanalInstanceWithManager#initEventParser<br><img src="https://img-blog.csdnimg.cn/2020070515412716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step2：根据配置的 MySQL 构建 EventParser 实例。这里有如下几个关键点：</p><ul><li>如果配置的 MySQL 地址是组方式则会创建 GroupEventParser，其内部会维护一个 EventParser 列表。</li><li>通过调用 doInitEventParser 方法创建 EventParser 实例。</li></ul><p>接下来我们将重点查看 doInitEventParser 的实现细节。<br>CanalInstanceWithManager#doInitEventParser<br><img src="https://img-blog.csdnimg.cn/20200705154216986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step3：从这里可以看出 Canal 目前并不支持 Oracle 数据，只支持 MySQL 与 本地 binlog 文件(直接根据 binlog 日志文件解析)。</p><blockquote><p>温馨提示：接下来将重点探讨基于 MySQL binlog 日志，并且会忽略与阿里云相关的 RDS 、tsdb 等数据库辅助支持，只关系与开源 MySQL 相关的处理逻辑。</p></blockquote><p>CanalInstanceWithManager#doInitEventParser<br><img src="https://img-blog.csdnimg.cn/20200705154326555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step3：MySQL 的 binlog 事件解析器实现类为 MysqlEventParser，这里我们重点来阐述一下这些参数的含义：</p><ul><li>destination<br>Canal Instance 实例的名称。</li><li>connectionCharset<br>字符集，解析 binlog 时会将指定的字节数据使用该编码级进行转换，默认为UTF-8。</li><li>connectionCharsetNumber<br>字符集的数字表现形式，UTF8对应的值为 33，该值在与 MySQL 的交互协议包中需要被用到，这里 Canal 处理的不是特别好，最好该属性设置为只读，由 connectionCharset 联动进行设置。</li><li>defaultConnectionTimeoutInSeconds<br>MySQL 默认连接超时时间，因为 Canal 会伪装为 MySQL 服务器的 Slave 节点，需要向 MySQL Master 发送请求，故需要先创建链接，这里就是创建连接的默认超市时间，默认为 30s。</li><li>sendBufferSize<br>用于网络通道发送端缓存区，目前在 Canal 中网络通道的实现类为 BioSocketChannelPool、NettySocketChannelPool，从代码的角度来看，目前这个参数并不会生效，即使用操作系统的默认值。</li><li>receiveBufferSize<br>用于忘了通道接收缓存区大小，目前同 sendBufferSize 参数，并不会生效。</li><li>detectingEnable<br>是否开启心跳检测，默认为开启。</li><li>detectingSQL<br>心跳检测语句，例如 select 1，show master status 等。</li><li>detectingIntervalInSeconds<br>心跳间隔检测，默认为 3s。</li><li>slaveId<br>从服务器的 id，在同一个 MySQL 复制组内不能重复。</li></ul><p>CanalInstanceWithManager#doInitEventParser<br><img src="https://img-blog.csdnimg.cn/20200705154533494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step4：如果设置了 CanalPrameter 的 List<String> positions 属性，则将其解析为 EntryPosition 实体，我们来看一下如何表征 binlog 日志的位点信息。<br><img src="https://img-blog.csdnimg.cn/20200705154618806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其主要的核心参数如下：</p><ul><li>long timestamp<br>时间戳，用时间戳来表示位置</li><li>String journalName<br>binlog 日志的文件名，例如 mysql-bin.000001。</li><li>Long position<br>使用偏移量来表示具体位点。</li><li>long serverId<br>设置 master 的 id。</li><li>String gtid<br>全局事务ID。</li></ul><blockquote><p>温馨提示：实践指导，CanalParameter 的 List&lt; String&gt; positions 不支持组模式，只能设置一组，即第一个元素为主，第二个元素可以为从节点，该属性非必填。</p></blockquote><p>CanalInstanceWithManager#doInitEventParser<br><img src="https://img-blog.csdnimg.cn/20200705154725749.png#pic_center" alt="在这里插入图片描述"><br>Step5：继续设置参数，具体看一下各个参数的含义：</p><ul><li>fallbackIntervalInSeconds<br>如果 MySQL 主节点宕机，Canal 支持切换到其从节点继续同步 binlog 日志，但为了数据的完整性，可以设置一个回退时间，即会造成数据重复下发，但尽量不丢失，该值默认为 60s。</li><li>profilingEnabled<br>是否开启性能采集，主要采集的是一批日志经过 EventSink 组件处理到完成 存入EventStore 的时间消耗。 </li><li>filterTableError<br>是否忽略表过滤异常，默认为 false，表过滤会在后续文章中详细介绍。</li><li>parallel<br>解析、canal 接入 prometheus 采集监控数据是否支持并发，默认为 false。</li><li>isGTIDMode<br>是否开启 gtid 模式。</li></ul><p>CanalInstanceWithManager#doInitEventParser<br><img src="https://img-blog.csdnimg.cn/20200705154838454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step6：继续填充解析器相关参数，其重点实现如下：</p><ul><li>transactionSize<br>Canal 提供了一种机制，尝试讲一个数据库事务中所有的变更日志一起进行处理，这个为处理缓存事务日志的缓存区长度，默认为 1024。</li><li>logPositionManager<br>初始化日志位点管理器，Canal 提供了基于内存、zookeeper、内存与zookeepr混合管理器等日志位点管理器，这个后续会详细介绍。</li><li>AviaterRegexFilter<br>提供了基于 aviater 的正则表达式，对 table 名称进行过滤。</li><li>blackFilter<br>canal 提供了黑名单配置，提供黑名单正则表达式对 table 名称进行过滤。</li></ul><p>CanalInstanceWithManager#doInitEventParser<br><img src="https://img-blog.csdnimg.cn/20200705154936822.png#pic_center" alt="在这里插入图片描述"><br>Step7：如果解析器是 MySQL 解析器，提供了 HA 机制，即如果 MySQL Master 宕机，Canal 还能主动切换到 MYSQL Slave 节点，继续同步 binlog 日志。</p><h2 id="3、EventParser-工作流程详解"><a href="#3、EventParser-工作流程详解" class="headerlink" title="3、EventParser 工作流程详解"></a>3、EventParser 工作流程详解</h2><p>上面已经详细介绍了EventParser 的初始化过程，有助于大家对 CanalInstance 相关配置参数的理解，本节将相信介绍 EventParser 的工作流程，其实现代码入口为 EventParser 的 start 方法。本文重点将探究 MySQL binlog 日志的解析，故其实现类为：MysqlEventParser。</p><p>MysqlEventParser 的 start 方法代码如下：<br><img src="https://img-blog.csdnimg.cn/20200705155037845.png#pic_center" alt="在这里插入图片描述"><br>主要调用的是其父类的 start 方法。接下来对其进行详细解读。</p><p>AbstractEventParser#start<br><img src="https://img-blog.csdnimg.cn/20200705155122667.png#pic_center" alt="在这里插入图片描述"><br>Step1：创建环形缓存区，其主要的作用是 Canal 在解析 binlog 日志后，会尽量尝试将一个数据库事务所产生的全部变更日志（一个事务所有变更数据）当成一个整体提交给 EventSink 组件，从而 Canal 的消费方能一次将一个事务的数据全部同步，数据的完整性得到了保证。</p><blockquote><p>温馨提示：关于环形缓存区的具体实现细节将在下文详细介绍，这里先简单说一下 Canal 目前无法百分之百保证一个事务的数据就一定是一次消费，如果一个事务产生的变更日志超过了环形缓存区的容量，则会被强制提交消费，一个事务的数据会被分开消费，默认环形缓存区的长度为 1024.</p></blockquote><p>AbstractEventParser#start<br><img src="https://img-blog.csdnimg.cn/20200705155210317.png#pic_center" alt="在这里插入图片描述"><br>Step2：构建一个 binlog 解析器，该方法在 AbstractEventParser 中为一个抽象方法，具体的实现在其子类中，其代码截图如下：AbstractMysqlEventParser，在 MySQL binlog 解析的实现类为 LogEventConvert，所处的模块为 parse，该部分是整个 Canal EventParser 的核心，将在后续文章中单独详细介绍。<br><img src="https://img-blog.csdnimg.cn/20200705155320470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>AbstractEventParser#start<br><img src="https://img-blog.csdnimg.cn/20200705155756282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step3：启动一个独立的线程来负责 binlog 的解析，其线程包含了 Canal Instance 的 destination、address 等信息，方便利用 jstack 去诊断 binlog 解析相关问题。接下来就是解读该线程的 run 方法，从而探究 binlog 的解析流程。</p><p>AbstractEventParser#start<br><img src="https://img-blog.csdnimg.cn/20200705155856428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step31：首先创建一条到需要解析 binlog 日志的服务器，例如需要同步 192.168.1.166:3306 这个数据库实例的 binlog 日志，那 Canal 首先会使用拥有该库复制权限的账号去创建一条TCP连接，本文并不会详细去介绍这里的实现细节，这里代表一个领域，即需要知晓 MySQL 通讯协议，通过TCP与MySQL建立连接，并按照 MySQL 通讯协议发送命令，例如 select、dump 等请求，这个后续在学完 Canal 等核心组件后，可能会深入学习该部分的内容，这里我重点点出其实现的几个关键要点：</p><ul><li>首先创建一条TCP连接，连接到 MySQL 服务器，Canal 提供了 BIO 与 Netty 两种实现方式。</li><li>TCP 三次握手后成功建立TCP连接后，需要与 MySQL  进行握手，完成协议约定，客户端登录校验等，例如握手实现代码见：MysqlConnector negotiate。</li><li>一言以蔽之，MySqlConnection 的职责就是实现一个 MySQL 客户端。其效果等同于实现我们常用的 SQL 连接客户端，关于这方面的编程其实不难，如果大家有志成为一名数据库中间件方面的技术人员，只需按照 MySQL 官方文档中有关通讯协议即可。</li></ul><p>AbstractEventParser#start<br><img src="https://img-blog.csdnimg.cn/20200705160027515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step32：发送心跳包，这里的关键实现点如下：</p><ul><li>利用 Timer 实现定时调度，心跳包发送间隔通过 detectingIntervalInSeconds 指定。</li><li>心跳包主要是构建一个 CanalEntry.Entry,其类型为EntryType.HEARTBEAT。<br>心跳包并不是发送给远端 MySQL 服务器，而是将 Entry 下发到 EventSink 组件。</li><li>该心跳包的用意合作，在这里先留一个伏笔，后续文章会依依揭晓。</li></ul><p>AbstractEventParser#start<br><img src="https://img-blog.csdnimg.cn/20200705160316604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step33：执行发送 dump 命令正式从 MySQL 服务器接收 binlog 日志之前的准备工作，具体准备工作如下：</p><ul><li>首先再创建一条专属数据库连接，主要用于查找 MySQL 的一些配置信息，统称元数据。</li><li>向 MySQL 服务器发送 show variables like ‘binlog_format‘ 语句查询服务端配置的 binlog 格式，MySQL 支持 STATEMENT、ROW、MIXED 三种模式。</li><li>向 MySQL 服务起发送 show variables like ‘binlog_row_image’ 语句查询服务器断配置的 binlog_row_image。</li></ul><p>扩展阅读：binlog_format 我相信大家都不陌生，对 binlog_row_image 见过的估计比较少，那 binlog_row_image 有何作用呢？</p><p>binlog_row_image 主要是在 binlog_format 为 ROW 模式下，控制记录 binlog 事件的方式，binlog 的作用是记录数据的变化，例如 update 请求，需要记录一行记录变化之前的数据以及变化后的数据，在 binlog event 分别用 before 、after 记录变化前后的数据，但有一个问题，是只发生变化的字段的前后值呢，还是记录一行中所有字段修改前后的值呢？故引入了 binlog_row_image，该值支持如下选项：</p><ul><li>full：在 before 与 after 中记录所有字段的值，针对每一个字段，使用 update 来表示该字段是否发生变化，该选项为默认值。</li><li>minimal：在 before 与 after 中只记录发生变化的字段，并且包含能够唯一识一行数据的值，例如主键。</li><li>noblob：在 before 与 after 中记录所有的列值，但 BLOB 与 TEXT 类型的字段列除外（如未更改）。</li></ul><p>AbstractEventParser#start<br><img src="https://img-blog.csdnimg.cn/20200705160549515.png#pic_center" alt="在这里插入图片描述"><br>Step34：向 MySQL 服务端发送 show variables like ‘server_id’ 语句，查询服务端配置的 serverId。</p><p>AbstractEventParser#start<br><img src="https://img-blog.csdnimg.cn/20200705160640818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step35：通过日志位点管理器获取需要同步的位点，后续会详细展开。</p><p>AbstractEventParser#start<br><img src="https://img-blog.csdnimg.cn/20200705160732298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step36：通过向 MySQL 发送 dump 请求，从服务器接收 binlog 日志，并进行处理，为了提高性能，Canal 支持该过程进行并行化处理，通过 parallel 属性设置是否支持并发，从而引入 disruptor 高性能并发框架，详情后在后续文章中详细解读。</p><p>AbstractEventParser#start<br><img src="https://img-blog.csdnimg.cn/20200705160817485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step37：通过接收到 MySQL 服务端返回的日志并解析为 Canal.Entry 对象，并传输到 EventSink 组件。</p><p>上述过程反复执行，持续完成 binlog 日志的解析，实现数据的同步。</p><p>4、总结<br>本文首先结合官方文档了解了 EventParser，但 Canal 的官方手册并不特别详细，故需要我们通过源码去反推 canal instance 中关于 EventParser 有哪些参数，并且这些参数有何意义，是如何工作的。</p><p>众所周知，EventParser 的主要职责就是与 MySQL 服务器“打交道”，将自己伪装成 MySQL 服务器的一个从节点，从服务器端接收 binlog 日志，并将二进制流解码成 Canal.Entry，看似简单，但实现起来还是比较困难的，下面这些方面是后续值得我们研究探讨的点：</p><ol><li>环形缓存区的使用与技巧。</li><li>实现 MySQL 通讯协议，向 MySQL 发送相关SQL语句并解析返回结果\，具体由 MysqlConnection 对象实现。</li><li>日志解析位点管理机制。</li><li>基于GTID、日志位点偏移量两种方式定位 binlog 日志方式。</li><li>dump 命令的发送、高性能设计（ disruptor 框架的引入）</li></ol><p>本文由于篇幅的问题，对上述知识点只是点到为止，后续会按需要进行深入探讨。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将从三个方面深度剖析 EventParser 组件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从官方文档看 EventParser 的设计思想&lt;/li&gt;
&lt;li&gt;从 EventParser 初始化了解内部的是可配置项&lt;/li&gt;
&lt;li&gt;从 EventParser 的启动窥探其工作实现原理&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;温馨提示：本篇篇幅较长，如果耐心阅读一定会有不错的收获，为了提高阅读体验，本文所有源码都是通过截图方式，大家可以重点阅读对应的文字说明，并在文末进行了总结。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1、官方文档看-EventParser&quot;&gt;&lt;a href=&quot;#1、官方文档看-EventParser&quot; class=&quot;headerlink&quot; title=&quot;1、官方文档看 EventParser&quot;&gt;&lt;/a&gt;1、官方文档看 EventParser&lt;/h2&gt;&lt;p&gt;首先我们先从官方文档来看 EventParser 的整体设计，其架构设计图如下所示：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200705153423275.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;上述图罗列出了 EventParser 的整体工作流程图，其关键步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从 Log Position 管理器中获取上一次解析的日志位点。&lt;/li&gt;
&lt;li&gt;向 Mysql Master 节点发送 BINLOG_DUMP 请求。&lt;/li&gt;
&lt;li&gt;Mysql Master 节点从 Slave 端传入的日志位点开始向从节点推送 binlog 日志。&lt;/li&gt;
&lt;li&gt;Slave 接收 binlog 日志，调用 BinlogParser 解析 binlog日志。&lt;/li&gt;
&lt;li&gt;将解析后的结构化数据传入到 EventSink 组件。&lt;/li&gt;
&lt;li&gt;定时记录解析 binlog 的日志，以便重启后继续进行增量订阅。&lt;/li&gt;
&lt;li&gt;上图中还罗列一个HA 特性，即需要同步的 Master 如果宕机，可以从它的其他从节点继续同步 binlog 日志，避免单点故障。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;官方文档有助于理解 EventParser 组件的实现原理，但关于如何使用 EventParser 的篇幅较少，故接下来将从源码的角度来反推 EventParser 的特性以及详细的工作实现原理，以便指导我们如何更好的使用 EventParser。&lt;/p&gt;</summary>
    
    
    
    <category term="canal" scheme="http://example.com/categories/canal/"/>
    
    
    <category term="canal" scheme="http://example.com/tags/canal/"/>
    
    <category term="数据异构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BC%82%E6%9E%84/"/>
    
    <category term="EventParser" scheme="http://example.com/tags/EventParser/"/>
    
  </entry>
  
  <entry>
    <title>数据异构之 Canal 初探（技巧篇）</title>
    <link href="http://example.com/posts/4d11b991.html"/>
    <id>http://example.com/posts/4d11b991.html</id>
    <published>2020-12-12T13:55:01.000Z</published>
    <updated>2020-12-12T15:44:36.432Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p>源码分析 Canal 系列开始了，一个全新的系列，即能探讨 canal 本身的实现原理，也是笔者源码阅读技巧的展示。</p></blockquote><h2 id="1、应用场景"><a href="#1、应用场景" class="headerlink" title="1、应用场景"></a>1、应用场景</h2><p>提到 Canal，大家应该都能想到这是一个用于解析 MySQL binlog 日志的工具，并将 MySQL 数据库中数据同步到其他存储介质中，例如 Elasticsearch。</p><p>即 Canal 一个非常常用的使用场景：数据异构，一种更高级别的数据读写分离架构设计方法。</p><p>随着业务不断的发展，企业发展到一定阶段，发现单体的关系型数据库已无法支撑业务高速发展带来数据不断累积的压力，从而会诞生出一种设计架构：分库分表。分库分表对缓解单库数据库压力确实是一种非常好的解决方案，但又衍生出另外一种困境，关联查询不友好，甚至跨库JOIN就更加如此。</p><p>举例说明如下： 例如一个订单系统，通常有两类用户需要去查询订单，一类是顾客，一类是商家，在对数据库进行分库分表时，如果以顾客(buy_id)进行分库的话，同一个商家的订单数据会分布在不同的库中，如果以商家(shop_id)进行分库的话，同一个用户购买的所有订单数据将会分布子啊不同的库中，这样进行关联查询，就必然需要跨库进行join，其成本都会偏高。而且上面的场景只能满足一方的需求，那如何是好呢？</p><p>Canal 这个时候就闪亮登场了，在电商设计中，其实商家、顾客会被拆分成两个不同的服务，我们可以为两个不同的服务搭建不同的数据库集群，我们可以用户订单库、商家订单库进行分库，以用户订单库为主库，当用户在订单系统下单后，数据进入到用户订单库中，然后可以通过 canal 监听数据库的binlog日志，然后将数据再同步到商家订单库，而用户订单库以用户ID为维度进行分库，商家订单库以商家ID做分库，完美解决问题。</p><h2 id="2、架构设计原理"><a href="#2、架构设计原理" class="headerlink" title="2、架构设计原理"></a>2、架构设计原理</h2><p>在了解到 Canal 的基本使用场景后，我们通过 canal 官方文档，去探究一下其核心架构设计理念，以此打开进入 Canal 的神秘世界中。</p><a id="more"></a><p>首先我们简单看一下 MySQL 的主从同步原理：<br><img src="https://img-blog.csdnimg.cn/20200614170111529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从上面的图中可以看成主从复制主要分成三个步骤：</p><ul><li><p>master将改变记录到二进制日志(binary log ) 中（ 这些记录叫做二进制日志事件，binary log events，可以通过show binlog events进行查看）</p></li><li><p>slave将master的binary log events拷贝到它的中继日志(relay log)</p></li><li><p>slave重做中继日志中的事件，将改变反映它自己的数据。</p></li></ul><p>基于 MySQL 这种数据同步机制，那 Canal 的设计目标主要就是实现数据的同步，即数据的复制，从上面的图自然而然的想到了如下的设计：<br><img src="https://img-blog.csdnimg.cn/20200614170239924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>原理相对比较简单：</p><ul><li><p>canal 模拟 mysql slave 的交互协议，伪装自己为 mysql slave，向 mysql master 发送 dump 协议</p></li><li><p>mysql master 收到 dump 请求，开始推送 binary log 给 slave (canal)</p></li><li><p>canal解析 binary log 对象(原始为byte流)</p></li></ul><p>接下来我们来看一下 Canale 的整体组成部分：<br><img src="https://img-blog.csdnimg.cn/20200614170338258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>说明：</p><ul><li><p>server代表一个canal运行实例，对应于一个jvm</p></li><li><p>instance对应于一个数据队列 （1个server对应1..n个instance)</p></li></ul><p>instance模块：</p><ul><li><p>eventParser (数据源接入，模拟slave协议和master进行交互，协议解析)</p></li><li><p>eventSink (Parser和Store链接器，进行数据过滤，加工，分发的工作)</p></li><li><p>eventStore (数据存储)</p></li><li><p>metaManager (增量订阅&amp;消费信息管理器)</p></li></ul><blockquote><p>这些组件我暂时不打算深入去研究，因为在目前这个阶段我自己也不清楚，但这个是我后续需要学习研究的重点。</p></blockquote><h2 id="3、在-IntelliJ-IDEA-中运行-Canal-Demo"><a href="#3、在-IntelliJ-IDEA-中运行-Canal-Demo" class="headerlink" title="3、在 IntelliJ IDEA 中运行 Canal Demo"></a>3、在 IntelliJ IDEA 中运行 Canal Demo</h2><p>在 Linux 环境中安装 canal 比较简单，大家可以安装官方手册一步一步操作即可，在这里我就不重复介绍，本节主要的目的是希望在开发工具中运行 Canal 的 Demo，以便后续在研究源码的过程中遇到难题时可以进行 Debug。</p><blockquote><p>温馨提示：大家在学习过程中，可以根据官方文档先安装一遍 canal，对理解 Canal 的核心组件有着非常重要的帮助。</p></blockquote><p>首先先从 canal 源码中寻找官方提供的 Demo，其示例代码在 example 包中，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200614170556995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>但是另外稍微遗憾的是 canal 提供提供的示例代码中只包含了 client 端相关的代码，并没有包含服务端(server)，故我们将目光放到其单元测试中，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200614170614672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>接下来我根据官方的一些提示，结合自己的理解，编写出如下测试代码，在 IDEA 开发工具中实现运行 Canal 相关的 Demo。下面的代码已通过测试，可直接使用。</p><p>1、Canal Server Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.otter.canal.server;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.instance.core.CanalInstance;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.instance.core.CanalInstanceGenerator;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.instance.manager.CanalInstanceWithManager;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.instance.manager.model.Canal;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.instance.manager.model.CanalParameter;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.server.embedded.CanalServerWithEmbedded;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.server.netty.CanalServerWithNetty;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanalServerTestMain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZK_CLUSTER_ADDRESS      = <span class="string">&quot;127.0.0.1:2181&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String DESTINATION   = <span class="string">&quot;example&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String DETECTING_SQL = <span class="string">&quot;select 1&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String MYSQL_ADDRESS = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String USERNAME      = <span class="string">&quot;canal&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD      = <span class="string">&quot;canal&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String FILTER        = <span class="string">&quot;.\\*\\\\\\\\..\\*&quot;</span>;</span><br><span class="line">    <span class="comment">/** 默认 500s 后关闭 */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RUN_TIME = <span class="number">120</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ByteBuffer header        = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">private</span> CanalServerWithNetty nettyServer;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CanalServerTestMain test = <span class="keyword">new</span> CanalServerTestMain();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.setUp();</span><br><span class="line">            System.out.println(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(RUN_TIME);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ee) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            test.tearDown();</span><br><span class="line">            System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CanalServerWithEmbedded embeddedServer = <span class="keyword">new</span> CanalServerWithEmbedded();</span><br><span class="line">        embeddedServer.setCanalInstanceGenerator(<span class="keyword">new</span> CanalInstanceGenerator() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> CanalInstance <span class="title">generate</span><span class="params">(String destination)</span> </span>&#123;</span><br><span class="line">                Canal canal = buildCanal();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> CanalInstanceWithManager(canal, FILTER);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        nettyServer = CanalServerWithNetty.instance();</span><br><span class="line">        nettyServer.setEmbeddedServer(embeddedServer);</span><br><span class="line">        nettyServer.setPort(<span class="number">11111</span>);</span><br><span class="line">        nettyServer.start();</span><br><span class="line">        <span class="comment">// 启动 instance</span></span><br><span class="line">        embeddedServer.start(<span class="string">&quot;example&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nettyServer.stop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Canal <span class="title">buildCanal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Canal canal = <span class="keyword">new</span> Canal();</span><br><span class="line">        canal.setId(<span class="number">1L</span>);</span><br><span class="line">        canal.setName(DESTINATION);</span><br><span class="line">        canal.setDesc(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        CanalParameter parameter = <span class="keyword">new</span> CanalParameter();</span><br><span class="line">        <span class="comment">//parameter.setZkClusters(Arrays.asList(ZK_CLUSTER_ADDRESS));</span></span><br><span class="line">        parameter.setMetaMode(CanalParameter.MetaMode.MEMORY);</span><br><span class="line">        parameter.setHaMode(CanalParameter.HAMode.HEARTBEAT);</span><br><span class="line">        parameter.setIndexMode(CanalParameter.IndexMode.MEMORY);</span><br><span class="line">        parameter.setStorageMode(CanalParameter.StorageMode.MEMORY);</span><br><span class="line">        parameter.setMemoryStorageBufferSize(<span class="number">32</span> * <span class="number">1024</span>);</span><br><span class="line">        parameter.setSourcingType(CanalParameter.SourcingType.MYSQL);</span><br><span class="line">        parameter.setDbAddresses(Arrays.asList(<span class="keyword">new</span> InetSocketAddress(MYSQL_ADDRESS, <span class="number">3306</span>),</span><br><span class="line">                <span class="keyword">new</span> InetSocketAddress(MYSQL_ADDRESS, <span class="number">3306</span>)));</span><br><span class="line">        parameter.setDbUsername(USERNAME);</span><br><span class="line">        parameter.setDbPassword(PASSWORD);</span><br><span class="line">        parameter.setSlaveId(<span class="number">1234L</span>);</span><br><span class="line">        parameter.setDefaultConnectionTimeoutInSeconds(<span class="number">30</span>);</span><br><span class="line">        parameter.setConnectionCharset(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        parameter.setConnectionCharsetNumber((<span class="keyword">byte</span>) <span class="number">33</span>);</span><br><span class="line">        parameter.setReceiveBufferSize(<span class="number">8</span> * <span class="number">1024</span>);</span><br><span class="line">        parameter.setSendBufferSize(<span class="number">8</span> * <span class="number">1024</span>);</span><br><span class="line">        parameter.setDetectingEnable(<span class="keyword">false</span>);</span><br><span class="line">        parameter.setDetectingIntervalInSeconds(<span class="number">10</span>);</span><br><span class="line">        parameter.setDetectingRetryTimes(<span class="number">3</span>);</span><br><span class="line">        parameter.setDetectingSQL(DETECTING_SQL);</span><br><span class="line">        canal.setCanalParameter(parameter);</span><br><span class="line">        <span class="keyword">return</span> canal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、Canal Client Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.otter.canal.example;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnectors;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnector;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.common.utils.AddressUtils;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.Message;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.Column;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.EventType;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCanalClientExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建链接</span></span><br><span class="line">        CanalConnector connector = CanalConnectors.newSingleConnector(<span class="keyword">new</span> InetSocketAddress(AddressUtils.getHostIp(),</span><br><span class="line">                <span class="number">11111</span>), <span class="string">&quot;example&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> batchSize = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">int</span> emptyCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connector.connect();</span><br><span class="line">            connector.subscribe(<span class="string">&quot;.*\\..*&quot;</span>);</span><br><span class="line">            connector.rollback();</span><br><span class="line">            <span class="keyword">int</span> totalEmptyCount = <span class="number">3000</span>;</span><br><span class="line">            <span class="keyword">while</span> (emptyCount &lt; totalEmptyCount) &#123;</span><br><span class="line">                Message message = connector.getWithoutAck(batchSize); <span class="comment">// 获取指定数量的数据</span></span><br><span class="line">                <span class="keyword">long</span> batchId = message.getId();</span><br><span class="line">                <span class="keyword">int</span> size = message.getEntries().size();</span><br><span class="line">                <span class="keyword">if</span> (batchId == -<span class="number">1</span> || size == <span class="number">0</span>) &#123;</span><br><span class="line">                    emptyCount++;</span><br><span class="line">                    System.out.println(<span class="string">&quot;empty count : &quot;</span> + emptyCount);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    emptyCount = <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">// System.out.printf(&quot;message[batchId=%s,size=%s] \n&quot;, batchId, size);</span></span><br><span class="line">                    printEntry(message.getEntries());</span><br><span class="line">                &#125;</span><br><span class="line">                connector.ack(batchId); <span class="comment">// 提交确认</span></span><br><span class="line">                <span class="comment">// connector.rollback(batchId); // 处理失败, 回滚数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;empty too many times, exit&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            connector.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEntry</span><span class="params">(List&lt;CanalEntry.Entry&gt; entrys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (CanalEntry.Entry entry : entrys) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getEntryType() == CanalEntry.EntryType.TRANSACTIONBEGIN || entry.getEntryType() == CanalEntry.EntryType.TRANSACTIONEND) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            CanalEntry.RowChange rowChage = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rowChage = CanalEntry.RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;ERROR ## parser of eromanga-event has an error , data:&quot;</span> + entry.toString(),</span><br><span class="line">                        e);</span><br><span class="line">            &#125;</span><br><span class="line">            CanalEntry.EventType eventType = rowChage.getEventType();</span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;================&gt; binlog[%s:%s] , name[%s,%s] , eventType : %s&quot;</span>,</span><br><span class="line">                    entry.getHeader().getLogfileName(), entry.getHeader().getLogfileOffset(),</span><br><span class="line">                    entry.getHeader().getSchemaName(), entry.getHeader().getTableName(),</span><br><span class="line">                    eventType));</span><br><span class="line">            <span class="keyword">for</span> (CanalEntry.RowData rowData : rowChage.getRowDatasList()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (eventType == CanalEntry.EventType.DELETE) &#123;</span><br><span class="line">                    printColumn(rowData.getBeforeColumnsList());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eventType == EventType.INSERT) &#123;</span><br><span class="line">                    printColumn(rowData.getAfterColumnsList());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-------&gt; before&quot;</span>);</span><br><span class="line">                    printColumn(rowData.getBeforeColumnsList());</span><br><span class="line">                    System.out.println(<span class="string">&quot;-------&gt; after&quot;</span>);</span><br><span class="line">                    printColumn(rowData.getAfterColumnsList());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printColumn</span><span class="params">(List&lt;Column&gt; columns)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Column column : columns) &#123;</span><br><span class="line">            System.out.println(column.getName() + <span class="string">&quot; : &quot;</span> + column.getValue() + <span class="string">&quot;    update=&quot;</span> + column.getUpdated());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 client 的效果如下图所示：<br><img src="https://img-blog.csdnimg.cn/2020061417091623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在数据库中变更一条数据，以便产生新的binlog日志，其输出结果如下：<br><img src="https://img-blog.csdnimg.cn/20200614170932906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>能在 IDEA 中搭建并运行 Demo，是我们踏入 canal 的第一步，后续将根据官方文档中的内容为提纲，尝试逐步解开 canal 的实现原理，以便更好的指导实践。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;源码分析 Canal 系列开始了，一个全新的系列，即能探讨 canal 本身的实现原理，也是笔者源码阅读技巧的展示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1、应用场景&quot;&gt;&lt;a href=&quot;#1、应用场景&quot; class=&quot;headerlink&quot; title=&quot;1、应用场景&quot;&gt;&lt;/a&gt;1、应用场景&lt;/h2&gt;&lt;p&gt;提到 Canal，大家应该都能想到这是一个用于解析 MySQL binlog 日志的工具，并将 MySQL 数据库中数据同步到其他存储介质中，例如 Elasticsearch。&lt;/p&gt;
&lt;p&gt;即 Canal 一个非常常用的使用场景：数据异构，一种更高级别的数据读写分离架构设计方法。&lt;/p&gt;
&lt;p&gt;随着业务不断的发展，企业发展到一定阶段，发现单体的关系型数据库已无法支撑业务高速发展带来数据不断累积的压力，从而会诞生出一种设计架构：分库分表。分库分表对缓解单库数据库压力确实是一种非常好的解决方案，但又衍生出另外一种困境，关联查询不友好，甚至跨库JOIN就更加如此。&lt;/p&gt;
&lt;p&gt;举例说明如下： 例如一个订单系统，通常有两类用户需要去查询订单，一类是顾客，一类是商家，在对数据库进行分库分表时，如果以顾客(buy_id)进行分库的话，同一个商家的订单数据会分布在不同的库中，如果以商家(shop_id)进行分库的话，同一个用户购买的所有订单数据将会分布子啊不同的库中，这样进行关联查询，就必然需要跨库进行join，其成本都会偏高。而且上面的场景只能满足一方的需求，那如何是好呢？&lt;/p&gt;
&lt;p&gt;Canal 这个时候就闪亮登场了，在电商设计中，其实商家、顾客会被拆分成两个不同的服务，我们可以为两个不同的服务搭建不同的数据库集群，我们可以用户订单库、商家订单库进行分库，以用户订单库为主库，当用户在订单系统下单后，数据进入到用户订单库中，然后可以通过 canal 监听数据库的binlog日志，然后将数据再同步到商家订单库，而用户订单库以用户ID为维度进行分库，商家订单库以商家ID做分库，完美解决问题。&lt;/p&gt;
&lt;h2 id=&quot;2、架构设计原理&quot;&gt;&lt;a href=&quot;#2、架构设计原理&quot; class=&quot;headerlink&quot; title=&quot;2、架构设计原理&quot;&gt;&lt;/a&gt;2、架构设计原理&lt;/h2&gt;&lt;p&gt;在了解到 Canal 的基本使用场景后，我们通过 canal 官方文档，去探究一下其核心架构设计理念，以此打开进入 Canal 的神秘世界中。&lt;/p&gt;</summary>
    
    
    
    <category term="canal" scheme="http://example.com/categories/canal/"/>
    
    
    <category term="canal" scheme="http://example.com/tags/canal/"/>
    
    <category term="数据异构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BC%82%E6%9E%84/"/>
    
    <category term="binlog" scheme="http://example.com/tags/binlog/"/>
    
  </entry>
  
  <entry>
    <title>一文详解 Canal Instance 设计理念与定制开发思路</title>
    <link href="http://example.com/posts/c9e417fa.html"/>
    <id>http://example.com/posts/c9e417fa.html</id>
    <published>2020-12-12T13:53:01.000Z</published>
    <updated>2020-12-12T15:44:36.432Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>从 Canal 系列的第一篇文章我们基本能了解到，Instance 是 Canal 数据同步的核心，在一个 Canal 实例中只有启动 Instace，才能实现数据的同步，那 Instance 到底是“何许人也”，本文将以源码为手段，试图揭开 Instance 的神秘面纱。</p><h2 id="1、Canal-Instance-类继承体系"><a href="#1、Canal-Instance-类继承体系" class="headerlink" title="1、Canal Instance 类继承体系"></a>1、Canal Instance 类继承体系</h2><p><img src="https://img-blog.csdnimg.cn/20200621210310965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>重要的类说明如下：</p><ul><li>CanalInstanceCanal Instance 接口，即定义 Instance 的基本特征，主要定义如下方法：<ul><li>String getDestination()<br>实例的目的地名称，在 Canal 中表示一个源实例名称，对应一个 MySQL 实例信息，例如 192.168.1.3:3306，这里为该实例取一个名称。</li><li>CanalEventParser getEventParser()<br>事件解析器，即 Binlog 解析器，负责解析 binlog 日志。</li><li>CanalEventSink getEventSink()<br>EventParse 与 EventStore 的连接器，主要处理数据的过滤、加工与分发，即提供了对 binlog 原始数据进行“加工”的切入点，EventStore 存储的就是经 EventSink处理过的数据。</li><li>CanalEventStore getEventStore()<br>事件存储器，即 Canal Instance 作为 MySQL 的 “Slave” 服务器，需要将同步过来的数据进行存储，然后被 Canal 的客户端最终会从 EventStore 中获取数据，目前 Canal 只实现了基于内存的 EventStore，那 Canal 是如何避免内存泄露，并且如何避免数据丢失的，这将是后续我们需要研究的重点。</li><li>CanalMetaManager getMetaManager()<br>Canal 元数据管理器，例如记录 消费端消费进度，即从 Canal EventStore 中处理数据的情况。</li><li><pre><code>CanalAlarmHandler getAlarmHandler()</code></pre>告警服务。</li></ul></li><li>AbstractCanalInstance<br>CanalInstance的抽象实现类。</li><li>CanalInstanceWithManager<br>基于手动编程式的 CanaInstance，主要通过API的方式手动生成 CanalInstance 实例。 可以类比 Spring 基于编程API 的事务管理器。</li><li>CanalInstanceWithSpring<br>基于 Spring 方式构建 CanaInstance。</li><li>CanalInstanceGenerator<br>Canal Instance 的构造类体系，即通过该类提供的方法创建 CanalInstance 实例，提供基于 Spring、手动管理等方式。</li></ul><a id="more"></a><h2 id="2、CanalInstance-四大核心组件"><a href="#2、CanalInstance-四大核心组件" class="headerlink" title="2、CanalInstance 四大核心组件"></a>2、CanalInstance 四大核心组件</h2><p>从类层次了解 Canal Instance 显得不那么直观，接下来先抛出一个使用场景，再结合架构图进一步加深对 Canal Instance 的理解。</p><p>例如某公司的订单系统使用了分库分表，数据库的分别部署在 192.168.1.166:3306，192.168.1.168:3306 两个数据库，并且每一个数据库上会创建多个 schema，例如 order_db、user_db，那现在为了对订单提供多维度的查询，统计等功能，架构组因此提出通过订阅数据库 binlog 日志，将两个订单库中的订单数据，即将 order_db 中的数据同步到 elasticsearch，而 Canal 的设计初衷就是为了解决上述问题，故我们可以边思考这个场景，来反推一下 Canal Instance 的设计理念。</p><p>Canal Instance 的架构图如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200621210705154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Canal 中数据的同步是由 CanalInstance 组件负责，一个 Canal Server 实例中可以创建多个 CanalInstance 实例。</p><p>每一个 CanalInstance 可以看成是对应一个 MySQL 实例，即案例中需要同步两个数据库实例，故最终需要创建两个 CanalInstance。其实也不难理解，因为 MySQL 的 binlog 就是以实例为维度进行存储的。Canal Instance 包含了 4个 核心组件 ：EventParse、EventSink、EventStore、CanaMetaManager，在这里主要是阐明其作用，后续文章会一一详细介绍，以便更好的指导实践。</p><ul><li>EventParse 组件<br>负责解析 binlog日志，其职责就是根据 binlog 的存储格式将有效数据提取出来，这个不难理解，我们也可以通过该模块，进一步了解一下 binglog 的存储格式。</li><li>EventSink 组件<br>结合数据同步案例，在一个数据库实例上通常会创建多个 Schema，但通常并不是所有的 schema 都需要被同步，如果直接将 EventParse 解析出来的数据全部传入EventStore 组件，将对 EventStore 带来不必要的性能消耗；另外本例中使用了分库分表，需要将多个库的数据同步到单一源，可能需要涉及到合并、归并等策略。以上等等等需求就是 EventSink 需要解决的问题域。</li><li>EventStore 组件<br>用来存储经 canal 转换的数据，被 Canal Client 进行消费的数据，目前 Canal 只提供了基于内存的存储实现。大家不妨先思考一下，采用基于内存的存储模式，如何避免内存溢出，其具体实现将在后续文章中详细剖析。</li><li>CanalMetaManager 组件<br>元数据存储管理器。在 Canal 中最基本的元数据至少应该包含 EventParse 组件解析的位点与消费端的消费位点。Canal Server 重启后要能从上一次未同步位置开始同步，否则会丢失数据。在将数据库数据同步到 es 的示例中，所谓的 canal 客户端就是从 Canal Server 即 EventStore 中获取数据，并将数据写入 es 中，并上报写入进度，这些信息都是由 CanalMetaManager 组件完成。</li></ul><p>从最新的版本来看，Canal 支持直接将解析后的数据发送到MQ，故 CanalInstance 中还持有另外一个组件：CanalMQConfig，关于 MQ 的一些配置，提供了多种策略实现 shcema、table 到 MQ Topic 的自动映射管理，为 Canal 的使用者带来更多便利，这部分内容会在后续文章中单独介绍，这里先暂时不过多讨论。</p><p>经过上面的了解，我想大家对 Canal Instance 有了一个相对全面的了解了吧，接下来我们再来关注一下 CanalInstance 的构造方式，这个对后续的实践有着非常重要的影响。</p><h2 id="3、CanalInstance-构造方式"><a href="#3、CanalInstance-构造方式" class="headerlink" title="3、CanalInstance 构造方式"></a>3、CanalInstance 构造方式</h2><p>Canal 中提供了两种方式对 Instance 进行初始化：Spring 与 手动编程方式。 CanalInstance 最最核心的就是上述提到的4个组件，即 CanalInstanceWithManager 类的具体职责就是管理上述核心组件，即提供对上述组件的加载、启动、停止，并协调，从其名字就能看出来，从其构造函数同样能得知：<br><img src="https://img-blog.csdnimg.cn/20200621210843366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>编程方式创建 Canal Instance 就变得简单起来，只需设置参数，并创建 CanalInstanceWithManger 方法即可，正如示例代码中使用的那样。<br><img src="https://img-blog.csdnimg.cn/2020062121090623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>另外 Canal 提供了对 Spring 的整合，将 canal Instance 的相关核心组件纳入 Spring 的管理，其实现类为： CanalInstanceWithSpring，对应的 Spring 配置示例如下图所示：</p><blockquote><p>温馨提示：基于 Canal 二次开发的编程技巧思考如下：Canal 框架本身将 Canal Server 做成了启动脚本，可以通过自定义 Instance，即从 instance 配置文件中加载配置，然后启动 Canal Server 解析 Binlog 日志，最终按照预定的配置进行工作，例如在生产环境搭建一些 Canal 集群，统一交由运维去手动维护，如果需要数据同步，则配置相应的 instance 文件，然后进行启动就生效，其实这种模式处于 Canal 的初阶阶段，更好的方式是对 Canal 进行二次开发，通过可视化的界面，通过界面的方式定义数据同步任务，例如将指定数据库实例上的指定 Schema 的 binglog 日志同步到指定消息集群的指定 topic，并且可重推、随时停止，重启，这样 Canal 的维护者无需关注底层的细节，只需要通过页面简单配置一下即可。</p></blockquote><p>本文就先介绍到这里了，本文的目的是了解 CanalInstance 在 Canal 中所处的定位，揭开其4大核心组件的作用与引入目的，为接下来逐个学习研究打下基础。</p><blockquote><p>源码研究 Canal 学习方法提示：目前 Canal 系列虽然在持续连载，目前笔者只能尽量做到周更，如果读者朋友们也正在研究 Canal，我觉得大家在读取本文后，可以继续深入研究其四大核心组件，并带着问题去研究，例如在学习元数据管理时是如何保证数据不丢失，重启后又是如何定位位点的。如果大家想更全局的去研究 Canal，我觉得除了阅读 Canal 官方的设计手册，还可以专门去看一下 CanalParameter 这个类，Canal 支持的所有配置属性，并且都有相应的注释，关于 Canal 的所有一切，都可以从这里窥探出端倪，然后可以选择感兴趣的内容加以继续深入学习。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;从 Canal 系列的第一篇文章我们基本能了解到，Instance 是 Canal 数据同步的核心，在一个 Canal 实例中只有启动 Instace，才能实现数据的同步，那 Instance 到底是“何许人也”，本文将以源码为手段，试图揭开 Instance 的神秘面纱。&lt;/p&gt;
&lt;h2 id=&quot;1、Canal-Instance-类继承体系&quot;&gt;&lt;a href=&quot;#1、Canal-Instance-类继承体系&quot; class=&quot;headerlink&quot; title=&quot;1、Canal Instance 类继承体系&quot;&gt;&lt;/a&gt;1、Canal Instance 类继承体系&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200621210310965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;重要的类说明如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CanalInstanceCanal Instance 接口，即定义 Instance 的基本特征，主要定义如下方法：&lt;ul&gt;
&lt;li&gt;String getDestination()&lt;br&gt;实例的目的地名称，在 Canal 中表示一个源实例名称，对应一个 MySQL 实例信息，例如 192.168.1.3:3306，这里为该实例取一个名称。&lt;/li&gt;
&lt;li&gt;CanalEventParser getEventParser()&lt;br&gt;事件解析器，即 Binlog 解析器，负责解析 binlog 日志。&lt;/li&gt;
&lt;li&gt;CanalEventSink getEventSink()&lt;br&gt;EventParse 与 EventStore 的连接器，主要处理数据的过滤、加工与分发，即提供了对 binlog 原始数据进行“加工”的切入点，EventStore 存储的就是经 EventSink处理过的数据。&lt;/li&gt;
&lt;li&gt;CanalEventStore getEventStore()&lt;br&gt;事件存储器，即 Canal Instance 作为 MySQL 的 “Slave” 服务器，需要将同步过来的数据进行存储，然后被 Canal 的客户端最终会从 EventStore 中获取数据，目前 Canal 只实现了基于内存的 EventStore，那 Canal 是如何避免内存泄露，并且如何避免数据丢失的，这将是后续我们需要研究的重点。&lt;/li&gt;
&lt;li&gt;CanalMetaManager getMetaManager()&lt;br&gt;Canal 元数据管理器，例如记录 消费端消费进度，即从 Canal EventStore 中处理数据的情况。&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;CanalAlarmHandler getAlarmHandler()&lt;/code&gt;&lt;/pre&gt;
告警服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;AbstractCanalInstance&lt;br&gt;CanalInstance的抽象实现类。&lt;/li&gt;
&lt;li&gt;CanalInstanceWithManager&lt;br&gt;基于手动编程式的 CanaInstance，主要通过API的方式手动生成 CanalInstance 实例。 可以类比 Spring 基于编程API 的事务管理器。&lt;/li&gt;
&lt;li&gt;CanalInstanceWithSpring&lt;br&gt;基于 Spring 方式构建 CanaInstance。&lt;/li&gt;
&lt;li&gt;CanalInstanceGenerator&lt;br&gt;Canal Instance 的构造类体系，即通过该类提供的方法创建 CanalInstance 实例，提供基于 Spring、手动管理等方式。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="canal" scheme="http://example.com/categories/canal/"/>
    
    
    <category term="canal" scheme="http://example.com/tags/canal/"/>
    
    <category term="数据异构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BC%82%E6%9E%84/"/>
    
    <category term="CanalInstance" scheme="http://example.com/tags/CanalInstance/"/>
    
  </entry>
  
  <entry>
    <title>全链路压测必备基础组件之线程上下文管理之“三剑客”</title>
    <link href="http://example.com/posts/497923c7.html"/>
    <id>http://example.com/posts/497923c7.html</id>
    <published>2020-12-11T15:19:01.000Z</published>
    <updated>2020-12-12T01:18:16.008Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>说起本地线程变量，我相信大家首先会想到的是JDK默认提供的ThreadLocal，用来存储在整个调用链中都需要访问的数据，并且是线程安全的。由于本文的写作背景是笔者需要在公司落地全链路压测平台，一个基本并核心的功能需求是压测标记需要在整个调用链中进行传递，线程上下文环境成为解决这个问题最合适的技术。</p><blockquote><p>温馨提示：<br>本从从ThreadLocal原理入手分析，并抛出其缺点，再逐一引出InheritableThreadLocal、TransmittableThreadLocal。文章篇幅稍长，但由于循序渐进，层层递进，故精华部分在后面。</p></blockquote><h2 id="1、ThreadLocal详解"><a href="#1、ThreadLocal详解" class="headerlink" title="1、ThreadLocal详解"></a>1、ThreadLocal详解</h2><p>ThreadLocal对外提供;的API如下：</p><ul><li>public T get(）<br>从线程上下文环境中获取设置的值。</li><li>public void set(T value)<br>将值存储到线程上下文环境中，供后续使用。</li><li>public void remove()<br>清除线程本地上下文环境。</li></ul><p>上述API使用简单，关键是要理解ThreadLocal的内部存储结果。</p><h3 id="1-1-ThreadLocal存储结构"><a href="#1-1-ThreadLocal存储结构" class="headerlink" title="1.1 ThreadLocal存储结构"></a>1.1 ThreadLocal存储结构</h3><p><img src="https://img-blog.csdnimg.cn/20190720224949903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上图的几个关键点如下：</p><ul><li>数据存储位置<br>当线程调用threadLocal对象的set(Object value)方法时，数据并不是存储在ThreadLocal对象中，而是存储在Thread对象中，这也是ThreadLocal的由来，具体存储在线程对象的threadLocals属性中，其类型为ThreadLocal.ThreadLocalMap。</li><li>ThreadLocal.ThreadLocalMap，Map结构，即键值对，键为threadLocal对象，值为需要存储到线程上下文的值(threadLocal#set)方法的参数。</li></ul><a id="more"></a><h3 id="1-2-源码分析ThreadLocal"><a href="#1-2-源码分析ThreadLocal" class="headerlink" title="1.2 源码分析ThreadLocal"></a>1.2 源码分析ThreadLocal</h3><h4 id="1-2-1-源码分析get"><a href="#1-2-1-源码分析get" class="headerlink" title="1.2.1 源码分析get"></a>1.2.1 源码分析get</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();  <span class="comment">// @1</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);  <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;                                <span class="comment">// @3</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();  <span class="comment">// @4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：获取当前线程。</p><p>代码@2：获取线程的threadLocals属性，在上图中已展示其存储结构。</p><p>代码@3：如果线程对象的threadLocals属性不为空，则从该Map结构中，用threadLocal对象为键去查找值，如果能找到，则返回其value值，否则执行代码@4。</p><p>代码@4：如果线程对象的threadLocals属性为空，或未从threadLocals中找到对应的键值对，则调用该方法执行初始化。</p><p>ThreadLocal#setInitialValue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();    <span class="comment">// @1</span></span><br><span class="line">    Thread t = Thread.currentThread();    <span class="comment">// @2</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);    <span class="comment">// @3</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)                                     <span class="comment">//@4</span></span><br><span class="line">       map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       createMap(t, value);                        <span class="comment">// @5</span></span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：调用initialValue()获取默认初始化值，该方法默认返回null，子类可以重写，实现线程本地变量的初始化。</p><p>代码@2：获取当前线程。</p><p>代码@3：获取该线程对象的threadLocals属性。</p><p>代码@4：如果不为空，则将threadLocal:value存入线程对象的threadLocals属性中。</p><p>代码@5：否则初始化线程对象的threadLocals,然后将threadLocal:value键值对存入线程对象的threadLocals属性中。</p><h4 id="1-2-2-源码分析set"><a href="#1-2-2-源码分析set" class="headerlink" title="1.2.2 源码分析set"></a>1.2.2 源码分析set</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在掌握了get方法实现细节，set方法、remove其实现的逻辑基本一样，就是对线程对象的threadLocals属性进行操作(Map结构)。</p><h3 id="1-3-ThreadLocal局限性"><a href="#1-3-ThreadLocal局限性" class="headerlink" title="1.3 ThreadLocal局限性"></a>1.3 ThreadLocal局限性</h3><p>经过上面的剖析，对ThreadLocal的内部存储与set、get、remove等实现细节都已理解，但ThreadLocal无法在父子线程之间传递，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; requestIdThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer reqId = <span class="keyword">new</span> Integer(<span class="number">5</span>);</span><br><span class="line">        Service a = <span class="keyword">new</span> Service();</span><br><span class="line">        a.setRequestId(reqId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequestId</span><span class="params">(Integer requestId)</span> </span>&#123;</span><br><span class="line">        requestIdThreadLocal.set(requestId);</span><br><span class="line">        doBussiness();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBussiness</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;首先打印requestId:&quot;</span> + requestIdThreadLocal.get());</span><br><span class="line">        (<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程启动&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;在子线程中访问requestId:&quot;</span> + requestIdThreadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><img src="https://img-blog.csdnimg.cn/20190720225215561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从结果上来看，在子线程中无法访问在父线程中设置的本地线程变量，那我们该如何来解决该问题呢？</p><p>为了解决该问题，JDK引入了另外一个线程本地变量实现类InheritableThreadLocal，接下来将重点介绍InheritableThreadLocal的实现原理。</p><h2 id="2、InheritableThreadLocal"><a href="#2、InheritableThreadLocal" class="headerlink" title="2、InheritableThreadLocal"></a>2、InheritableThreadLocal</h2><p>由于ThreadLocal在父子线程交互中子线程无法访问到存储在父线程中的值，无法满足某些场景的需求，例如链路跟踪，例如如下场景：<br><img src="https://img-blog.csdnimg.cn/20190720225255699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为了解决上述问题，JDK引入了InheritableThreadLocal，即子线程可以访问父线程中的线程本地变量，更严谨的说法是子线程可以访问在创建子线程时父线程当时的本地线程变量，因为其实现原理就是在创建子线程将父线程当前存在的本地线程变量拷贝到子线程的本地线程变量中。</p><h3 id="2-1-类图"><a href="#2-1-类图" class="headerlink" title="2.1 类图"></a>2.1 类图</h3><p><img src="https://img-blog.csdnimg.cn/20190720225324764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从类的继承层次来看，InheritableThreadLocal只是在ThreadLocal的get、set、remove流程中，重写了getMap、createMap方法，整体流程与ThreadLocal保持一致，故我们初步来看一下InheritableThreadLocal是如何重写上述这两个方法的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码得知，ThreadLocal操作的是Thread对象的threadLocals属性，而InheritableThreadLocal操作的是Thread对象的inheritableThreadLocals属性。</p><blockquote><p>温馨提示：createMap被执行的条件是调用InheritableThreadLocal#get、set时如果线程的inheritableThreadLocals属性为空时才会被调用。</p></blockquote><p>那问题来了，InheritableThreadLocal是如何继承自父对象的线程本地变量的呢？</p><h3 id="2-2-线程上下文环境如何从父线程传递到子线程"><a href="#2-2-线程上下文环境如何从父线程传递到子线程" class="headerlink" title="2.2 线程上下文环境如何从父线程传递到子线程"></a>2.2 线程上下文环境如何从父线程传递到子线程</h3><p>这部分的代码入口为：Thread#init方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread parent = currentThread();                <span class="comment">// @1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)    <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line"><span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line"><span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set thread ID */</span></span><br><span class="line">tid = nextThreadID();</span><br></pre></td></tr></table></figure><p>子线程是通过在父线程中通过调用new Thread()方法来创建子线程，Thread#init方法就是在Thread的构造方法中被调用。</p><p>代码@1：获取当前线程对象，即待创建的线程的父线程。</p><p>代码@2：如果父线程的inheritableThreadLocals不为空并且inheritThreadLocals为true(该值默认为true)，则使用父线程的inherit本地变量的值来创建子线程的inheritableThreadLocals结构，即将父线程中的本地变量复制到子线程中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    Entry[] parentTable = parentMap.table;</span><br><span class="line">    <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">    setThreshold(len);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = parentTable[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object value = key.childValue(e.value);</span><br><span class="line">                Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                </span><br><span class="line">table[h] = c;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码就不一一分析，类似于Map的复制，只不过其在Hash冲突时，不是使用链表结构，而是直接在数组中找下一个为null的槽位。</p><blockquote><p>温馨提示：子线程默认拷贝父线程的方式是浅拷贝，如果需要使用深拷贝，需要使用自定义ThreadLocal，继承InheritableThreadLocal并重写childValue方法。</p></blockquote><h3 id="2-3-验证InheritableThreadLocal的特性"><a href="#2-3-验证InheritableThreadLocal的特性" class="headerlink" title="2.3 验证InheritableThreadLocal的特性"></a>2.3 验证InheritableThreadLocal的特性</h3><p>验证代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InheritableThreadLocal&lt;Integer&gt; requestIdThreadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer reqId = <span class="keyword">new</span> Integer(<span class="number">5</span>);</span><br><span class="line">        Service a = <span class="keyword">new</span> Service();</span><br><span class="line">        a.setRequestId(reqId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequestId</span><span class="params">(Integer requestId)</span> </span>&#123;</span><br><span class="line">        requestIdThreadLocal.set(requestId);</span><br><span class="line">        doBussiness();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBussiness</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;首先打印requestId:&quot;</span> + requestIdThreadLocal.get());</span><br><span class="line">        (<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程启动&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;在子线程中访问requestId:&quot;</span> + requestIdThreadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：<br><img src="https://img-blog.csdnimg.cn/20190720225632413.png" alt="在这里插入图片描述"><br>符合预期，在子线程中如愿访问到了在主线程中设置的本地环境变量。</p><h3 id="2-4-InheritableThreadLocal局限性"><a href="#2-4-InheritableThreadLocal局限性" class="headerlink" title="2.4 InheritableThreadLocal局限性"></a>2.4 InheritableThreadLocal局限性</h3><p>InheritableThreadLocal支持子线程访问在父线程的核心思想是在创建线程的时候将父线程中的本地变量值复制到子线程，即复制的时机为创建子线程时。但我们提到并发、多线程就理不开线程池的使用，因为线程池能够复用线程，减少线程的频繁创建与销毁，如果使用InheritableThreadLocal，那么线程池中的线程拷贝的数据来自于第一个提交任务的外部线程，即后面的外部线程向线程池中提交任务时，子线程访问的本地变量都来源于第一个外部线程，造成线程本地变量混乱，验证代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟tomcat线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService tomcatExecutors = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务线程池，默认Control中异步任务执行线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService businessExecutors = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程上下文环境，模拟在Control这一层，设置环境变量，然后在这里提交一个异步任务，模拟在子线程中，是否可以访问到刚设置的环境变量值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InheritableThreadLocal&lt;Integer&gt; requestIdThreadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ ) &#123;  <span class="comment">// 模式10个请求，每个请求执行ControlThread的逻辑，其具体实现就是，先输出父线程的名称，</span></span><br><span class="line">                                                  <span class="comment">//  然后设置本地环境变量，并将父线程名称传入到子线程中，在子线程中尝试获取在父线程中的设置的环境变量</span></span><br><span class="line">            tomcatExecutors.submit(<span class="keyword">new</span> ControlThread(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//简单粗暴的关闭线程池</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        businessExecutors.shutdown();</span><br><span class="line">        tomcatExecutors.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟Control任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ControlThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ControlThread</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                requestIdThreadLocal.set(i);</span><br><span class="line">                <span class="comment">//使用线程池异步处理任务</span></span><br><span class="line">                businessExecutors.submit(<span class="keyword">new</span> BusinessTask(Thread.currentThread().getName()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务任务，主要是模拟在Control控制层，提交任务到线程池执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String parentThreadName;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BusinessTask</span><span class="params">(String parentThreadName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.parentThreadName = parentThreadName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//如果与上面的能对应上来，则说明正确，否则失败</span></span><br><span class="line">            System.out.println(<span class="string">&quot;parentThreadName:&quot;</span> + parentThreadName + <span class="string">&quot;:&quot;</span> + requestIdThreadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行效果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1:0</span><br><span class="line">pool-1-thread-2:1</span><br><span class="line">pool-1-thread-3:2</span><br><span class="line">pool-1-thread-4:3</span><br><span class="line">pool-1-thread-5:4</span><br><span class="line">pool-1-thread-6:5</span><br><span class="line">pool-1-thread-7:6</span><br><span class="line">pool-1-thread-8:7</span><br><span class="line">pool-1-thread-9:8</span><br><span class="line">pool-1-thread-10:9</span><br><span class="line">parentThreadName:pool-1-thread-7:6</span><br><span class="line">parentThreadName:pool-1-thread-4:6</span><br><span class="line">parentThreadName:pool-1-thread-3:6</span><br><span class="line">parentThreadName:pool-1-thread-2:6</span><br><span class="line">parentThreadName:pool-1-thread-1:6</span><br><span class="line">parentThreadName:pool-1-thread-9:6</span><br><span class="line">parentThreadName:pool-1-thread-10:6</span><br><span class="line">parentThreadName:pool-1-thread-8:7</span><br><span class="line">parentThreadName:pool-1-thread-6:5</span><br><span class="line">parentThreadName:pool-1-thread-5:4</span><br></pre></td></tr></table></figure><p>从这里可以出thread-7、thread-4、thread-3、thread-2、thread-1、thread-9、thread-10获取的都是6，在子线程中出现出现了线程本地变量混乱的现象，在全链路跟踪与压测出现这种情况是致命的。</p><p>问题：大家通过上面的学习，应该能解释这个现象？此处可以稍微停下来思考一番。</p><p>怎么解决这个问题呢？</p><p>TransmittableThreadLocal ”闪亮登场“。</p><h2 id="3、TransmittableThreadLocal"><a href="#3、TransmittableThreadLocal" class="headerlink" title="3、TransmittableThreadLocal"></a>3、TransmittableThreadLocal</h2><h3 id="3-1-TransmittableThreadLocal“何许人也”"><a href="#3-1-TransmittableThreadLocal“何许人也”" class="headerlink" title="3.1 TransmittableThreadLocal“何许人也”"></a>3.1 TransmittableThreadLocal“何许人也”</h3><p>TransmittableThreadLocal何许人也，它可是阿里巴巴开源的专门解决InheritableThreadLocal的局限性，实现线程本地变量在线程池的执行过程中，能正常的访问父线程设置的线程变量。实践是检验整理的唯一标准，我们还是以上面的示例来进行验证，看看TransmittableThreadLocal是否支持上述场景：</p><p>首先需要在pom.xml文件中引入如下maven依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>transmittable-thread-local<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟tomcat线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService tomcatExecutors = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务线程池，默认Control中异步任务执行线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService businessExecutors = TtlExecutors.getTtlExecutorService(Executors.newFixedThreadPool(<span class="number">4</span>)); <span class="comment">// 使用ttl线程池，该框架的使用，请查阅官方文档。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程上下文环境，模拟在Control这一层，设置环境变量，然后在这里提交一个异步任务，模拟在子线程中，是否可以访问到刚设置的环境变量值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> TransmittableThreadLocal&lt;Integer&gt; requestIdThreadLocal = <span class="keyword">new</span> TransmittableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private static InheritableThreadLocal&lt;Integer&gt; requestIdThreadLocal = new InheritableThreadLocal&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ ) &#123;</span><br><span class="line">            tomcatExecutors.submit(<span class="keyword">new</span> ControlThread(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//简单粗暴的关闭线程池</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        businessExecutors.shutdown();</span><br><span class="line">        tomcatExecutors.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟Control任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ControlThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ControlThread</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            requestIdThreadLocal.set(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用线程池异步处理任务</span></span><br><span class="line"></span><br><span class="line">            businessExecutors.submit(<span class="keyword">new</span> BusinessTask(Thread.currentThread().getName()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务任务，主要是模拟在Control控制层，提交任务到线程池执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String parentThreadName;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BusinessTask</span><span class="params">(String parentThreadName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.parentThreadName = parentThreadName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//如果与上面的能对应上来，则说明正确，否则失败</span></span><br><span class="line">            System.out.println(<span class="string">&quot;parentThreadName:&quot;</span> + parentThreadName + <span class="string">&quot;:&quot;</span> + requestIdThreadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> pool-1-thread-10:9</span><br><span class="line"> pool-1-thread-8:7</span><br><span class="line"> pool-1-thread-7:6</span><br><span class="line"> pool-1-thread-9:8</span><br><span class="line"> pool-1-thread-6:5</span><br><span class="line"> pool-1-thread-5:4</span><br><span class="line"> pool-1-thread-4:3</span><br><span class="line"> pool-1-thread-3:2</span><br><span class="line"> pool-1-thread-2:1</span><br><span class="line">pool-1-thread-1:0</span><br><span class="line">parentThreadName:pool-1-thread-5:4</span><br><span class="line">parentThreadName:pool-1-thread-9:4</span><br><span class="line">parentThreadName:pool-1-thread-3:4</span><br><span class="line">parentThreadName:pool-1-thread-2:4</span><br><span class="line">parentThreadName:pool-1-thread-7:4</span><br><span class="line">parentThreadName:pool-1-thread-8:4</span><br><span class="line">parentThreadName:pool-1-thread-1:4</span><br><span class="line">parentThreadName:pool-1-thread-6:5</span><br><span class="line">parentThreadName:pool-1-thread-10:9</span><br><span class="line">parentThreadName:pool-1-thread-4:3</span><br></pre></td></tr></table></figure><p>执行结果符合预期。那TransmittableThreadLocal是如何实现的呢？</p><h3 id="3-2-TransmittableThreadLocal实现原理"><a href="#3-2-TransmittableThreadLocal实现原理" class="headerlink" title="3.2 TransmittableThreadLocal实现原理"></a>3.2 TransmittableThreadLocal实现原理</h3><blockquote><p>从InheritableThreadLocal不支持线程池的根本原因是InheritableThreadLocal是在父线程创建子线程时复制的，由于线程池的复用机制，“子线程”只会复制一次。要支持线程池中能访问提交任务线程的本地变量，其实只需要在父线程在向线程池提交任务时复制父线程的上下环境，那在子线程中就能够如愿访问到父线程中的本地遍历，实现本地环境变量在线程调用之中的透传，实现链路跟踪，这也就是TransmittableThreadLocal最本质的实现原理。</p></blockquote><h4 id="3-2-1-TransmittableThreadLocal类图"><a href="#3-2-1-TransmittableThreadLocal类图" class="headerlink" title="3.2.1 TransmittableThreadLocal类图"></a>3.2.1 TransmittableThreadLocal类图</h4><p><img src="https://img-blog.csdnimg.cn/20190720230155275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>TransmittableThreadLocal继承自InheritableThreadLocal，接下来将从set方法为入口，开始探究TransmittableThreadLocal实现原理。</p><h4 id="3-2-2-set方法详解"><a href="#3-2-2-set方法详解" class="headerlink" title="3.2.2 set方法详解"></a>3.2.2 set方法详解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.set(value);                              <span class="comment">// @1</span></span><br><span class="line">    <span class="comment">// may set null to remove value</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == value)                               <span class="comment">// @2</span></span><br><span class="line">        removeValue();</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">addValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先调用父类的set方法，将value存入线程本地遍历，即Thread对象的inheritableThreadLocals中。</p><p>代码@2：如果value为空，则调用removeValue()否则调用addValue。</p><p>那接下来重点看看这两个方法有什么名堂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!holder.get().containsKey(<span class="keyword">this</span>)) &#123;    <span class="comment">// @1</span></span><br><span class="line">        holder.get().put(<span class="keyword">this</span>, <span class="keyword">null</span>); <span class="comment">// WeakHashMap supports null value.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    holder.get().remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：当前线程在调用threadLocal方法的set方法(即向线程本地遍历存储数据时)，如果需要设置的值不为null，则调用addValue方法，将当前ThreadLocal存储到TransmittableThreadLocal的全局静态变量holder。holder的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> InheritableThreadLocal&lt;Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt; holder =</span><br><span class="line">            <span class="keyword">new</span> InheritableThreadLocal&lt;Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; initialValue() &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; childValue(Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; parentValue) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;(parentValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>从中可以看出，使用了线程本地变量，内部存放的结构为Map&lt;TransmittableThreadLocal<?>, ?>，即该对象缓存了线程执行过程中所有的TransmittableThreadLocal对象，并且其关联的值不为空。但这样做有什么用呢？</p><p>为了解开这个难题，可能需要大家对ttl这个框架的使用有一定的理解，本文由于篇幅的原因，将不会详细介绍，如有大家有兴趣，可以查阅其官网了解其使用：<a href="https://github.com/alibaba/transmittable-thread-local">https://github.com/alibaba/transmittable-thread-local</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = TtlExecutors.getTtlExecutorService(Executors.newFixedThreadPool(<span class="number">4</span>));</span><br><span class="line">TransmittableThreadLocal&lt;String&gt; parent = <span class="keyword">new</span> TransmittableThreadLocal&lt;String&gt;();</span><br><span class="line">parent.set(<span class="string">&quot;value-set-in-parent&quot;</span>);</span><br><span class="line">Runnable task = <span class="keyword">new</span> Task(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">Callable call = <span class="keyword">new</span> Call(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">executorService.submit(task);</span><br><span class="line">executorService.submit(call);</span><br><span class="line"></span><br><span class="line">我们从submit为突破口，来尝试解开holder属性用途。</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExecutorTtlWrapper</span> <span class="keyword">implements</span> <span class="title">Executor</span>, <span class="title">TtlEnhanced</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"></span><br><span class="line">    ExecutorTtlWrapper(<span class="meta">@Nonnull</span> Executor executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="meta">@Nonnull</span> Runnable command)</span> </span>&#123;</span><br><span class="line">        executor.execute(TtlRunnable.get(command));  <span class="comment">// @1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nonnull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">unwrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在向线程池提交任务时，会使用TtlRunnable对提交任务进行包装。接下来将重点探讨TtlRunnable。</p><h4 id="3-2-2-TtlRunnable详解"><a href="#3-2-2-TtlRunnable详解" class="headerlink" title="3.2.2 TtlRunnable详解"></a>3.2.2 TtlRunnable详解</h4><h5 id="3-2-2-1-类图"><a href="#3-2-2-1-类图" class="headerlink" title="3.2.2.1 类图"></a>3.2.2.1 类图</h5><p><img src="https://img-blog.csdnimg.cn/20190720230352201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下面一一来介绍其核心属性：</p><ul><li>AtomicReference&lt; Object&gt; capturedRef<br>“捕获”的引用，根据下文的解读，该引用指向的数据结构包含了父线程在执行过程中，通过使用TransmittableThreadLocal存储的本地线程变量，但这里的触发时机是向线程池提交任务时捕获。</li><li>Runnable runnable<br>提交到线程池中待执行的业务逻辑。</li><li>boolean releaseTtlValueReferenceAfterRun<br>默认为false。</li></ul><p>接下来重点看一下其构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">TtlRunnable</span><span class="params">(<span class="meta">@Nonnull</span> Runnable runnable, <span class="keyword">boolean</span> releaseTtlValueReferenceAfterRun)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.capturedRef = <span class="keyword">new</span> AtomicReference&lt;Object&gt;(capture());   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">this</span>.runnable = runnable;</span><br><span class="line">    <span class="keyword">this</span>.releaseTtlValueReferenceAfterRun = releaseTtlValueReferenceAfterRun;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法没什么特别，重点看一下子线程是如何“捕获”父线程中已设置的本地线程变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TransmittableThreadLocal$Transmitter#capture</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; captured = <span class="keyword">new</span> HashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;();  <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">for</span> (TransmittableThreadLocal&lt;?&gt; threadLocal : holder.get().keySet()) &#123;     <span class="comment">// @2</span></span><br><span class="line">        captured.put(threadLocal, threadLocal.copyValue());                              <span class="comment">// @3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> captured;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：先创建Map容器，用来存储父线程的本地线程变量，键为在父线程执行过程中使用到的TransmittableThreadLocal线程。</p><p>代码@2：holder.get()，获取父线程中使用中的ThreadLocal，因为我们从3.2.2节中发现，在当前线程在调用TransmittableThreadLocal的set方法，并且其值不为空的时候，会将TransmittableThreadLocal对象存储存储在当前线程的本地变量中。故这里使用holder.get()方法能获取父线程中已使用的ThreadLocal，并其值不为null。</p><p>代码@3：遍历父线程已使用的线程本地，将其值存入到captured中，注意默认是浅拷贝，如果向实现深度拷贝，请重写TransmittableThreadLocal的copyValue方法。</p><blockquote><p>温馨提示：从这里看出TransmittableThreadLocal的静态属性holder的用处吧，请重点理解holder的属性类型为：InheritableThreadLocal&lt;Map&lt;TransmittableThreadLocal<?>, ?>&gt;。</p></blockquote><p>在向线程池提交任务时，就会先捕获父线程(提交任务到线程池的线程)中的本地环境变量，接下来重点来看一下其run方法。</p><h5 id="3-2-2-2-run方法"><a href="#3-2-2-2-run方法" class="headerlink" title="3.2.2.2 run方法"></a>3.2.2.2 run方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object captured = capturedRef.get();             </span><br><span class="line">    <span class="keyword">if</span> (captured == <span class="keyword">null</span> || releaseTtlValueReferenceAfterRun &amp;&amp; !capturedRef.compareAndSet(captured, <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;TTL value reference is released after run!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object backup = replay(captured);                <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        runnable.run();                                           <span class="comment">// @2</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        restore(backup);                                        <span class="comment">// @3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：”重放”父线程的本地环境变量，即使用从父线程中捕获过来的上下文环境，在子线程中重新执行一遍，并返回原先存在与子线程中的上下文环境变量。</p><p>代码@2：执行业务逻辑。</p><p>代码@3：恢复线程池中当前执行任务的线程的上下文环境，即代码@1，会直接继承父线程中的上下文环境，但会将原先存在该线程的线程上下文环境进行备份，在任务执行完后通过执行restore方法进行恢复。</p><p>不得不佩服这里设计的巧妙。笔者有理由相信能看到这里的诸位读者一定是有实力有求知的欲望的人，那我们在来看一下replay、restore方法的实现。</p><h5 id="3-2-2-3-replay"><a href="#3-2-2-3-replay" class="headerlink" title="3.2.2.3 replay"></a>3.2.2.3 replay</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">replay</span><span class="params">(<span class="meta">@Nonnull</span> Object captured)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; capturedMap = (Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;) captured;      <span class="comment">// @1</span></span><br><span class="line">    Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; backup = <span class="keyword">new</span> HashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;();              </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;? extends Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt; iterator = holder.get().entrySet().iterator();               <span class="comment">// @2</span></span><br><span class="line">                 iterator.hasNext(); ) &#123;</span><br><span class="line">        Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; next = iterator.next();</span><br><span class="line">        TransmittableThreadLocal&lt;?&gt; threadLocal = next.getKey();</span><br><span class="line"></span><br><span class="line">        backup.put(threadLocal, threadLocal.get());                                                                                                                       <span class="comment">// @3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear the TTL values that is not in captured</span></span><br><span class="line">        <span class="comment">// avoid the extra TTL values after replay when run task</span></span><br><span class="line">        <span class="keyword">if</span> (!capturedMap.containsKey(threadLocal)) &#123;                                                                                                                    <span class="comment">// @4</span></span><br><span class="line">            iterator.remove();</span><br><span class="line">            threadLocal.superRemove();</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">// set values to captured TTL</span></span><br><span class="line">      setTtlValuesTo(capturedMap);                                                                                                                                              <span class="comment">// @5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// call beforeExecute callback</span></span><br><span class="line">    doExecuteCallback(<span class="keyword">true</span>);                                                                                                                                                     <span class="comment">// @6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> backup;                                                                                                                                                                       <span class="comment">// @7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先解释一下两个局部变量的含义：</p><ul><li>capturedMap<br>子线程从父线程捕获的线程本地遍历。</li><li>backup<br>线程池中处理本次任务的线程中原先存在的本地线程变量。</li></ul><p>代码@2：holder.get()，这里是子线程中原先存在的本地线程变量(即线程池中分配来执行本次任务的线程)，然后遍历它，将其存储在backUp(@3)。</p><p>代码@4：从这里开始，开始将根据父线程的本地变量来重放当前线程，如果父线程中不包含的threadlocal对象，将从本地线程变量中移除。</p><p>代码@5：遍历父线程中的本地线程变量，在子线程中重新执行一次threadlocal.set方法。</p><p>代码@6：执行beforeExecute()狗子函数。</p><p>代码@7：返回线程池原线程的本地线程变量，供本次调用后恢复上下文环境。</p><h5 id="3-2-2-4-restore"><a href="#3-2-2-4-restore" class="headerlink" title="3.2.2.4 restore"></a>3.2.2.4 restore</h5><p>恢复线程中子线程原先的本地线程变量，即恢复线程，本次执行并不会污染线程池中线程原先的上下文环境，精妙。我们来看看其代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restore</span><span class="params">(<span class="meta">@Nonnull</span> Object backup)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; backupMap = (Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;) backup;      <span class="comment">// @1</span></span><br><span class="line">    <span class="comment">// call afterExecute callback</span></span><br><span class="line">    doExecuteCallback(<span class="keyword">false</span>);                                                                                                                                                   <span class="comment">// @2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;? extends Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt; iterator = holder.get().entrySet().iterator();           <span class="comment">// @3</span></span><br><span class="line">                 iterator.hasNext(); ) &#123;</span><br><span class="line">        Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; next = iterator.next();</span><br><span class="line">        TransmittableThreadLocal&lt;?&gt; threadLocal = next.getKey();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear the TTL values that is not in bac1kup</span></span><br><span class="line">        <span class="comment">// avoid the extra TTL values after restore</span></span><br><span class="line">        <span class="keyword">if</span> (!backupMap.containsKey(threadLocal)) &#123;                                                                                                                     <span class="comment">// @4</span></span><br><span class="line">            iterator.remove();</span><br><span class="line">            threadLocal.superRemove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restore TTL values</span></span><br><span class="line">    setTtlValuesTo(backupMap);                                                                                                                                                  <span class="comment">// @5</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>代码@1：获取备份好的线程本地上下文。</p><p>代码@2：执行afterExecute()钩子函数。</p><p>代码@3：遍历本地线程变量，将不属于backUpMap中存在的线程本地上下文移除(@4)。</p><p>代码@5：遍历备份的本地线程本地，在本地线程中重新执行threadlocal#set方法，实现线程本地变量的还原。</p><p>本文介绍到这里了，详细介绍了ThreadLocal、InheritableThreadLocal、TransmittableThreadLocal的实现原理，并从ThreadLocal、InheritableThreadLocal的局限性，最终引出TransmittableThreadLocal，为全链路压测中压测标记的透传打下坚实的基础。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;说起本地线程变量，我相信大家首先会想到的是JDK默认提供的ThreadLocal，用来存储在整个调用链中都需要访问的数据，并且是线程安全的。由于本文的写作背景是笔者需要在公司落地全链路压测平台，一个基本并核心的功能需求是压测标记需要在整个调用链中进行传递，线程上下文环境成为解决这个问题最合适的技术。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;温馨提示：&lt;br&gt;本从从ThreadLocal原理入手分析，并抛出其缺点，再逐一引出InheritableThreadLocal、TransmittableThreadLocal。文章篇幅稍长，但由于循序渐进，层层递进，故精华部分在后面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1、ThreadLocal详解&quot;&gt;&lt;a href=&quot;#1、ThreadLocal详解&quot; class=&quot;headerlink&quot; title=&quot;1、ThreadLocal详解&quot;&gt;&lt;/a&gt;1、ThreadLocal详解&lt;/h2&gt;&lt;p&gt;ThreadLocal对外提供;的API如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;public T get(）&lt;br&gt;从线程上下文环境中获取设置的值。&lt;/li&gt;
&lt;li&gt;public void set(T value)&lt;br&gt;将值存储到线程上下文环境中，供后续使用。&lt;/li&gt;
&lt;li&gt;public void remove()&lt;br&gt;清除线程本地上下文环境。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述API使用简单，关键是要理解ThreadLocal的内部存储结果。&lt;/p&gt;
&lt;h3 id=&quot;1-1-ThreadLocal存储结构&quot;&gt;&lt;a href=&quot;#1-1-ThreadLocal存储结构&quot; class=&quot;headerlink&quot; title=&quot;1.1 ThreadLocal存储结构&quot;&gt;&lt;/a&gt;1.1 ThreadLocal存储结构&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190720224949903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;上图的几个关键点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据存储位置&lt;br&gt;当线程调用threadLocal对象的set(Object value)方法时，数据并不是存储在ThreadLocal对象中，而是存储在Thread对象中，这也是ThreadLocal的由来，具体存储在线程对象的threadLocals属性中，其类型为ThreadLocal.ThreadLocalMap。&lt;/li&gt;
&lt;li&gt;ThreadLocal.ThreadLocalMap，Map结构，即键值对，键为threadLocal对象，值为需要存储到线程上下文的值(threadLocal#set)方法的参数。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="全链路" scheme="http://example.com/tags/%E5%85%A8%E9%93%BE%E8%B7%AF/"/>
    
    <category term="ThreadLocal" scheme="http://example.com/tags/ThreadLocal/"/>
    
    <category term="InheritableThreadLocal" scheme="http://example.com/tags/InheritableThreadLocal/"/>
    
    <category term="ttl" scheme="http://example.com/tags/ttl/"/>
    
  </entry>
  
</feed>
