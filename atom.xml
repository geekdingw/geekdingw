<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>中间件兴趣圈</title>
  
  <subtitle>关注微信公众号「中间件兴趣圈」，第一时间获取最新干货！</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-12-09T15:30:56.273Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>中间件兴趣圈</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>快速排序算法java版实现</title>
    <link href="http://example.com/posts/42760d48.html"/>
    <id>http://example.com/posts/42760d48.html</id>
    <published>2020-12-09T15:26:35.000Z</published>
    <updated>2020-12-09T15:30:56.273Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>快速排序思想：从待排序序列中找到一个关键字（默认为第一个元素） 然后将比关键字少的数据排列在左边，大于关键字的排在右边，然后对关键字左右两边的序列继续上面步骤，直至关键字两边的序列都已经排好序。具体算法如下：</p><p>设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，</p><p> 然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。<br> 值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。<br> 一趟快速排序的算法是：<br> 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br> 2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；<br> 3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；<br> 4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；<br> 5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,<br> 4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。</p><p> 找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</p><blockquote><p>温馨提示：上述算法的描述来源与百度，大家也可以按照上面的算法，用自己熟悉的语言尝试实现一遍。</p></blockquote><p>一言不合继续用代码说话。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> persistent.prestige.console.algorithm;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，</span></span><br><span class="line"><span class="comment"> * 然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。</span></span><br><span class="line"><span class="comment"> * 值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。</span></span><br><span class="line"><span class="comment"> * 一趟快速排序的算法是：</span></span><br><span class="line"><span class="comment"> * 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；</span></span><br><span class="line"><span class="comment"> * 2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；</span></span><br><span class="line"><span class="comment"> * 3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；</span></span><br><span class="line"><span class="comment"> * 4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；</span></span><br><span class="line"><span class="comment"> * 5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,</span></span><br><span class="line"><span class="comment"> * 4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。</span></span><br><span class="line"><span class="comment"> * 找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lenovo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> hign )</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(hign &lt;= low) <span class="keyword">return</span>; <span class="comment">// 如果hign 小于等于 low ,说明待排序队列只包含一个元素，无法再排序</span></span><br><span class="line"><span class="keyword">int</span> keyIdx = asort(a, low, hign); </span><br><span class="line"><span class="keyword">if</span>( ! (keyIdx == low &amp;&amp; low == hign) ) &#123; <span class="comment">// keyIdx == low &amp;&amp; low == hign 则说明不可分</span></span><br><span class="line"><span class="keyword">if</span>(keyIdx == low ) &#123; <span class="comment">//说明左边已经排好序了</span></span><br><span class="line">quickSort(a, low + <span class="number">1</span>, hign);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>  (keyIdx == hign ) &#123;  <span class="comment">// 说明右边已经排序好了</span></span><br><span class="line">quickSort(a, low, hign -<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">quickSort(a, low , keyIdx -<span class="number">1</span>); <span class="comment">// 关键字左边排序</span></span><br><span class="line">quickSort(a, keyIdx + <span class="number">1</span>, hign); <span class="comment">// 关键字右边排序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序   一趟排序算法实现</span></span><br><span class="line"><span class="comment"> * 一趟快速排序的算法是：(来源于百度百科)</span></span><br><span class="line"><span class="comment"> * 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；</span></span><br><span class="line"><span class="comment"> * 2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；</span></span><br><span class="line"><span class="comment"> * 3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；</span></span><br><span class="line"><span class="comment"> * 4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；</span></span><br><span class="line"><span class="comment"> * 5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,</span></span><br><span class="line"><span class="comment"> * 4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。</span></span><br><span class="line"><span class="comment"> * 找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> low       待排序起始下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hign      待排序结束下标  (low hign) 限制排序数组范围</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>          本轮排序后，关键字所在位置(下标)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">asort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> hign)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> key = a[low];</span><br><span class="line">loop :</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">// low 与 hign 相等时退出</span></span><br><span class="line"><span class="keyword">while</span>( hign &gt; <span class="number">0</span> ) &#123;</span><br><span class="line"><span class="keyword">if</span>( a[hign] &lt; key ) &#123;</span><br><span class="line">swap(a, low, hign);   <span class="comment">// 从后向前找，找到第一个比关键字小的元素后交换元素后跳出本次比较</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">hign --;</span><br><span class="line"><span class="keyword">if</span>(low == hign) <span class="keyword">break</span> loop;</span><br><span class="line">&#125;</span><br><span class="line">low ++; </span><br><span class="line"><span class="keyword">if</span>(low == hign) <span class="keyword">break</span> loop;</span><br><span class="line"><span class="keyword">while</span>( low &lt; a.length ) &#123;</span><br><span class="line"><span class="keyword">if</span>( a[low] &gt; key ) &#123;   <span class="comment">// 从前向后找，找到第一个比关键字大的元素时交换元素后跳出本次比较</span></span><br><span class="line">swap(a, low, hign);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">low ++; </span><br><span class="line"><span class="keyword">if</span>(low == hign) <span class="keyword">break</span> loop;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> low;<span class="comment">//关键字所在的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换数组中两个元素的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = a[i];</span><br><span class="line">a[i] = a[j];</span><br><span class="line">a[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">&quot;待排序数据：(5,8,2,10,6,9,21,18,19,7)&quot;</span>);</span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">21</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">7</span>&#125;;</span><br><span class="line">quickSort(a, <span class="number">0</span>, a.length -<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;排序后结果：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot; ---------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;待排序数据：(5,8,2,10,5,9,21,18,8,7)&quot;</span>);</span><br><span class="line">a = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">21</span>,<span class="number">18</span>,<span class="number">8</span>,<span class="number">7</span>&#125;;</span><br><span class="line">quickSort(a, <span class="number">0</span>, a.length -<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;排序后结果：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;快速排序思想：从待排序序列中找到一个关键字（默认为第一个元素） 然后将比关键字少的数据排列在左边，大于关键字的排在右边，然后对关键字左右两边的序列继续上面步骤，直至关键字两边的序列都已经排好序。具体算法如下：&lt;/p&gt;
&lt;p&gt;设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，&lt;/p&gt;
&lt;p&gt; 然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。&lt;br&gt; 值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。&lt;br&gt; 一趟快速排序的算法是：&lt;br&gt; 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；&lt;br&gt; 2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；&lt;br&gt; 3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；&lt;br&gt; 4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；&lt;br&gt; 5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,&lt;br&gt; 4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。&lt;/p&gt;
&lt;p&gt; 找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;温馨提示：上述算法的描述来源与百度，大家也可以按照上面的算法，用自己熟悉的语言尝试实现一遍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一言不合继续用代码说话。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java 算法" scheme="http://example.com/tags/java-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序二叉树JAVA版实现</title>
    <link href="http://example.com/posts/3b6094a6.html"/>
    <id>http://example.com/posts/3b6094a6.html</id>
    <published>2020-12-09T15:22:35.000Z</published>
    <updated>2020-12-09T15:25:39.337Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>1、排序二叉树特点</p><ul><li>根节点的值大于等于左子树的节点</li><li>根节点的值小于等于它右子树的节点。</li></ul><p>2、遍历二叉树的方法</p><ul><li>先序遍历：先遍历根节点，然后遍历左子树，再遍历右子树</li><li>中序遍历：先遍历左子树，然后遍历根节点，再遍历右子树</li><li>后续遍历  </li></ul><p><strong>如果要保证节点从小到大排序，采用中序遍历</strong>；</p><p>一言不合就写代码实现，提供详细的可视化角度（代码可运行）。</p><p>目前代码中，已经实现 新增单个元素、删除单个元素、中序遍历整颗树。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br></pre></td><td class="code"><pre><span class="line">package persistent.prestige.study.datastructures.tree;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.List;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 二叉树学习</span><br><span class="line"> * </span><br><span class="line">在数据结构里，</span><br><span class="line">就是对一棵二叉树所有结点的访问</span><br><span class="line">前序遵循“根左右”</span><br><span class="line">中序遵循“左根右”</span><br><span class="line">后序遵循“左右根”</span><br><span class="line">根：根节点</span><br><span class="line">左：左子女</span><br><span class="line">右：右子女</span><br><span class="line">如：一棵二叉树 ：</span><br><span class="line">           A</span><br><span class="line">          &#x2F; \</span><br><span class="line">         B   C</span><br><span class="line">        &#x2F; \ </span><br><span class="line">       D   E</span><br><span class="line">前序访问顺序就是：ABDEC（根一定第一个）</span><br><span class="line">中序访问顺序就是：DBEAC（根一定在中间）</span><br><span class="line">后序访问顺序就是：DEBCA（根一定在最后）</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * @author prestigeding@126.com</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BinaryTree&lt;E&gt; implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * </span><br><span class="line"> *&#x2F;</span><br><span class="line">private static final long serialVersionUID &#x3D; -3970337667739333043L;</span><br><span class="line"></span><br><span class="line">private Comparator&lt;E&gt; comparator;</span><br><span class="line"></span><br><span class="line">private TreeNode&lt;E&gt; root;</span><br><span class="line"></span><br><span class="line">public BinaryTree() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public BinaryTree(Comparator&lt;E&gt; comparator) &#123;</span><br><span class="line">super();</span><br><span class="line">this.comparator &#x3D; comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 增加元素</span><br><span class="line"> * @param e</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">if(e &#x3D;&#x3D; null) return false;</span><br><span class="line"></span><br><span class="line">if(root &#x3D;&#x3D; null ) &#123;</span><br><span class="line">root &#x3D; new TreeNode&lt;E&gt;(e, null);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add0(root, e);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> *                          10</span><br><span class="line"> *                     &#x2F;          \</span><br><span class="line"> *                    3           18</span><br><span class="line"> *                  &#x2F;   \        &#x2F;   \               </span><br><span class="line"> *                 2     4      13    21       </span><br><span class="line"> *                         \</span><br><span class="line"> *                          9</span><br><span class="line"> *                        &#x2F;   \</span><br><span class="line"> *                       8     9 </span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * @param root</span><br><span class="line"> * @param e</span><br><span class="line"> *&#x2F;</span><br><span class="line">private TreeNode&lt;E&gt; add0(TreeNode&lt;E&gt; root, E e) &#123;</span><br><span class="line">final TreeNode&lt;E&gt; curNode &#x3D; root;</span><br><span class="line"></span><br><span class="line">int cmp &#x3D; compare(e, curNode.value);</span><br><span class="line">if(cmp &lt; 0 ) &#123; &#x2F;&#x2F;表示待插入的节点值，比当前节点值小</span><br><span class="line">if(curNode.left &#x3D;&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F;创建当前节点的左节点</span><br><span class="line">TreeNode&lt;E&gt; newNode &#x3D; new TreeNode&lt;E&gt;(e, curNode);</span><br><span class="line">curNode.left &#x3D; newNode;</span><br><span class="line">return newNode;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return add0(curNode.left, e);&#x2F;&#x2F;遍历左子树</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123; &#x2F;&#x2F; 大于等于0，右子树</span><br><span class="line">if(curNode.right &#x3D;&#x3D; null ) &#123;</span><br><span class="line">&#x2F;&#x2F;创建当前节点的右节点</span><br><span class="line">TreeNode&lt;E&gt; newNode &#x3D; new TreeNode&lt;E&gt;(e, curNode);</span><br><span class="line">curNode.right &#x3D; newNode;</span><br><span class="line">return newNode;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return add0(curNode.right, e);&#x2F;&#x2F;遍历右子树</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 比较两个元素的大小</span><br><span class="line"> * @param e1</span><br><span class="line"> * @param e2</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">private int compare(E e1, E e2) &#123;</span><br><span class="line">return comparator &#x3D;&#x3D; null ?  ((Comparable&lt;E&gt;) e1 ).compareTo(e2) : comparator.compare(e1, e2);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * </span><br><span class="line"> * 删除元素</span><br><span class="line"> * @param e  </span><br><span class="line"> * @return  如果返回ture,表示删除成功,如果返回false,表示删除失败，没有找到元素</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean remove(E e) &#123;</span><br><span class="line">if( e &#x3D;&#x3D; null ) return false;</span><br><span class="line"></span><br><span class="line">TreeNode&lt;E&gt; cur &#x3D; root;</span><br><span class="line">int cmp;</span><br><span class="line">while (cur !&#x3D; null ) &#123;</span><br><span class="line">if(e.equals(cur.value)) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">cmp &#x3D; compare(e, root.value);</span><br><span class="line">if(cmp &lt; 0 ) &#123; &#x2F;&#x2F;表示待删除的节点值，比当前节点值小</span><br><span class="line">cur &#x3D; cur.left;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">cur &#x3D; cur.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(cur !&#x3D; null ) &#123; &#x2F;&#x2F;找到了元素，需要删除该元素</span><br><span class="line">TreeNode&lt;E&gt; cLeft &#x3D; cur.left;</span><br><span class="line">TreeNode&lt;E&gt; cRight &#x3D; cur.right;</span><br><span class="line"></span><br><span class="line">if(cLeft !&#x3D; null ) &#123; &#x2F;&#x2F;如果被删除节点的左子树不为空，则将左子树放入当前节点的位置</span><br><span class="line">remove0(cLeft, cur);</span><br><span class="line">if(cLeft.right !&#x3D; null &amp;&amp;  cur.right !&#x3D; null) &#123; &#x2F;&#x2F;需要移动相应节点</span><br><span class="line">TreeNode&lt;E&gt; wNode &#x3D; cLeft.right;</span><br><span class="line">cLeft.right &#x3D; cur.right;</span><br><span class="line">wNode.parent &#x3D; null;</span><br><span class="line">TreeNode&lt;E&gt; newNode &#x3D; add0(cLeft, wNode.value);</span><br><span class="line">newNode.left &#x3D; wNode.left;</span><br><span class="line">newNode.right &#x3D; wNode.right;</span><br><span class="line">wNode &#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">remove0(cRight, cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将当前节点释放，，help GC</span><br><span class="line">cur.value &#x3D; null;</span><br><span class="line">cur.right &#x3D; null;</span><br><span class="line">cur.left &#x3D; null;</span><br><span class="line">cur.parent &#x3D; null;</span><br><span class="line">cur &#x3D; null;</span><br><span class="line"></span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void remove0(TreeNode&lt;E&gt; newNode, TreeNode&lt;E&gt; cur) &#123;</span><br><span class="line">TreeNode&lt;E&gt; parent &#x3D; cur.parent;</span><br><span class="line">newNode.parent &#x3D; parent;</span><br><span class="line">if(cur.parent.left &#x3D;&#x3D; cur) &#123;</span><br><span class="line">cur.parent.left &#x3D; newNode;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">cur.parent.right &#x3D; newNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 中序遍历</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void middleOrderTraversal() &#123;</span><br><span class="line">System.out.println(&quot;----------中序遍历开始---------\n&quot;);</span><br><span class="line">if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">System.out.print(&quot;二叉树&quot;);</span><br><span class="line">System.out.println(&quot;----------中序遍历结束---------\n&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">middleOrderTraversal0(root);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;\n----------中序遍历结束---------\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 中序遍历</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void middleOrderTraversal0(TreeNode&lt;E&gt; root) &#123;</span><br><span class="line">if (root &#x3D;&#x3D; null)</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">final TreeNode&lt;E&gt; cur &#x3D; root;</span><br><span class="line">if (cur.left !&#x3D; null) &#123;</span><br><span class="line">middleOrderTraversal0(cur.left);</span><br><span class="line">System.out.print(toObjectString(cur.value) + &quot;,&quot;);</span><br><span class="line">middleOrderTraversal0(cur.right);</span><br><span class="line">&#125; else if (cur.right !&#x3D; null) &#123;</span><br><span class="line">System.out.print(cur.value + &quot;,&quot;);</span><br><span class="line">middleOrderTraversal0(cur.right);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; 此时输出节点</span><br><span class="line">System.out.print(cur.value + &quot;,&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public TreeNode&lt;E&gt; getRoot() &#123;</span><br><span class="line">return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setRoot(TreeNode&lt;E&gt; root) &#123;</span><br><span class="line">this.root &#x3D; root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private String toObjectString(E value) &#123;</span><br><span class="line">return value &#x3D;&#x3D; null ? &quot;&quot; : value.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 二叉数</span><br><span class="line"> * </span><br><span class="line"> * @author Administrator</span><br><span class="line"> *</span><br><span class="line"> * @param &lt;E&gt;</span><br><span class="line"> *&#x2F;</span><br><span class="line">@SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">private final static class TreeNode&lt;E&gt; implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">private static final long serialVersionUID &#x3D; 6540618639489225256L;</span><br><span class="line"></span><br><span class="line">public E value;</span><br><span class="line">public TreeNode&lt;E&gt; left;</span><br><span class="line">public TreeNode&lt;E&gt; right;</span><br><span class="line"></span><br><span class="line">public TreeNode&lt;E&gt; parent;</span><br><span class="line"></span><br><span class="line">public TreeNode(E value, TreeNode&lt;E&gt; parent) &#123;</span><br><span class="line">super();</span><br><span class="line">this.value &#x3D; value;</span><br><span class="line">this.parent &#x3D; parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public TreeNode(E value, TreeNode&lt;E&gt; left, TreeNode&lt;E&gt; right, TreeNode&lt;E&gt; parent) &#123;</span><br><span class="line">super();</span><br><span class="line">this.value &#x3D; value;</span><br><span class="line">this.left &#x3D; left;</span><br><span class="line">this.right &#x3D; right;</span><br><span class="line">this.parent &#x3D; parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">if(value !&#x3D; null)</span><br><span class="line">return value.toString();</span><br><span class="line"></span><br><span class="line">return super.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** *******************测试 start ***************************&#x2F;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;测试开始&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;BinaryTree&lt;Integer&gt; t &#x3D; new BinaryTree&lt;Integer&gt;();</span><br><span class="line">&#x2F;&#x2F;t.setRoot(t.initTree());</span><br><span class="line">&#x2F;&#x2F;t.middleOrderTraversal();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;先研究一下 Comparator o1 &gt; o2 的排序逻辑</span><br><span class="line">&#x2F;&#x2F;testSort();</span><br><span class="line"></span><br><span class="line">&#x2F;* *                          10</span><br><span class="line"> *                     &#x2F;              \</span><br><span class="line"> *                    3                18</span><br><span class="line"> *                  &#x2F;   \            &#x2F;   \               </span><br><span class="line"> *                 2     4          13    21       </span><br><span class="line"> *                         \       &#x2F;  \  </span><br><span class="line"> *                          9     11    15  </span><br><span class="line"> *                        &#x2F;   \</span><br><span class="line"> *                       8     9 </span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; add 方法测试</span><br><span class="line">BinaryTree&lt;Integer&gt; t &#x3D; new BinaryTree&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;t.add(new Integer(10));</span><br><span class="line">&#x2F;&#x2F;t.add(new Integer(18));</span><br><span class="line">&#x2F;&#x2F;t.add(new Integer(3));</span><br><span class="line">&#x2F;&#x2F;t.add(new Integer(2));</span><br><span class="line">&#x2F;&#x2F;t.add(new Integer(4));</span><br><span class="line">&#x2F;&#x2F;t.add(new Integer(8));</span><br><span class="line">&#x2F;&#x2F;t.add(new Integer(9));</span><br><span class="line">&#x2F;&#x2F;t.add(new Integer(9));</span><br><span class="line">&#x2F;&#x2F;t.add(new Integer(21));</span><br><span class="line">&#x2F;&#x2F;t.add(new Integer(13));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t.add(new Integer(10));</span><br><span class="line">t.add(new Integer(18));</span><br><span class="line">t.add(new Integer(3));</span><br><span class="line">t.add(new Integer(9));</span><br><span class="line">t.add(new Integer(8));</span><br><span class="line">t.add(new Integer(2));</span><br><span class="line">t.add(new Integer(21));</span><br><span class="line">t.add(new Integer(4));</span><br><span class="line">t.add(new Integer(9));</span><br><span class="line">t.add(new Integer(13));</span><br><span class="line">t.add(new Integer(11));</span><br><span class="line">t.add(new Integer(15));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;查看数结构，中序遍历</span><br><span class="line">t.middleOrderTraversal();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;测试删除</span><br><span class="line">System.out.println(&quot;删除节点18&quot;);</span><br><span class="line">t.remove(new Integer(18));</span><br><span class="line">System.err.println(&quot;删除节点18号的排序二叉树&quot;);</span><br><span class="line">t.middleOrderTraversal();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;测试结束&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 当用升序排序时，则 o1 &gt; o2 时要返回大于0的数</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static void testSort() &#123;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; a &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">a.add(1);</span><br><span class="line">a.add(8);</span><br><span class="line">a.add(9);</span><br><span class="line">a.add(3);</span><br><span class="line">a.add(5);</span><br><span class="line"></span><br><span class="line">Collections.sort(a, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line"></span><br><span class="line">return o1.intValue() &gt; o2.intValue() ? 1 : -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(a);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 用来测试的，后续会完善 加入元素</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> *                          </span><br><span class="line"> *                          10</span><br><span class="line"> *                     &#x2F;          \</span><br><span class="line"> *                    3           18</span><br><span class="line"> *                  &#x2F;   \        &#x2F;   \               </span><br><span class="line"> *                 2     4      13    21       </span><br><span class="line"> *                         \</span><br><span class="line"> *                          9</span><br><span class="line"> *                        &#x2F;   \</span><br><span class="line"> *                       8     9 </span><br><span class="line"> *                       </span><br><span class="line"> *                       </span><br><span class="line"></span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Deprecated</span><br><span class="line">public TreeNode&lt;Integer&gt; initTree() &#123;</span><br><span class="line">TreeNode&lt;Integer&gt; _root &#x3D; new TreeNode&lt;Integer&gt;(new Integer(10), null); &#x2F;&#x2F; 根节点</span><br><span class="line"></span><br><span class="line">TreeNode&lt;Integer&gt; l3 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(3), _root);</span><br><span class="line">_root.left &#x3D; l3;</span><br><span class="line"></span><br><span class="line">TreeNode&lt;Integer&gt; l2 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(2), l3);</span><br><span class="line">l3.left &#x3D; l2;</span><br><span class="line"></span><br><span class="line">TreeNode&lt;Integer&gt; l4 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(4), l3);</span><br><span class="line">l3.right &#x3D; l4;</span><br><span class="line"></span><br><span class="line">TreeNode&lt;Integer&gt; l91 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(9), l4);</span><br><span class="line">l4.right &#x3D; l91;</span><br><span class="line"></span><br><span class="line">TreeNode&lt;Integer&gt; l8 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(8), l91);</span><br><span class="line">l91.left &#x3D; l8;</span><br><span class="line"></span><br><span class="line">TreeNode&lt;Integer&gt; l92 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(9), l91);</span><br><span class="line">l91.right &#x3D; l92;</span><br><span class="line"></span><br><span class="line">TreeNode&lt;Integer&gt; l18 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(18), _root);</span><br><span class="line">_root.right &#x3D; l18;</span><br><span class="line"></span><br><span class="line">TreeNode&lt;Integer&gt; l13 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(13), l18);</span><br><span class="line">l18.left &#x3D; l13;</span><br><span class="line"></span><br><span class="line">TreeNode&lt;Integer&gt; l21 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(21), l18);</span><br><span class="line">l18.right &#x3D; l21;</span><br><span class="line"></span><br><span class="line">return _root;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** *******************测试 end ***************************&#x2F;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;1、排序二叉树特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根节点的值大于等于左子树的节点&lt;/li&gt;
&lt;li&gt;根节点的值小于等于它右子树的节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、遍历二叉树的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先序遍历：先遍历根节点，然后遍历左子树，再遍历右子树&lt;/li&gt;
&lt;li&gt;中序遍历：先遍历左子树，然后遍历根节点，再遍历右子树&lt;/li&gt;
&lt;li&gt;后续遍历  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;如果要保证节点从小到大排序，采用中序遍历&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;一言不合就写代码实现，提供详细的可视化角度（代码可运行）。&lt;/p&gt;
&lt;p&gt;目前代码中，已经实现 新增单个元素、删除单个元素、中序遍历整颗树。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java 算法" scheme="http://example.com/tags/java-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java Reference 引用学习总结</title>
    <link href="http://example.com/posts/3c69fbc4.html"/>
    <id>http://example.com/posts/3c69fbc4.html</id>
    <published>2020-12-09T15:12:35.000Z</published>
    <updated>2020-12-11T04:16:11.016Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="1、Java引用的类型"><a href="#1、Java引用的类型" class="headerlink" title="1、Java引用的类型"></a>1、Java引用的类型</h2><p>强引用、软引用(java.lang.ref.SoftReference)、弱引用(java.lang.ref.WeakReference)、虚引用(　java.lang.ref.PhantomReference　)。</p><p>java默认的引用类型为强引用，比如 Object a = new Object();其中 a 为强引用，new Object()为一个具体的对象。</p><p>至于软应用，弱引用，虚引用，就是 JAVA 虚拟机管理对象的范畴了，可以这样理解，SoftReference、WeakReference、PlantomReference 只是一种标记，JAVA 虚拟机在垃圾回收时，对上述不同的标记【引用的对象】采取不同的措施。采取措施如下：</p><ul><li><p>软引用(SoftReference)：当内存足够时，该引用【引用的对象】不会被回收，那什么是内存足够呢？进行年轻代的垃圾回收不会触发SoftReference所指向对象的回收,如果触发Full GC，那SoftReference所指向的对象将被回收。</p></li><li><p>弱引用(WeakReference) :当进行年轻代垃圾回收时，该引用指向的对象，就会被回收。</p></li><li><p>虚引用(PhantomeReference) 该引用指向的对象，无法对垃圾收集器收集对象时产生任何影响，唯一有用的是，如果被垃圾收集器收集的对象，被PhantomeReference标记，垃圾收集器会通过注册在PhantomeReference上的队列来通知应用程序，该引用指向的对象，已经被垃圾收集器回收。</p></li></ul><p>从上文的描述，也清楚的知道，上述应用是直接JVM打交道，更直接的说是与垃圾回收器直接的交互。</p><a id="more"></a><h2 id="2、java-lang-ref-Reference-详解"><a href="#2、java-lang-ref-Reference-详解" class="headerlink" title="2、java.lang.ref.Reference 详解"></a>2、java.lang.ref.Reference 详解</h2><h4 id="2-1-关键数据结构"><a href="#2-1-关键数据结构" class="headerlink" title="2.1 关键数据结构"></a>2.1 关键数据结构</h4><ul><li><p>private T referent;     /* Treated specially by GC */</p></li><li><p>private ReferenceQueue&lt;? super T&gt; queue;</p></li><li><p>private Reference next;<br>非常关键：Reference 本身可以当场一个 Reference 链表使用，在 ReferenceHandler 线程中从 pending 队列中，取出一个Reference, 如果该 Reference 相关的 queue 不为null,则执行入队操作，r.queue.enqueue(r); 参数为当前的引用，在入队列操作时，只要第一次进入队列，该引用的queue会被设置为 ReferenceQueue.ENQUEUE,也就算是再次调用进入队列操作，此时也无法再次与构造方法中传入的队 列绑定  在一起了。</p></li><li><p>private static Reference pending = null<br>关键中的关键；此队列维护着需要进入通知队列的引用，由 JVM 虚拟机垃圾回收器在检测到被引用指向的对象可达性发生改变后，如果该对象的引用（Referecnce）注册了引用队列 (ReferenceQueue),则 JVM 虚拟机垃圾收集器会将该引用加入到 pending 队列，注意这个 pending 队列是一个静态类变量。</p><p>为了便于理解上述的观点，先展示一下引用如何使用。</p><p>SoftReference sf = new SoftReference( new Object() );</p><p>其中sf 为引用，new Object为 sf指向的对象，其实也就是建立了 sf 到 new Object 对象的引用（关联），然后垃圾回收器发现 new Object 的可达性发生变化（其实就是变为不可达后），此时JVM虚拟机会根据引用对象 sf 的 queue 是否为空，如果为空，则直接将引用的状态变为 InActivie(非激活，离真正回收不远了)</p></li><li><p>ReferenceQueue queue = new ReferenceQueue();<br>  如果 SoftReference sf2 = new SoftRerence( new Object(),  queue );如果垃圾回收器检测到 new Object 的可达性发生变化后，会将该引用添加到 pending 引用链上，然后有专门的线程 ReferenceHandle 线程来将引用加入到引用链中（入队），也就是应用程序可以从 queue 中获取到所以垃圾回收器回收的对象的应用，也就是 queue是 垃圾回收器通知应用程序 被引用指向的对象已经被垃圾回收的消息。</p></li></ul><p>####　2.2 Reference 的状态</p><ul><li><p>Active<br>激活状态（可达），一般新建的引用就是该状态，该状态的属性特点  next = null; queue = ReferenceQueue.Null(默认值) 或者  构造方法指定的 queue  Reference( T referent, ReferenceQueue queue)。</p><p>当垃圾回收器检测到可达性发生变化（变为不可达时），如果 queue == ReferenceQueue.Null 的话，状态直接变为 InActive, 如果 queue 不为空，则加入到 Reference 的静态变量 pending 的队列中，并将状态设置为 Pending。</p></li><li><p>Pending</p><p>会有一个专门的线程 ReferenceHandler 来处理pengding链表中的引用[pending链表，应该是后进先出的特点]，将该引用入队（如果有注册队列，也可以看出是垃圾回收器以此来通知应用程序做些事情【请参考 WeakHashMap 的实现】）。在r.queue.enque(r) 方法中，有个关键点，保证一个引用，只能入队一次，入队后，该引用就与原来的引用队列失去关联；为了清晰展示次过程，将该代码附加上（来源于 java.lang.ref.Reference）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueue(Reference&lt;? extends T&gt; r) &#123; &#x2F;* Called only by Reference class *&#x2F;</span><br><span class="line">        synchronized (r) &#123;</span><br><span class="line">            if (r.queue &#x3D;&#x3D; ENQUEUED) return false; &#x2F;&#x2F;关注这里</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                r.queue &#x3D; ENQUEUED;                &#x2F;&#x2F; 关注这里</span><br><span class="line">                r.next &#x3D; (head &#x3D;&#x3D; null) ? r : head;</span><br><span class="line">                head &#x3D; r;</span><br><span class="line">                queueLength++;</span><br><span class="line">                if (r instanceof FinalReference) &#123;</span><br><span class="line">                    sun.misc.VM.addFinalRefCount(1);</span><br><span class="line">                &#125;</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p></li><li><p>Enqueue<br>进入队列中的Reference 中的 next 为队列中一个引用，或等于this(表示当前引用为最后一个), queue = ReferenceQueue.ENQUEUE。</p></li><li><p>InActive</p><p>queue = ReferenceQueue.NULL; next = this</p></li></ul><p>JAVA 四种引用的理解就到这了，其实 JAVA 中还有一种引用，java.lang.ref.FinalReference 应用，不过修饰符是 default, 包访问权限，主要用于 finalizer方法的执行，请关注下一篇博文。</p><p>再统一聊聊 java 引用中涉及到的引用的几个队列。</p><p>Reference中涉及到的队列(链表)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Reference next;</span><br><span class="line"></span><br><span class="line">private static Reference pending &#x3D; null;</span><br><span class="line"></span><br><span class="line">private ReferenceQueue queue;</span><br></pre></td></tr></table></figure><p>每个引用可以关联一个引用队列，该引用队列由应用程序创建的，，然后垃圾回收器在检测到引用不可达时，将该引用加入到该队列，应用程序可以根据该引用队列来做些处理。（也就是该引用队列 成为 垃圾回收器与应用程序的通信机制）。</p><p>ReferenceQueue 自身的结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private volatile Reference&lt;? extends T&gt; head &#x3D; null;</span><br></pre></td></tr></table></figure><p>首先，应用程序如下使用引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class TestReference &#123;</span><br><span class="line"></span><br><span class="line">           private static ReferenceQueue aQueue &#x3D; new ReferenceQueue();</span><br><span class="line"></span><br><span class="line">           public static void main(String args) &#123;</span><br><span class="line"></span><br><span class="line">                  Object a &#x3D; new Object();   &#x2F;&#x2F; 代码1</span><br><span class="line"></span><br><span class="line">                  WeakReference ref &#x3D; new WeakReference( a, aQueue );  </span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后在程序运行过程，内存不断消耗，直至触发垃圾回收操作。此时，垃圾收集器发现 代码1处的 a 所指向的对象，只有 ref引用它，从根路径不可达，故垃圾回收器，会将 ref 引用加入到  static Reference pending 链表中。</p><blockquote><p>注意，此代码是写在JVM实现中的】</p></blockquote><p>所处理的操作无非就是</p><p>1、如果pending 为空，则将当前引用(ref) 设置为pengding,,并且将 ref对象的next指针指向自己； 如果pending不为空，则将当前的引用(ref)的next指向pengding,然后pengding = 当前的引用ref,所以 pengding 其实就是 一个后进新出的链表单向链表结构。</p><p>2、由此总结出  ref 与 pengding链表关联的第一步  由JVM垃圾回收器完成。<br>从pengding 链表中取出引用，进行入队操作。该操作由专门的线程(ReferenceHandle 线程处理)，我重点将 ReferenceHandle线程的源代码贴出已供分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private static class ReferenceHandler extends Thread &#123;</span><br><span class="line">        ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class="line">            super(g, name);</span><br><span class="line">        &#125;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                Reference r;</span><br><span class="line">                synchronized (lock) &#123;</span><br><span class="line">                    if (pending !&#x3D; null) &#123;        </span><br><span class="line">                        &#x2F;&#x2F; 如果pengding不为空，则取出pengding 的第一个引用，</span><br><span class="line">                        &#x2F;&#x2F; 然后重新设置pengding 的值（为原来的pending.next,见如下代码   a,b,c）</span><br><span class="line">                        r &#x3D; pending;                &#x2F;&#x2F; a 将pending取出，准备入队操作</span><br><span class="line">                        Reference rn &#x3D; r.next;  &#x2F;&#x2F; b 先获取原先pending 的 next</span><br><span class="line">                        pending &#x3D; (rn &#x3D;&#x3D; r) ? null : rn;  </span><br><span class="line">                        &#x2F;&#x2F; c  如果pending的next等于本身，则设在pending为空，否则为链表的下一个。</span><br><span class="line">                        &#x2F;&#x2F; 从这里更加看出 pending 是后进先出队列。</span><br><span class="line">                        r.next &#x3D; r;</span><br><span class="line">                    &#125; else &#123; </span><br><span class="line">                        &#x2F;&#x2F; 如果 pending 为空，则线程阻塞，等待垃圾回收器添加新的引用到 pending链表中</span><br><span class="line">                        try &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; catch (InterruptedException x) &#123; &#125;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; Fast path for cleaners</span><br><span class="line">                if (r instanceof Cleaner) &#123;</span><br><span class="line">                    ((Cleaner)r).clean();</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                ReferenceQueue q &#x3D; r.queue;</span><br><span class="line">                if (q !&#x3D; ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1、Java引用的类型&quot;&gt;&lt;a href=&quot;#1、Java引用的类型&quot; class=&quot;headerlink&quot; title=&quot;1、Java引用的类型&quot;&gt;&lt;/a&gt;1、Java引用的类型&lt;/h2&gt;&lt;p&gt;强引用、软引用(java.lang.ref.SoftReference)、弱引用(java.lang.ref.WeakReference)、虚引用(　java.lang.ref.PhantomReference　)。&lt;/p&gt;
&lt;p&gt;java默认的引用类型为强引用，比如 Object a = new Object();其中 a 为强引用，new Object()为一个具体的对象。&lt;/p&gt;
&lt;p&gt;至于软应用，弱引用，虚引用，就是 JAVA 虚拟机管理对象的范畴了，可以这样理解，SoftReference、WeakReference、PlantomReference 只是一种标记，JAVA 虚拟机在垃圾回收时，对上述不同的标记【引用的对象】采取不同的措施。采取措施如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;软引用(SoftReference)：当内存足够时，该引用【引用的对象】不会被回收，那什么是内存足够呢？进行年轻代的垃圾回收不会触发SoftReference所指向对象的回收,如果触发Full GC，那SoftReference所指向的对象将被回收。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;弱引用(WeakReference) :当进行年轻代垃圾回收时，该引用指向的对象，就会被回收。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;虚引用(PhantomeReference) 该引用指向的对象，无法对垃圾收集器收集对象时产生任何影响，唯一有用的是，如果被垃圾收集器收集的对象，被PhantomeReference标记，垃圾收集器会通过注册在PhantomeReference上的队列来通知应用程序，该引用指向的对象，已经被垃圾收集器回收。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上文的描述，也清楚的知道，上述应用是直接JVM打交道，更直接的说是与垃圾回收器直接的交互。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="reference" scheme="http://example.com/tags/reference/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis一二级缓存实现原理与使用指南</title>
    <link href="http://example.com/posts/36b32da.html"/>
    <id>http://example.com/posts/36b32da.html</id>
    <published>2020-12-09T15:08:35.000Z</published>
    <updated>2020-12-11T04:17:38.694Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>Mybatis 与 Hibernate 一样，支持一二级缓存。一级缓存指的是 Session 级别的缓存，即在一个会话中多次执行同一条 SQL 语句并且参数相同，则后面的查询将不会发送到数据库，直接从 Session 缓存中获取。二级缓存，指的是 SessionFactory 级别的缓存，即不同的会话可以共享。</p><p>缓存，通常涉及到缓存的写、读、过期(更新缓存)等几个方面，请带着这些问题一起来探究Mybatis关于缓存的实现原理吧。</p><blockquote><p>提出问题：缓存的查询顺序，是先查一级缓存还是二级缓存？</p></blockquote><p>本文以SQL查询与更新两个流程来揭开Mybatis缓存实现的细节。</p><h2 id="1、从-SQL-查询流程看一二级缓存"><a href="#1、从-SQL-查询流程看一二级缓存" class="headerlink" title="1、从 SQL 查询流程看一二级缓存"></a>1、从 SQL 查询流程看一二级缓存</h2><blockquote><p>温馨提示，本文不会详细介绍详细的 SQL 执行流程，如果对其感兴趣，可以查阅笔者的另外一篇文章：<a href="https://blog.csdn.net/prestigeding/article/details/90647674">源码分析Mybatis SQL执行流程</a></p></blockquote><h3 id="1-1-创建Executor"><a href="#1-1-创建Executor" class="headerlink" title="1.1 创建Executor"></a>1.1 创建Executor</h3><p>Configuration#newExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;                                                           <span class="comment">// @1</span></span><br><span class="line">      executor = <span class="keyword">new</span> CachingExecutor(executor);                 <span class="comment">// @2</span></span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果 cacheEnabled 为 true，表示开启缓存机制，缓存的实现类为 CachingExecutor，这里使用了经典的装饰模式，处理了缓存的相关逻辑后，委托给的具体的 Executor 执行。</p><p>cacheEnable 在实际的使用中通过在 mybatis-config.xml 文件中指定，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该值默认为true。</p><h3 id="1-2-CachingExecutor-query"><a href="#1-2-CachingExecutor-query" class="headerlink" title="1.2 CachingExecutor#query"></a>1.2 CachingExecutor#query</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameterObject);  <span class="comment">// @1</span></span><br><span class="line">    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);   <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);       <span class="comment">// @3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：根据参数生成SQL语句。</p><p>代码@2：根据 MappedStatement、参数、分页参数、SQL 生成缓存 Key。</p><p>代码@3：调用6个参数的 query 方法。</p><p>缓存 Key 的创建比较简单，本文就只贴出代码，大家一目了然,大家重点关注组成缓存Key的要素。<br>BaseExecute#createCacheKey</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  CacheKey cacheKey = <span class="keyword">new</span> CacheKey();</span><br><span class="line">  cacheKey.update(ms.getId());</span><br><span class="line">  cacheKey.update(rowBounds.getOffset());</span><br><span class="line">  cacheKey.update(rowBounds.getLimit());</span><br><span class="line">  cacheKey.update(boundSql.getSql());</span><br><span class="line">  List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">  <span class="comment">// mimic DefaultParameterHandler logic</span></span><br><span class="line">  <span class="keyword">for</span> (ParameterMapping parameterMapping : parameterMappings) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">      Object value;</span><br><span class="line">      String propertyName = parameterMapping.getProperty();</span><br><span class="line">      <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">        value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">        value = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">        value = parameterObject;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">        value = metaObject.getValue(propertyName);</span><br><span class="line">      &#125;</span><br><span class="line">      cacheKey.update(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (configuration.getEnvironment() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// issue #176</span></span><br><span class="line">    cacheKey.update(configuration.getEnvironment().getId());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cacheKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来重点看CachingExecutor的另外一个query方法。</p><p>CachingExecutor#query</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Cache cache = ms.getCache();    <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      flushCacheIfRequired(ms);        <span class="comment">// @2</span></span><br><span class="line">      <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ensureNoOutParams(ms, boundSql);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);      <span class="comment">// @3</span></span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;                                                              <span class="comment">// @4</span></span><br><span class="line">          list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);    <span class="comment">//@5</span></span><br><span class="line">          tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116                                                               // @6</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);  <span class="comment">//@7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：获取 MappedStatement 中的 Cache cache 属性。<br>代码@2：如果不为空，则尝试从缓存中获取，否则直接委托给具体的执行器执行，例如 SimpleExecutor (@7)。<br>代码@3：尝试从缓存中根据缓存 Key 查找。<br>代码@4：如果从缓存中获取的值不为空，则直接返回缓存中的值，否则先从数据库查询@5，将查询结果更新到缓存中。</p><p>这里的缓存即 MappedStatement 中的 Cache 对象是一级缓存还是二级缓存？通常在 ORM 类框架中，Session 级别的缓存为一级缓存，即会话结束后就会失效，显然这里不会随着 Session 的失效而失效，因为 Cache 对象是存储在于 MappedStatement 对象中的，每一个 MappedStatement 对象代表一个 Dao(Mapper) 中的一个方法，即代表一条对应的 SQL 语句，是一个全局的概念。</p><p>相信大家也会觉得，想继续深入了解 CachingExecutor 中使用的 Cache 是一级缓存还是二级缓存，了解 Cache 对象的创建至关重要。关于 MappedStatement 的创建流程，建议查阅笔者的另外一篇博文：<a href="https://blog.csdn.net/prestigeding/article/details/90488395">源码分析Mybatis MappedStatement的创建流程</a>。</p><p>本文只会关注 MappedStatement 对象流程中关于于缓存相关的部分。</p><p>接下来将按照先二级缓存，再一级缓存的思路进行讲解。</p><h4 id="1-2-1-二级缓存"><a href="#1-2-1-二级缓存" class="headerlink" title="1.2.1 二级缓存"></a>1.2.1 二级缓存</h4><h5 id="1-2-1-1-MappedStatement-cache属性创建机制"><a href="#1-2-1-1-MappedStatement-cache属性创建机制" class="headerlink" title="1.2.1.1 MappedStatement#cache属性创建机制"></a>1.2.1.1 MappedStatement#cache属性创建机制</h5><p>从上面看，如果 cacheEnable 为 true 并且 MappedStatement 对象的 cache 属性不为空，则能使用二级缓存。</p><p>我们可以看到 MappedStatement 对象的 cache 属性赋值的地方为：MapperBuilderAssistant#addMappedStatement，从该方法的调用链可以得知是在解析 Mapper 定义的时候就会创建。<br><img src="https://img-blog.csdnimg.cn/20190826205429651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>使用的 cache 属性为 MapperBuilderAssistant 的 currentCache,我们跟踪一下该属性的赋值方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Cache <span class="title">useCacheRef</span><span class="params">(String namespace)</span></span></span><br></pre></td></tr></table></figure><p>其调用链如下：<br><img src="https://img-blog.csdnimg.cn/2019082620552683.png" alt="在这里插入图片描述"><br>可以看出是在解析 cacheRef 标签，即在解析 Mapper.xml 文件中的 cacheRef 标签时，即二级缓存的使用和 cacheRef 标签离不开关系，并且特别注意一点，其参数为 namespace，即每一个 namespace 对应一个 Cache 对象，在 Mybatis 的方法中，通常namespace 对一个 Mapper.java 对象，对应对数据库一张表的更新、新增操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Cache useNewCache</span><br></pre></td></tr></table></figure><p>其调用链如下图所示：<br><img src="https://img-blog.csdnimg.cn/20190826205659301.png" alt="在这里插入图片描述">在解析 Mapper.xml 文件中的 cache 标签时被调用。</p><h5 id="1-2-1-2-cache标签解析"><a href="#1-2-1-2-cache标签解析" class="headerlink" title="1.2.1.2 cache标签解析"></a>1.2.1.2 cache标签解析</h5><p>接下来我们根据 cache 标签简单看一下 cache 标签的解析，下面以 xml 配置方式为例展开，基于注解的解析，其原理类似，其代码 XMLMapperBuilder 的 cacheElement 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">      String type = context.getStringAttribute(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;PERPETUAL&quot;</span>);                                                      </span><br><span class="line">      Class&lt;? extends Cache&gt; typeClass = typeAliasRegistry.resolveAlias(type);</span><br><span class="line">      String eviction = context.getStringAttribute(<span class="string">&quot;eviction&quot;</span>, <span class="string">&quot;LRU&quot;</span>);</span><br><span class="line">      Class&lt;? extends Cache&gt; evictionClass = typeAliasRegistry.resolveAlias(eviction);</span><br><span class="line">      Long flushInterval = context.getLongAttribute(<span class="string">&quot;flushInterval&quot;</span>);</span><br><span class="line">      Integer size = context.getIntAttribute(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">      <span class="keyword">boolean</span> readWrite = !context.getBooleanAttribute(<span class="string">&quot;readOnly&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">boolean</span> blocking = context.getBooleanAttribute(<span class="string">&quot;blocking&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">      Properties props = context.getChildrenAsProperties();</span><br><span class="line">      builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从上面 cache 标签的核心属性如下：</p><ul><li>type<br>缓存实现类，可选择值：PERPETUAL、LRU 等，Mybatis 中所有的缓存实现类如下：<br><img src="https://img-blog.csdnimg.cn/2019082620593518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>eviction<br>移除算法，默认为 LRU。</li><li>flushInterval<br>缓存过期时间。</li><li>size<br>缓存在内存中的缓存个数。</li><li>readOnly<br>是否是只读。</li><li>blocking<br>是否阻塞，具体实现请看 BlockingCache。</li></ul><h5 id="1-2-1-3-cacheRef"><a href="#1-2-1-3-cacheRef" class="headerlink" title="1.2.1.3 cacheRef"></a>1.2.1.3 cacheRef</h5><p><img src="https://img-blog.csdnimg.cn/20190826210042752.png" alt="在这里插入图片描述"><br>cacheRef 只有一个属性，就是 namespace，就是引用其他 namespace 中的 cache。</p><p>Cache 的创建流程就讲解到这里，同一个 Namespace 只会定义一个 Cache。二级缓存的创建是在 *Mapper.xml 文件中使用了&lt; cache/&gt;、&lt; cacheRef/&gt;标签时创建，并且会按 NameSpace 为维度，为各个 MapperStatement 传入它所属的 Namespace 的二级缓存对象。</p><p>二级缓存的查询逻辑就介绍到这里了，我们再次回成 CacheingExecutor 的查询方法：<br>CachingExecutor#query</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Cache cache = ms.getCache();    <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      flushCacheIfRequired(ms);        <span class="comment">// @2</span></span><br><span class="line">      <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ensureNoOutParams(ms, boundSql);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);      <span class="comment">// @3</span></span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;                                                              <span class="comment">// @4</span></span><br><span class="line">          list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);    <span class="comment">//@5</span></span><br><span class="line">          tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116                                                               // @6</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);  <span class="comment">//@7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 MappedStatement 的 cache 属性为空，则直接调用内部的 Executor 的查询方法。也就时如果在 *.Mapper.xm l文件中未定义&lt; cache/&gt;或&lt; cacheRef/&gt;，则 cache 属性会为空。</p><h4 id="1-2-2-一级缓存"><a href="#1-2-2-一级缓存" class="headerlink" title="1.2.2 一级缓存"></a>1.2.2 一级缓存</h4><p>Mybatis 根据 SQL 的类型共有如下3种 Executor类型，分别是 SIMPLE,  REUSE, BATCH，本文将以 SimpleExecutor为 例来对一级缓存的介绍。</p><p>BaseExecutor#query</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;   <span class="comment">// @1</span></span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      queryStack++;                                                              </span><br><span class="line">      list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;     <span class="comment">// @2</span></span><br><span class="line">      <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);   <span class="comment">// @3</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      queryStack--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">        deferredLoad.load();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// issue #601</span></span><br><span class="line">      deferredLoads.clear();</span><br><span class="line">      <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">        <span class="comment">// issue #482</span></span><br><span class="line">        clearLocalCache();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码@1：queryStack：查询栈，每次查询之前，加一，查询返回结果后减一，如果为1，表示整个会会话中没有执行的查询语句，并根据 MappedStatement 是否需要执行清除缓存，如果是查询类的请求，无需清除缓存，如果是更新类操作的MappedStatemt，每次执行之前都需要清除缓存。<br>代码@2：如果缓存中存在，直接返回缓存中的数据。<br>代码@3：如果缓存未命中，则调用 queryFromDatabase 从数据中查询。</p><p>我们顺便看一下 queryFromDatabase 方法，再来看一下一级缓存的实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   List&lt;E&gt; list;</span><br><span class="line">   localCache.putObject(key, EXECUTION_PLACEHOLDER);   <span class="comment">//@!</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);   <span class="comment">// @2</span></span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     localCache.removeObject(key);                                                            <span class="comment">// @3</span></span><br><span class="line">   &#125;</span><br><span class="line">   localCache.putObject(key, list);                                                              <span class="comment">// @4</span></span><br><span class="line">   <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">     localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> list;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>代码@1：先往本地遍历存储一个厂里，表示正在执行中。<br>代码@2：从数据中查询数据。<br>代码@3：先移除正在执行中的标记。<br>代码@4：将数据库中的值存储到一级缓存中。</p><p>可以看出一级缓存的属性为 localCache，为 Executor 的属性。如果大家看过笔者发布的这个 Mybatis 系列就能轻易得出一个结论，每一个 SQL 会话对应一个 SqlSession 对象，每一个 SqlSession 会对应一个 Executor 对象，故 Executor 级别的缓存即为Session 级别的缓存，即为 Mybatis 的一级缓存。</p><p>上面已经介绍了一二级缓存的查找与添加，在查询的时候，首先查询缓存，如果缓存未命中，则查询数据库，然后将查询到的结果存入缓存中。</p><p>下面我们来简单看看缓存的更新。</p><h2 id="2、从SQL更新流程看一二级缓存"><a href="#2、从SQL更新流程看一二级缓存" class="headerlink" title="2、从SQL更新流程看一二级缓存"></a>2、从SQL更新流程看一二级缓存</h2><p>从更新的角度，更加的是关注缓存的更新，即当数据发生变化后，如果清除对应的缓存。</p><a id="more"></a><h3 id="2-1-二级缓存"><a href="#2-1-二级缓存" class="headerlink" title="2.1 二级缓存"></a>2.1 二级缓存</h3><p>CachingExecutor#update</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameterObject)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    flushCacheIfRequired(ms);    <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">return</span> delegate.update(ms, parameterObject);  <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果有必要则刷新缓存。<br>代码@2：调用内部的 Executor，例如 SimpleExecutor。</p><p>接下来重点看一下 flushCacheIfRequired 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;      </span><br><span class="line">      tcm.clear(cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TransactionalCacheManager#clear</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">    getTransactionalCache(cache).clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TransactionalCacheManager 事务缓存管理器，其实就是对 MappedStatement 的 cache 属性进行装饰，最终调用的还是MappedStatement 的 getCache 方法得到其缓存对象然后调用 clear 方法，清空所有的缓存，即缓存的更新策略是只要namespace 的任何一条插入或更新语句执行，整个 namespace 的缓存数据将全部清空。</p><h3 id="2-2-一级缓存的更新"><a href="#2-2-一级缓存的更新" class="headerlink" title="2.2 一级缓存的更新"></a>2.2 一级缓存的更新</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing an update&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  clearLocalCache();</span><br><span class="line">  <span class="keyword">return</span> doUpdate(ms, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其更新策略与二级缓存维护的一样。</p><p>一二级缓存的的新增、查询、更新就介绍到这里了，接下来对其进行一个总结。</p><h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><h3 id="3-1-一二级缓存作用序列图"><a href="#3-1-一二级缓存作用序列图" class="headerlink" title="3.1 一二级缓存作用序列图"></a>3.1 一二级缓存作用序列图</h3><p>Mybatis 一二级缓存时序图如下：<br><img src="https://img-blog.csdnimg.cn/20190826210834511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-2-如何使用二级缓存"><a href="#3-2-如何使用二级缓存" class="headerlink" title="3.2 如何使用二级缓存"></a>3.2 如何使用二级缓存</h3><p>1、在mybatis-config.xml中将cacheEnable设置为true。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不过该值默认为true。</p><p>2、在需要缓存的表操作，对应的 Dao 的配置文件中，例如 *Mapper.xml 文件中使用 cache、或 cacheRef 标签来定义缓存。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.winterchen.dao.UserDao&quot;</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.winterchen.model.UserDomain&quot;</span>&gt;</span></span><br><span class="line">    //省略</span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.winterchen.model.UserDomain&quot;</span>&gt;</span></span><br><span class="line">      //省略</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;lru&quot;</span> <span class="attr">readOnly</span>=<span class="string">&quot;true&quot;</span> <span class="attr">flushInterval</span>=<span class="string">&quot;3600000&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样就定义了一个 Cache，其 namespace 为 com.winterchen.dao.UserDao。其中 flushInterval 定义该 cache 定时清除的时间间隔，单位为 ms。</p><p>如果一个表的更新操作、新增操作位于不同的 Mapper.xml 文件中，如果对一个表的操作的 Cache 定义在不同的文件，则缓存数据则会出现不一致的情况，因为 Cache 的更新逻辑是，在一个 Namespace 中，如果有更新、插入语句的执行，则会清除该 namespace 对应的 cache 里面的所有缓存。那怎么来处理这种场景呢？cacheRef 闪亮登场。</p><p>如果一个 Mapper.xml 文件需要引入定义在别的 Mapper.xml 文件中定义的 cache,则使用 cacheRef，示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cacheRef</span> &quot;<span class="attr">namespace</span>&quot; = <span class="string">&quot;com.winterchen.dao.UserDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>一级缓存默认是开启的，也无法关闭。</p><p>缓存的介绍就介绍到这里。如果本文对您有所帮助，麻烦点一下赞，谢谢。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;Mybatis 与 Hibernate 一样，支持一二级缓存。一级缓存指的是 Session 级别的缓存，即在一个会话中多次执行同一条 SQL 语句并且参数相同，则后面的查询将不会发送到数据库，直接从 Session 缓存中获取。二级缓存，指的是 SessionFactory 级别的缓存，即不同的会话可以共享。&lt;/p&gt;
&lt;p&gt;缓存，通常涉及到缓存的写、读、过期(更新缓存)等几个方面，请带着这些问题一起来探究Mybatis关于缓存的实现原理吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;提出问题：缓存的查询顺序，是先查一级缓存还是二级缓存？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文以SQL查询与更新两个流程来揭开Mybatis缓存实现的细节。&lt;/p&gt;
&lt;h2 id=&quot;1、从-SQL-查询流程看一二级缓存&quot;&gt;&lt;a href=&quot;#1、从-SQL-查询流程看一二级缓存&quot; class=&quot;headerlink&quot; title=&quot;1、从 SQL 查询流程看一二级缓存&quot;&gt;&lt;/a&gt;1、从 SQL 查询流程看一二级缓存&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;温馨提示，本文不会详细介绍详细的 SQL 执行流程，如果对其感兴趣，可以查阅笔者的另外一篇文章：&lt;a href=&quot;https://blog.csdn.net/prestigeding/article/details/90647674&quot;&gt;源码分析Mybatis SQL执行流程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-1-创建Executor&quot;&gt;&lt;a href=&quot;#1-1-创建Executor&quot; class=&quot;headerlink&quot; title=&quot;1.1 创建Executor&quot;&gt;&lt;/a&gt;1.1 创建Executor&lt;/h3&gt;&lt;p&gt;Configuration#newExecutor&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Executor &lt;span class=&quot;title&quot;&gt;newExecutor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Transaction transaction, ExecutorType executorType)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	executorType = executorType == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? defaultExecutorType : executorType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    executorType = executorType == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? ExecutorType.SIMPLE : executorType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Executor executor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ExecutorType.BATCH == executorType) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BatchExecutor(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ExecutorType.REUSE == executorType) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ReuseExecutor(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SimpleExecutor(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cacheEnabled) &amp;#123;                                                           &lt;span class=&quot;comment&quot;&gt;// @1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CachingExecutor(executor);                 &lt;span class=&quot;comment&quot;&gt;// @2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    executor = (Executor) interceptorChain.pluginAll(executor);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; executor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码@1：如果 cacheEnabled 为 true，表示开启缓存机制，缓存的实现类为 CachingExecutor，这里使用了经典的装饰模式，处理了缓存的相关逻辑后，委托给的具体的 Executor 执行。&lt;/p&gt;
&lt;p&gt;cacheEnable 在实际的使用中通过在 mybatis-config.xml 文件中指定，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;settings&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;setting&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;cacheEnabled&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;settings&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该值默认为true。&lt;/p&gt;
&lt;h3 id=&quot;1-2-CachingExecutor-query&quot;&gt;&lt;a href=&quot;#1-2-CachingExecutor-query&quot; class=&quot;headerlink&quot; title=&quot;1.2 CachingExecutor#query&quot;&gt;&lt;/a&gt;1.2 CachingExecutor#query&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &amp;lt;E&amp;gt; &lt;span class=&quot;function&quot;&gt;List&amp;lt;E&amp;gt; &lt;span class=&quot;title&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; SQLException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BoundSql boundSql = ms.getBoundSql(parameterObject);  &lt;span class=&quot;comment&quot;&gt;// @1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);   &lt;span class=&quot;comment&quot;&gt;// @2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);       &lt;span class=&quot;comment&quot;&gt;// @3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码@1：根据参数生成SQL语句。&lt;/p&gt;
&lt;p&gt;代码@2：根据 MappedStatement、参数、分页参数、SQL 生成缓存 Key。&lt;/p&gt;
&lt;p&gt;代码@3：调用6个参数的 query 方法。&lt;/p&gt;
&lt;p&gt;缓存 Key 的创建比较简单，本文就只贴出代码，大家一目了然,大家重点关注组成缓存Key的要素。&lt;br&gt;BaseExecute#createCacheKey&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; CacheKey &lt;span class=&quot;title&quot;&gt;createCacheKey&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (closed) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ExecutorException(&lt;span class=&quot;string&quot;&gt;&amp;quot;Executor was closed.&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CacheKey cacheKey = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CacheKey();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cacheKey.update(ms.getId());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cacheKey.update(rowBounds.getOffset());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cacheKey.update(rowBounds.getLimit());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cacheKey.update(boundSql.getSql());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  List&amp;lt;ParameterMapping&amp;gt; parameterMappings = boundSql.getParameterMappings();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// mimic DefaultParameterHandler logic&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (ParameterMapping parameterMapping : parameterMappings) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (parameterMapping.getMode() != ParameterMode.OUT) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Object value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      String propertyName = parameterMapping.getProperty();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (boundSql.hasAdditionalParameter(propertyName)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        value = boundSql.getAdditionalParameter(propertyName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (parameterObject == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        value = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        value = parameterObject;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MetaObject metaObject = configuration.newMetaObject(parameterObject);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        value = metaObject.getValue(propertyName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      cacheKey.update(value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (configuration.getEnvironment() != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// issue #176&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cacheKey.update(configuration.getEnvironment().getId());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; cacheKey;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接下来重点看CachingExecutor的另外一个query方法。&lt;/p&gt;
&lt;p&gt;CachingExecutor#query&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &amp;lt;E&amp;gt; &lt;span class=&quot;function&quot;&gt;List&amp;lt;E&amp;gt; &lt;span class=&quot;title&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; SQLException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Cache cache = ms.getCache();    &lt;span class=&quot;comment&quot;&gt;// @1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cache != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      flushCacheIfRequired(ms);        &lt;span class=&quot;comment&quot;&gt;// @2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ms.isUseCache() &amp;amp;&amp;amp; resultHandler == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ensureNoOutParams(ms, boundSql);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;meta&quot;&gt;@SuppressWarnings(&amp;quot;unchecked&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;E&amp;gt; list = (List&amp;lt;E&amp;gt;) tcm.getObject(cache, key);      &lt;span class=&quot;comment&quot;&gt;// @3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (list == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;                                                              &lt;span class=&quot;comment&quot;&gt;// @4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          list = delegate.&amp;lt;E&amp;gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);    &lt;span class=&quot;comment&quot;&gt;//@5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          tcm.putObject(cache, key, list); &lt;span class=&quot;comment&quot;&gt;// issue #578 and #116                                                               // @6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; list;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; delegate.&amp;lt;E&amp;gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);  &lt;span class=&quot;comment&quot;&gt;//@7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码@1：获取 MappedStatement 中的 Cache cache 属性。&lt;br&gt;代码@2：如果不为空，则尝试从缓存中获取，否则直接委托给具体的执行器执行，例如 SimpleExecutor (@7)。&lt;br&gt;代码@3：尝试从缓存中根据缓存 Key 查找。&lt;br&gt;代码@4：如果从缓存中获取的值不为空，则直接返回缓存中的值，否则先从数据库查询@5，将查询结果更新到缓存中。&lt;/p&gt;
&lt;p&gt;这里的缓存即 MappedStatement 中的 Cache 对象是一级缓存还是二级缓存？通常在 ORM 类框架中，Session 级别的缓存为一级缓存，即会话结束后就会失效，显然这里不会随着 Session 的失效而失效，因为 Cache 对象是存储在于 MappedStatement 对象中的，每一个 MappedStatement 对象代表一个 Dao(Mapper) 中的一个方法，即代表一条对应的 SQL 语句，是一个全局的概念。&lt;/p&gt;
&lt;p&gt;相信大家也会觉得，想继续深入了解 CachingExecutor 中使用的 Cache 是一级缓存还是二级缓存，了解 Cache 对象的创建至关重要。关于 MappedStatement 的创建流程，建议查阅笔者的另外一篇博文：&lt;a href=&quot;https://blog.csdn.net/prestigeding/article/details/90488395&quot;&gt;源码分析Mybatis MappedStatement的创建流程&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本文只会关注 MappedStatement 对象流程中关于于缓存相关的部分。&lt;/p&gt;
&lt;p&gt;接下来将按照先二级缓存，再一级缓存的思路进行讲解。&lt;/p&gt;
&lt;h4 id=&quot;1-2-1-二级缓存&quot;&gt;&lt;a href=&quot;#1-2-1-二级缓存&quot; class=&quot;headerlink&quot; title=&quot;1.2.1 二级缓存&quot;&gt;&lt;/a&gt;1.2.1 二级缓存&lt;/h4&gt;&lt;h5 id=&quot;1-2-1-1-MappedStatement-cache属性创建机制&quot;&gt;&lt;a href=&quot;#1-2-1-1-MappedStatement-cache属性创建机制&quot; class=&quot;headerlink&quot; title=&quot;1.2.1.1 MappedStatement#cache属性创建机制&quot;&gt;&lt;/a&gt;1.2.1.1 MappedStatement#cache属性创建机制&lt;/h5&gt;&lt;p&gt;从上面看，如果 cacheEnable 为 true 并且 MappedStatement 对象的 cache 属性不为空，则能使用二级缓存。&lt;/p&gt;
&lt;p&gt;我们可以看到 MappedStatement 对象的 cache 属性赋值的地方为：MapperBuilderAssistant#addMappedStatement，从该方法的调用链可以得知是在解析 Mapper 定义的时候就会创建。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190826205429651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;使用的 cache 属性为 MapperBuilderAssistant 的 currentCache,我们跟踪一下该属性的赋值方法：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Cache &lt;span class=&quot;title&quot;&gt;useCacheRef&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String namespace)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其调用链如下：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019082620552683.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;可以看出是在解析 cacheRef 标签，即在解析 Mapper.xml 文件中的 cacheRef 标签时，即二级缓存的使用和 cacheRef 标签离不开关系，并且特别注意一点，其参数为 namespace，即每一个 namespace 对应一个 Cache 对象，在 Mybatis 的方法中，通常namespace 对一个 Mapper.java 对象，对应对数据库一张表的更新、新增操作。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Cache useNewCache&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其调用链如下图所示：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190826205659301.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;在解析 Mapper.xml 文件中的 cache 标签时被调用。&lt;/p&gt;
&lt;h5 id=&quot;1-2-1-2-cache标签解析&quot;&gt;&lt;a href=&quot;#1-2-1-2-cache标签解析&quot; class=&quot;headerlink&quot; title=&quot;1.2.1.2 cache标签解析&quot;&gt;&lt;/a&gt;1.2.1.2 cache标签解析&lt;/h5&gt;&lt;p&gt;接下来我们根据 cache 标签简单看一下 cache 标签的解析，下面以 xml 配置方式为例展开，基于注解的解析，其原理类似，其代码 XMLMapperBuilder 的 cacheElement 方法。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;cacheElement&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(XNode context)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (context != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      String type = context.getStringAttribute(&lt;span class=&quot;string&quot;&gt;&amp;quot;type&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;PERPETUAL&amp;quot;&lt;/span&gt;);                                                      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Class&amp;lt;? extends Cache&amp;gt; typeClass = typeAliasRegistry.resolveAlias(type);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      String eviction = context.getStringAttribute(&lt;span class=&quot;string&quot;&gt;&amp;quot;eviction&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;LRU&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Class&amp;lt;? extends Cache&amp;gt; evictionClass = typeAliasRegistry.resolveAlias(eviction);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Long flushInterval = context.getLongAttribute(&lt;span class=&quot;string&quot;&gt;&amp;quot;flushInterval&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Integer size = context.getIntAttribute(&lt;span class=&quot;string&quot;&gt;&amp;quot;size&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; readWrite = !context.getBooleanAttribute(&lt;span class=&quot;string&quot;&gt;&amp;quot;readOnly&amp;quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; blocking = context.getBooleanAttribute(&lt;span class=&quot;string&quot;&gt;&amp;quot;blocking&amp;quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Properties props = context.getChildrenAsProperties();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从上面 cache 标签的核心属性如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;type&lt;br&gt;缓存实现类，可选择值：PERPETUAL、LRU 等，Mybatis 中所有的缓存实现类如下：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019082620593518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/li&gt;
&lt;li&gt;eviction&lt;br&gt;移除算法，默认为 LRU。&lt;/li&gt;
&lt;li&gt;flushInterval&lt;br&gt;缓存过期时间。&lt;/li&gt;
&lt;li&gt;size&lt;br&gt;缓存在内存中的缓存个数。&lt;/li&gt;
&lt;li&gt;readOnly&lt;br&gt;是否是只读。&lt;/li&gt;
&lt;li&gt;blocking&lt;br&gt;是否阻塞，具体实现请看 BlockingCache。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;1-2-1-3-cacheRef&quot;&gt;&lt;a href=&quot;#1-2-1-3-cacheRef&quot; class=&quot;headerlink&quot; title=&quot;1.2.1.3 cacheRef&quot;&gt;&lt;/a&gt;1.2.1.3 cacheRef&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190826210042752.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;cacheRef 只有一个属性，就是 namespace，就是引用其他 namespace 中的 cache。&lt;/p&gt;
&lt;p&gt;Cache 的创建流程就讲解到这里，同一个 Namespace 只会定义一个 Cache。二级缓存的创建是在 *Mapper.xml 文件中使用了&amp;lt; cache/&amp;gt;、&amp;lt; cacheRef/&amp;gt;标签时创建，并且会按 NameSpace 为维度，为各个 MapperStatement 传入它所属的 Namespace 的二级缓存对象。&lt;/p&gt;
&lt;p&gt;二级缓存的查询逻辑就介绍到这里了，我们再次回成 CacheingExecutor 的查询方法：&lt;br&gt;CachingExecutor#query&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &amp;lt;E&amp;gt; &lt;span class=&quot;function&quot;&gt;List&amp;lt;E&amp;gt; &lt;span class=&quot;title&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; SQLException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Cache cache = ms.getCache();    &lt;span class=&quot;comment&quot;&gt;// @1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cache != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      flushCacheIfRequired(ms);        &lt;span class=&quot;comment&quot;&gt;// @2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ms.isUseCache() &amp;amp;&amp;amp; resultHandler == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ensureNoOutParams(ms, boundSql);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;meta&quot;&gt;@SuppressWarnings(&amp;quot;unchecked&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;E&amp;gt; list = (List&amp;lt;E&amp;gt;) tcm.getObject(cache, key);      &lt;span class=&quot;comment&quot;&gt;// @3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (list == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;                                                              &lt;span class=&quot;comment&quot;&gt;// @4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          list = delegate.&amp;lt;E&amp;gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);    &lt;span class=&quot;comment&quot;&gt;//@5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          tcm.putObject(cache, key, list); &lt;span class=&quot;comment&quot;&gt;// issue #578 and #116                                                               // @6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; list;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; delegate.&amp;lt;E&amp;gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);  &lt;span class=&quot;comment&quot;&gt;//@7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果 MappedStatement 的 cache 属性为空，则直接调用内部的 Executor 的查询方法。也就时如果在 *.Mapper.xm l文件中未定义&amp;lt; cache/&amp;gt;或&amp;lt; cacheRef/&amp;gt;，则 cache 属性会为空。&lt;/p&gt;
&lt;h4 id=&quot;1-2-2-一级缓存&quot;&gt;&lt;a href=&quot;#1-2-2-一级缓存&quot; class=&quot;headerlink&quot; title=&quot;1.2.2 一级缓存&quot;&gt;&lt;/a&gt;1.2.2 一级缓存&lt;/h4&gt;&lt;p&gt;Mybatis 根据 SQL 的类型共有如下3种 Executor类型，分别是 SIMPLE,  REUSE, BATCH，本文将以 SimpleExecutor为 例来对一级缓存的介绍。&lt;/p&gt;
&lt;p&gt;BaseExecutor#query&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &amp;lt;E&amp;gt; &lt;span class=&quot;function&quot;&gt;List&amp;lt;E&amp;gt; &lt;span class=&quot;title&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; SQLException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ErrorContext.instance().resource(ms.getResource()).activity(&lt;span class=&quot;string&quot;&gt;&amp;quot;executing a query&amp;quot;&lt;/span&gt;).object(ms.getId());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (closed) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ExecutorException(&lt;span class=&quot;string&quot;&gt;&amp;quot;Executor was closed.&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (queryStack == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; ms.isFlushCacheRequired()) &amp;#123;   &lt;span class=&quot;comment&quot;&gt;// @1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      clearLocalCache();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List&amp;lt;E&amp;gt; list;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      queryStack++;                                                              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      list = resultHandler == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? (List&amp;lt;E&amp;gt;) localCache.getObject(key) : &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;     &lt;span class=&quot;comment&quot;&gt;// @2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (list != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);   &lt;span class=&quot;comment&quot;&gt;// @3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      queryStack--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (queryStack == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (DeferredLoad deferredLoad : deferredLoads) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        deferredLoad.load();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// issue #601&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      deferredLoads.clear();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// issue #482&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        clearLocalCache();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; list;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码@1：queryStack：查询栈，每次查询之前，加一，查询返回结果后减一，如果为1，表示整个会会话中没有执行的查询语句，并根据 MappedStatement 是否需要执行清除缓存，如果是查询类的请求，无需清除缓存，如果是更新类操作的MappedStatemt，每次执行之前都需要清除缓存。&lt;br&gt;代码@2：如果缓存中存在，直接返回缓存中的数据。&lt;br&gt;代码@3：如果缓存未命中，则调用 queryFromDatabase 从数据中查询。&lt;/p&gt;
&lt;p&gt;我们顺便看一下 queryFromDatabase 方法，再来看一下一级缓存的实现类。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &amp;lt;E&amp;gt; &lt;span class=&quot;function&quot;&gt;List&amp;lt;E&amp;gt; &lt;span class=&quot;title&quot;&gt;queryFromDatabase&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; SQLException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   List&amp;lt;E&amp;gt; list;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   localCache.putObject(key, EXECUTION_PLACEHOLDER);   &lt;span class=&quot;comment&quot;&gt;//@!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);   &lt;span class=&quot;comment&quot;&gt;// @2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     localCache.removeObject(key);                                                            &lt;span class=&quot;comment&quot;&gt;// @3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   localCache.putObject(key, list);                                                              &lt;span class=&quot;comment&quot;&gt;// @4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ms.getStatementType() == StatementType.CALLABLE) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     localOutputParameterCache.putObject(key, parameter);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; list;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码@1：先往本地遍历存储一个厂里，表示正在执行中。&lt;br&gt;代码@2：从数据中查询数据。&lt;br&gt;代码@3：先移除正在执行中的标记。&lt;br&gt;代码@4：将数据库中的值存储到一级缓存中。&lt;/p&gt;
&lt;p&gt;可以看出一级缓存的属性为 localCache，为 Executor 的属性。如果大家看过笔者发布的这个 Mybatis 系列就能轻易得出一个结论，每一个 SQL 会话对应一个 SqlSession 对象，每一个 SqlSession 会对应一个 Executor 对象，故 Executor 级别的缓存即为Session 级别的缓存，即为 Mybatis 的一级缓存。&lt;/p&gt;
&lt;p&gt;上面已经介绍了一二级缓存的查找与添加，在查询的时候，首先查询缓存，如果缓存未命中，则查询数据库，然后将查询到的结果存入缓存中。&lt;/p&gt;
&lt;p&gt;下面我们来简单看看缓存的更新。&lt;/p&gt;
&lt;h2 id=&quot;2、从SQL更新流程看一二级缓存&quot;&gt;&lt;a href=&quot;#2、从SQL更新流程看一二级缓存&quot; class=&quot;headerlink&quot; title=&quot;2、从SQL更新流程看一二级缓存&quot;&gt;&lt;/a&gt;2、从SQL更新流程看一二级缓存&lt;/h2&gt;&lt;p&gt;从更新的角度，更加的是关注缓存的更新，即当数据发生变化后，如果清除对应的缓存。&lt;/p&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://example.com/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://example.com/tags/mybatis/"/>
    
    <category term="一级缓存" scheme="http://example.com/tags/%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    
    <category term="二级缓存" scheme="http://example.com/tags/%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>源码分析Mybatis插件(Plugin)机制与实战</title>
    <link href="http://example.com/posts/3e30e205.html"/>
    <id>http://example.com/posts/3e30e205.html</id>
    <published>2020-12-09T15:07:35.000Z</published>
    <updated>2020-12-09T15:07:05.627Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p>温馨提示：本文也是以提问式阅读与探究源码的技巧展示。</p></blockquote><h2 id="1、回顾"><a href="#1、回顾" class="headerlink" title="1、回顾"></a>1、回顾</h2><p>从前面的文章我们已经知道，Mybatis在执行SQL语句的扩展点为Executor、StatementHandler、ParameterHandler与ResultSetHandler，我们本节将以Executor为入口，向大家展示Mybatis插件的扩展机制。</p><p>我们先来看回顾一下Mybatis Executor的创建入口。</p><h3 id="1-1-Configuration-newExecutor"><a href="#1-1-Configuration-newExecutor" class="headerlink" title="1.1 Configuration#newExecutor"></a>1.1 Configuration#newExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">  Executor executor;</span><br><span class="line">  <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">  &#125;</span><br><span class="line">  executor = (Executor) interceptorChain.pluginAll(executor);   <span class="comment">// @1</span></span><br><span class="line">  <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1,：使用InterceptorChain.pluginAll(executor)进行拆件化处理。</p><p>思考：使用该方法调用后，会返回一个什么对象呢？如何自定义拆件，自定义插件如何执行呢？</p><p>那接下来我们带着上述疑问，从InterceptorChain类开始进行深入学习。</p><h2 id="2、InterceptorChain"><a href="#2、InterceptorChain" class="headerlink" title="2、InterceptorChain"></a>2、InterceptorChain</h2><p>从名字上看其大意为拦截器链。</p><h3 id="2-1-类图"><a href="#2-1-类图" class="headerlink" title="2.1 类图"></a>2.1 类图</h3><p><img src="https://img-blog.csdnimg.cn/20190530205753805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>InterceptorChain<br>拦截器链，其内部维护一个interceptors,表示拦截器链中所有的拦截器，并提供增加或获取拦截器链的方法，下面会重点分析pluginAll方法。</li><li>Interceptor<br>拦截器接口，用户自定义的拦截器需要实现该接口。</li><li>Invocation<br>拦截器执行时的上下文环境，其实就是目标方法的调用信息，包含目标对象、调用的方法信息、参数信息。其中包含一个非常重要的方法：proceed。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>该方法的主要目的就是进行处理链的传播，执行完拦截器的方法后，最终需要调用目标方法的invoke方法。</li></ul><p>记下来中先重点分析一下InterceptorChain方法的pluginAll方法，因为从开头也知道,Mybatis在创建对象时，是调用该方法，完成目标对象的包装。</p><a id="more"></a><h3 id="2-2-核心方法一览"><a href="#2-2-核心方法一览" class="headerlink" title="2.2 核心方法一览"></a>2.2 核心方法一览</h3><h4 id="2-2-1-pluginAll"><a href="#2-2-1-pluginAll" class="headerlink" title="2.2.1 pluginAll"></a>2.2.1 pluginAll</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;   <span class="comment">// @1</span></span><br><span class="line">  <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;   <span class="comment">// @2</span></span><br><span class="line">    target = interceptor.plugin(target);         </span><br><span class="line">  <span class="comment">// @3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：目标对象，需要被代理的对象。</p><p>代码@2：遍历InterceptorChain的拦截器链，分别调用Intercpetor对象的Plugin进行拦截(@3)。</p><p>那接下来有三个疑问？<br>问题1：InterceptorChain中的interceptors是从什么时候初始化的呢，即拦截链中的拦截器从何而来。<br>问题2：从前面也得知，无论是创建Executor，还是创建StatementHandler等，都是调用InterceptorChain#pluginAll方法，那是不是拦截器中的拦截器都会作用与目标对象，这应该是有问题的，该如何处理？<br>问题3：代理对象是如何创建的。</p><h4 id="2-2-1-addInterceptor"><a href="#2-2-1-addInterceptor" class="headerlink" title="2.2.1 addInterceptor"></a>2.2.1 addInterceptor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">  interceptors.add(interceptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想知道interceptors是如何初始化的，我们只需要查看该方法的调用链即可。</p><p>一路跟踪到源头，我们会发现在初始化SqlSessionFactory时，会解析一个标签plugin，就可以得知，会在SqlSessionFacotry的一个属性中配置所有的拦截器。<br>具体配置示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;shardingDataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath*:META-INF/mybatis/mappers/OrderMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;plugins&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;teneantInteceptor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.demo.inteceptor.TenaInteceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>问题1已经解决。但后面两个问题似乎没有什么突破口。由于目前所涉及的三个类，显然不足以给我们提供答案，我们先将目光移到InterceptorChain所在包中的其他类，看看其他类的职责如何。</p><h2 id="3、Intercepts与Signature"><a href="#3、Intercepts与Signature" class="headerlink" title="3、Intercepts与Signature"></a>3、Intercepts与Signature</h2><p>在org.apache.ibatis.plugin中存在如下两个注解类：Intercepts与Signature，从字面意思就是用来配置拦截的方法信息。<br><img src="https://img-blog.csdnimg.cn/2019053021040719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>Siganature注解的属性说明如下：<ul><li>Class&lt;?&gt; type ：需要拦截目标对象的类。</li><li>String method：需要拦截目标类的方法名。</li><li>Class&lt;?&gt;[] args：需要拦截目标类的方法名的参数类型签名。</li></ul></li></ul><p>备注：至于如何得知上述字段的含义，请看下文的Plugin#getSignatureMap方法。</p><p>但另外一个类型Plugin类确引起了我的注意。接下来我们将重点分析Plugin方法。</p><h2 id="4、Plugin详解"><a href="#4、Plugin详解" class="headerlink" title="4、Plugin详解"></a>4、Plugin详解</h2><h3 id="4-1-Plugin类图"><a href="#4-1-Plugin类图" class="headerlink" title="4.1 Plugin类图"></a>4.1 Plugin类图</h3><p><img src="https://img-blog.csdnimg.cn/20190530210628459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其中InvocationHandler为JDK的动态代理机制中的事件执行器，我们可以隐约阈值代理对象的生成将基于JDK内置的动态代理机制。</p><p>Plugin的核心属性如下：</p><ul><li>Object target<br>目标对象。</li><li>Interceptor interceptor<br>拦截器对象。</li><li>Map&lt;Class&lt;?&gt;, Set&lt; Method&gt;&gt; signatureMap<br>拦截器中的签名映射。</li></ul><h2 id="4-2-构造函数"><a href="#4-2-构造函数" class="headerlink" title="4.2  构造函数"></a>4.2  构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Plugin</span><span class="params">(Object target, Interceptor interceptor, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    <span class="keyword">this</span>.interceptor = interceptor;</span><br><span class="line">    <span class="keyword">this</span>.signatureMap = signatureMap;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注意：其构造函数为私有的，那如何构建Plugin呢，其构造方法为Plugin的镜头方法wrap中被调用。</p><h3 id="4-3-核心方法详解"><a href="#4-3-核心方法详解" class="headerlink" title="4.3 核心方法详解"></a>4.3 核心方法详解</h3><h4 id="4-3-1-wrap"><a href="#4-3-1-wrap" class="headerlink" title="4.3.1 wrap"></a>4.3.1 wrap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">  Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);  <span class="comment">// @1</span></span><br><span class="line">  Class&lt;?&gt; type = target.getClass();   </span><br><span class="line">  Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);   <span class="comment">// @2</span></span><br><span class="line">  <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(    <span class="comment">// @3</span></span><br><span class="line">        type.getClassLoader(),</span><br><span class="line">        interfaces,</span><br><span class="line">        <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：获取待包装的Interceptor的方法签名映射表，稍后详细分析。</p><p>代码@2：获取需要代理的对象的Class上声明的所有接口。</p><p>代码@3：使用JDK内置的Proxy创建代理对象。Proxy创建代理对象的方法声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span>，</span></span><br></pre></td></tr></table></figure><p>注意其事件处理器为Plugin，故在动态运行过程中会执行Plugin的invoker方法。</p><p>在进入Plugin#invoker方法学习之前，我们先重点查看一下getSignatureMap、getAllInterfaces的实现。</p><h4 id="4-3-2-getSignatureMap"><a href="#4-3-2-getSignatureMap" class="headerlink" title="4.3.2 getSignatureMap"></a>4.3.2 getSignatureMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; getSignatureMap(Interceptor interceptor) &#123;</span><br><span class="line">  Intercepts interceptsAnnotation = interceptor.getClass().getAnnotation(Intercepts.class);  <span class="comment">// @1</span></span><br><span class="line">  <span class="keyword">if</span> (interceptsAnnotation == <span class="keyword">null</span>) &#123; <span class="comment">// issue #251                                          // @2</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> PluginException(<span class="string">&quot;No @Intercepts annotation was found in interceptor &quot;</span> + interceptor.getClass().getName());      </span><br><span class="line">  &#125;</span><br><span class="line">  Signature[] sigs = interceptsAnnotation.value();   <span class="comment">// @3</span></span><br><span class="line">  Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;(); </span><br><span class="line">  <span class="keyword">for</span> (Signature sig : sigs) &#123;</span><br><span class="line">    Set&lt;Method&gt; methods = signatureMap.get(sig.type());</span><br><span class="line">    <span class="keyword">if</span> (methods == <span class="keyword">null</span>) &#123;</span><br><span class="line">      methods = <span class="keyword">new</span> HashSet&lt;Method&gt;();</span><br><span class="line">      signatureMap.put(sig.type(), methods);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Method method = sig.type().getMethod(sig.method(), sig.args());    </span><br><span class="line">      methods.add(method);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> PluginException(<span class="string">&quot;Could not find method on &quot;</span> + sig.type() + <span class="string">&quot; named &quot;</span> + sig.method() + <span class="string">&quot;. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> signatureMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先从Interceptor的类上获取Intercepts注解。</p><p>代码@2：如果Interceptor的类上没有定义Intercepts注解，则抛出异常，说明我们在自定义插件时，必须要有Intercepts注解。</p><p>代码@3：解析Interceptor的values属性（Signature[]）数组，然后存入HashMap&lt;Class&lt;?&gt;, Set&lt; Method&gt;&gt;容器内。</p><blockquote><p>温馨提示：从这里可以得知：自定义的插件必须定义Intercepts注解，其注解的value值为Signature。</p></blockquote><h4 id="4-3-3-getAllInterfaces"><a href="#4-3-3-getAllInterfaces" class="headerlink" title="4.3.3 getAllInterfaces"></a>4.3.3 getAllInterfaces</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt;[] getAllInterfaces(Class&lt;?&gt; type, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) &#123;</span><br><span class="line">  Set&lt;Class&lt;?&gt;&gt; interfaces = <span class="keyword">new</span> HashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">  <span class="keyword">while</span> (type != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; c : type.getInterfaces()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (signatureMap.containsKey(c)) &#123;</span><br><span class="line">        interfaces.add(c);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    type = type.getSuperclass();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> interfaces.toArray(<span class="keyword">new</span> Class&lt;?&gt;[interfaces.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的实现比较简单，并不是获取目标对象所实现的所有接口，而是返回需要拦截的方法所包括的接口。</p><h4 id="4-3-4-invoke"><a href="#4-3-4-invoke" class="headerlink" title="4.3.4 invoke"></a>4.3.4 invoke</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123; <span class="comment">// @1</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">    <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.contains(method)) &#123;   <span class="comment">// @2</span></span><br><span class="line">      <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));   <span class="comment">// @3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> method.invoke(target, args);                           <span class="comment">// @4</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先对其参数列表做一个简单的说明：</p><ul><li>Object proxy 当前的代理对象</li><li>Method method 当前执行的方法</li><li>Object[] args 当前执行方法的参数</li></ul><p>代码@2：获取当前执行方法所属的类，并获取需要被拦截的方法集合。</p><p>代码@3：如果需被拦截的方法集合包含当前执行的方法，则执行拦截器的interceptor方法。</p><p>代码@4：如果不是，则直接调用目标方法的Invoke方法。</p><p>从该方法可以看出Interceptor接口的intercept方法就是拦截器自身需要实现的逻辑，其参数为Invocation，在该方法的结束，需要调用invocation#proceed()方法，进行拦截器链的传播。</p><p>从目前的学习中，我们已经了解了Plugin.wrap方法就是生成带来带来类的唯一入口，那该方法在什么地方调用呢？从代码类库中没有找到该方法的调用链，说明该方法是供用户调用的。</p><p>再看InterceptorChain方法的pluginAll方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;   <span class="comment">// @1</span></span><br><span class="line">  <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;   <span class="comment">// @2</span></span><br><span class="line">    target = interceptor.plugin(target);           <span class="comment">// @3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会遍历用户定义的插件实现类（Interceptor），并调用Interceptor的plugin方法，对target进行拆件化处理，即我们在实现自定义的Interceptor方法时，在plugin中需要根据自己的逻辑，对目标对象进行包装（代理），创建代理对象，那我们就可以在该方法中使用Plugin#wrap来创建代理类。</p><p>接下来我们再来用序列图来对上述源码分析做一个总结：<br><img src="https://img-blog.csdnimg.cn/2019053021182314.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>看到这里，大家是否对上面提出的3个问题都已经有了自己的答案了。</p><p>问题1：InterceptorChain中的interceptors是从什么时候初始化的呢，即拦截链中的拦截器从何而来。<br>答：在初始化SqlSesstionFactory的时候，会解析属性plugins属性，会加载所有的拦截器到InterceptorChain中。</p><p>问题2：从前面也得知，无论是创建Executor，还是创建StatementHandler等，都是调用InterceptorChain#pluginAll方法，那是不是拦截器中的拦截器都会作用与目标对象，这应该是有问题的，该如何处理？</p><p>答案是在各自订阅的Interceptor#plugin方法中，我们可以根据传入的目标对象，是否是该拦截器关注的，如果不关注，则直接返回目标对象，如果关注，则使用Plugin#wrap方法创建代理对象。</p><p>问题3：代理对象是如何创建的？<br>代理对象是使用JDK的动态代理机制创建，使用Plugin#wrap方法创建。</p><h2 id="5、实践"><a href="#5、实践" class="headerlink" title="5、实践"></a>5、实践</h2><p>实践是检验真理的唯一标准，那到底如何使用Mybatis的插件机制呢？<br>创建自定义的拦截器Interceptor,实现Interceptor接口。<br>1）实现plugin方法，在该方法中决定是否需要创建代理对象，如果创建，使用Plugin#wrap方法创建。<br>2）实现interceptor方法，该方法中定义拦截器的逻辑，并且在最后请调用invocation.proceed()方法传递拦截器链。<br>3）使用Intercepts注解，定义需要拦截目标对象的方法签名，支持多个。<br>将实现的Interceptor在定义SqlSessionFactory的配置中，放入plugins属性。</p><p>最后给出一个Mybatis Plugin插件机制使用案例：基于Mycat+Mybatis的多租户方案：<a href="https://blog.csdn.net/prestigeding/article/details/52662426">基于Mybatis与Mycat的多租户方式，通过Mybatis的插件机制，动态改写SQL语句来实现多租户</a></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;温馨提示：本文也是以提问式阅读与探究源码的技巧展示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1、回顾&quot;&gt;&lt;a href=&quot;#1、回顾&quot; class=&quot;headerlink&quot; title=&quot;1、回顾&quot;&gt;&lt;/a&gt;1、回顾&lt;/h2&gt;&lt;p&gt;从前面的文章我们已经知道，Mybatis在执行SQL语句的扩展点为Executor、StatementHandler、ParameterHandler与ResultSetHandler，我们本节将以Executor为入口，向大家展示Mybatis插件的扩展机制。&lt;/p&gt;
&lt;p&gt;我们先来看回顾一下Mybatis Executor的创建入口。&lt;/p&gt;
&lt;h3 id=&quot;1-1-Configuration-newExecutor&quot;&gt;&lt;a href=&quot;#1-1-Configuration-newExecutor&quot; class=&quot;headerlink&quot; title=&quot;1.1 Configuration#newExecutor&quot;&gt;&lt;/a&gt;1.1 Configuration#newExecutor&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Executor &lt;span class=&quot;title&quot;&gt;newExecutor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Transaction transaction, ExecutorType executorType)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  executorType = executorType == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? defaultExecutorType : executorType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  executorType = executorType == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? ExecutorType.SIMPLE : executorType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Executor executor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ExecutorType.BATCH == executorType) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BatchExecutor(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ExecutorType.REUSE == executorType) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ReuseExecutor(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SimpleExecutor(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cacheEnabled) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CachingExecutor(executor);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  executor = (Executor) interceptorChain.pluginAll(executor);   &lt;span class=&quot;comment&quot;&gt;// @1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; executor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码@1,：使用InterceptorChain.pluginAll(executor)进行拆件化处理。&lt;/p&gt;
&lt;p&gt;思考：使用该方法调用后，会返回一个什么对象呢？如何自定义拆件，自定义插件如何执行呢？&lt;/p&gt;
&lt;p&gt;那接下来我们带着上述疑问，从InterceptorChain类开始进行深入学习。&lt;/p&gt;
&lt;h2 id=&quot;2、InterceptorChain&quot;&gt;&lt;a href=&quot;#2、InterceptorChain&quot; class=&quot;headerlink&quot; title=&quot;2、InterceptorChain&quot;&gt;&lt;/a&gt;2、InterceptorChain&lt;/h2&gt;&lt;p&gt;从名字上看其大意为拦截器链。&lt;/p&gt;
&lt;h3 id=&quot;2-1-类图&quot;&gt;&lt;a href=&quot;#2-1-类图&quot; class=&quot;headerlink&quot; title=&quot;2.1 类图&quot;&gt;&lt;/a&gt;2.1 类图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190530205753805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;InterceptorChain&lt;br&gt;拦截器链，其内部维护一个interceptors,表示拦截器链中所有的拦截器，并提供增加或获取拦截器链的方法，下面会重点分析pluginAll方法。&lt;/li&gt;
&lt;li&gt;Interceptor&lt;br&gt;拦截器接口，用户自定义的拦截器需要实现该接口。&lt;/li&gt;
&lt;li&gt;Invocation&lt;br&gt;拦截器执行时的上下文环境，其实就是目标方法的调用信息，包含目标对象、调用的方法信息、参数信息。其中包含一个非常重要的方法：proceed。&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;title&quot;&gt;proceed&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InvocationTargetException, IllegalAccessException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; method.invoke(target, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
该方法的主要目的就是进行处理链的传播，执行完拦截器的方法后，最终需要调用目标方法的invoke方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记下来中先重点分析一下InterceptorChain方法的pluginAll方法，因为从开头也知道,Mybatis在创建对象时，是调用该方法，完成目标对象的包装。&lt;/p&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://example.com/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://example.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>源码解析MyBatis Sharding-Jdbc SQL语句执行流程详解</title>
    <link href="http://example.com/posts/6620f9ec.html"/>
    <id>http://example.com/posts/6620f9ec.html</id>
    <published>2020-12-09T15:04:35.000Z</published>
    <updated>2020-12-09T15:04:31.898Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文将详细介绍Mybatis SQL语句执行的全流程，本文与上篇具有一定的关联性，建议先阅读该系列中的前面3篇文章，重点掌握Mybatis Mapper类的初始化过程，因为在Mybatis中，Mapper是执行SQL语句的入口，类似下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> UserService implements IUserService &#123;</span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUser</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.find(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始进入本文的主题，以源码为手段，分析Mybatis执行SQL语句的流行，并且使用了数据库分库分表中间件sharding-jdbc,其版本为sharding-jdbc1.4.1。</p><p>为了方便大家对本文的源码分析，先给出Mybatis层面核心类的方法调用序列图。</p><h2 id="1、SQL执行序列图"><a href="#1、SQL执行序列图" class="headerlink" title="1、SQL执行序列图"></a>1、SQL执行序列图</h2><p><img src="https://img-blog.csdnimg.cn/20190528210928807.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><a id="more"></a><h2 id="2、源码解析SQL执行流程"><a href="#2、源码解析SQL执行流程" class="headerlink" title="2、源码解析SQL执行流程"></a>2、源码解析SQL执行流程</h2><p>接下来从从源码的角度对其进行剖析。</p><blockquote><p>温馨提示：在本文的末尾，还会给出一张详细的Mybatis Shardingjdbc语句执行流程图。（请勿错过哦）。</p></blockquote><h3 id="2-1-MapperProxy-invoker"><a href="#2-1-MapperProxy-invoker" class="headerlink" title="2.1 MapperProxy#invoker"></a>2.1 MapperProxy#invoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);                                     <span class="comment">// @2</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码@1：创建并缓存MapperMethod对象。</p><p>代码@2：调用MapperMethod对象的execute方法，即mapperInterface中定义的每一个方法最终会对应一个MapperMethod。</p><h3 id="2-2-MapperMethod-execute"><a href="#2-2-MapperMethod-execute" class="headerlink" title="2.2 MapperMethod#execute"></a>2.2 MapperMethod#execute</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">if</span> (SqlCommandType.INSERT == command.getType()) &#123; </span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SqlCommandType.UPDATE == command.getType()) &#123;</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SqlCommandType.DELETE == command.getType()) &#123;</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SqlCommandType.SELECT == command.getType()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">        executeWithResultHandler(sqlSession, args);</span><br><span class="line">        result = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">        result = executeForMany(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">        result = executeForMap(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Unknown execution method for: &quot;</span> + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Mapper method &#x27;&quot;</span> + command.getName() </span><br><span class="line">          + <span class="string">&quot; attempted to return null from a method with a primitive return type (&quot;</span> + method.getReturnType() + <span class="string">&quot;).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>该方法主要是根据SQL类型，insert、update、select等操作，执行对应的逻辑，本文我们以查询语句，进行跟踪，进入executeForMany(sqlSession, args)方法。</p><h3 id="2-3-MapperMethod-executeForMany"><a href="#2-3-MapperMethod-executeForMany" class="headerlink" title="2.3 MapperMethod#executeForMany"></a>2.3 MapperMethod#executeForMany</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">executeForMany</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;E&gt; result;</span><br><span class="line">    Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">    <span class="keyword">if</span> (method.hasRowBounds()) &#123;</span><br><span class="line">      RowBounds rowBounds = method.extractRowBounds(args);</span><br><span class="line">      result = sqlSession.&lt;E&gt;selectList(command.getName(), param, rowBounds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = sqlSession.&lt;E&gt;selectList(command.getName(), param);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// issue #510 Collections &amp; arrays support</span></span><br><span class="line">    <span class="keyword">if</span> (!method.getReturnType().isAssignableFrom(result.getClass())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (method.getReturnType().isArray()) &#123;</span><br><span class="line">        <span class="keyword">return</span> convertToArray(result);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> convertToDeclaredCollection(sqlSession.getConfiguration(), result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>该方法也比较简单，最终通过SqlSession调用selectList方法。</p><h3 id="2-4-DefaultSqlSession-selectList"><a href="#2-4-DefaultSqlSession-selectList" class="headerlink" title="2.4 DefaultSqlSession#selectList"></a>2.4 DefaultSqlSession#selectList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      MappedStatement ms = configuration.getMappedStatement(statement);   <span class="comment">// @1</span></span><br><span class="line">      List&lt;E&gt; result = executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);   <span class="comment">// @2</span></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error querying database.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码@1：根据资源名称获取对应的MappedStatement对象，此时的statement为资源名称，例如com.demo.UserMapper.findUser。至于MappedStatement对象的生成在上一节初始化时已详细介绍过，此处不再重复介绍。</p><p>代码@2：调用Executor的query方法。这里说明一下，其实一开始会进入到CachingExecutor#query方法，由于CachingExecutor的Executor delegate属性默认是SimpleExecutor，故最终还是会进入到SimpleExecutor#query中。</p><p>接下来我们进入到SimpleExecutor的父类BaseExecutor的query方法中。</p><h3 id="2-5-BaseExecutor-query"><a href="#2-5-BaseExecutor-query" class="headerlink" title="2.5 BaseExecutor#query"></a>2.5 BaseExecutor#query</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;   <span class="comment">// @1</span></span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      queryStack++;</span><br><span class="line">      list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;                                            <span class="comment">// @2</span></span><br><span class="line">      <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);                   <span class="comment">// @3</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      queryStack--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">        deferredLoad.load();</span><br><span class="line">      &#125;</span><br><span class="line">      deferredLoads.clear(); <span class="comment">// issue #601</span></span><br><span class="line">      <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;                         <span class="comment">// @4</span></span><br><span class="line">        clearLocalCache(); <span class="comment">// issue #482</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先介绍一下该方法的入参，这些类都是Mybatis的重要类：</p><ul><li>MappedStatement ms<br>映射语句，一个MappedStatemnet对象代表一个Mapper中的一个方法，是映射的最基本对象。</li><li>Object parameter<br>SQL语句的参数列表。</li><li>RowBounds rowBounds<br>行边界对象，其实就是分页参数limit与size。</li><li>ResultHandler resultHandler<br>结果处理Handler。</li><li>CacheKey key<br>Mybatis缓存Key</li><li>BoundSql boundSql<br>SQL与参数绑定信息，从该对象可以获取在映射文件中的SQL语句。</li></ul><p>代码@2：首先从缓存中获取，Mybatis支持一级缓存（SqlSession）与二级缓存（多个SqlSession共享）。</p><p>代码@3：从数据库查询结果，然后进入到doQuery方法，执行真正的查询动作。</p><p>代码@4：如果一级缓存是语句级别的，则语句执行完毕后，删除缓存。</p><h3 id="2-6-SimpleExecutor-doQuery"><a href="#2-6-SimpleExecutor-doQuery" class="headerlink" title="2.6 SimpleExecutor#doQuery"></a>2.6 SimpleExecutor#doQuery</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Configuration configuration = ms.getConfiguration();</span><br><span class="line">      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);   <span class="comment">// @1</span></span><br><span class="line">      stmt = prepareStatement(handler, ms.getStatementLog());                                                                                                                   <span class="comment">// @2</span></span><br><span class="line">      <span class="keyword">return</span> handler.&lt;E&gt;query(stmt, resultHandler);                                                                                                                                        <span class="comment">// @3</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码@1：创建StatementHandler，这里会加入Mybatis的插件扩展机制(将在下篇详细介绍)，如图所示：<br><img src="https://img-blog.csdnimg.cn/20190528211610596.png" alt="在这里插入图片描述"><br>代码@2：创建Statement对象，注意，这里就是JDBC协议的java.sql.Statement对象了。</p><p>代码@3：使用Statment对象执行SQL语句。</p><p>接下来详细介绍Statement对象的创建过程与执行过程，即分布详细跟踪代码@2与代码@3。</p><h2 id="3、Statement对象创建流程"><a href="#3、Statement对象创建流程" class="headerlink" title="3、Statement对象创建流程"></a>3、Statement对象创建流程</h2><h3 id="3-1-java-sql-Connection对象创建"><a href="#3-1-java-sql-Connection对象创建" class="headerlink" title="3.1 java.sql.Connection对象创建"></a>3.1 java.sql.Connection对象创建</h3><h4 id="3-1-1-SimpleExecutor-prepareStatement"><a href="#3-1-1-SimpleExecutor-prepareStatement" class="headerlink" title="3.1.1 SimpleExecutor#prepareStatement"></a>3.1.1 SimpleExecutor#prepareStatement</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    Connection connection = getConnection(statementLog);  <span class="comment">// @1</span></span><br><span class="line">    stmt = handler.prepare(connection);                                  <span class="comment">// @2</span></span><br><span class="line">    handler.parameterize(stmt);                                               <span class="comment">// @3</span></span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Statement对象，分成三步：<br>代码@1：创建java.sql.Connection对象。</p><p>代码@2：使用Connection对象创建Statment对象。</p><p>代码@3：对Statement进行额外处理，特别是PrepareStatement的参数设置(ParameterHandler)。</p><h4 id="3-1-2-SimpleExecutor-getConnection"><a href="#3-1-2-SimpleExecutor-getConnection" class="headerlink" title="3.1.2 SimpleExecutor#getConnection"></a>3.1.2 SimpleExecutor#getConnection</h4><p>getConnection方法，根据上面流程图所示，先是进入到org.mybatis.spring.transaction.SpringManagedTransaction，再通过spring-jdbc框架，利用DataSourceUtils获取连接，其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">doGetConnection</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> SQLException </span>&#123;  </span><br><span class="line">Assert.notNull(dataSource, <span class="string">&quot;No DataSource specified&quot;</span>);</span><br><span class="line">ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource); </span><br><span class="line"><span class="keyword">if</span> (conHolder != <span class="keyword">null</span> &amp;&amp; (conHolder.hasConnection() || conHolder.isSynchronizedWithTransaction())) &#123;</span><br><span class="line">conHolder.requested();</span><br><span class="line"><span class="keyword">if</span> (!conHolder.hasConnection()) &#123;</span><br><span class="line">conHolder.setConnection(dataSource.getConnection());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> conHolder.getConnection();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Else we either got no holder or an empty thread-bound holder here.</span></span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">&quot;Fetching JDBC Connection from DataSource&quot;</span>);</span><br><span class="line">Connection con = dataSource.getConnection();      <span class="comment">// @1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里省略与事务处理相关的代码</span></span><br><span class="line"><span class="keyword">return</span> con;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：通过DataSource获取connection，那此处的DataSource是“谁”呢？看一下我们工程的配置：<br><img src="https://img-blog.csdnimg.cn/20190528212019407.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190528212039288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>故最终dataSouce.getConnection获取的连接，是从SpringShardingDataSource中获取连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">com.dangdang.ddframe.rdb.sharding.jdbc.ShardingDataSource#getConnection</span><br><span class="line"><span class="function"><span class="keyword">public</span> ShardingConnection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        MetricsContext.init(shardingProperties);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ShardingConnection(shardingContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的结果如下：<br><img src="https://img-blog.csdnimg.cn/20190528212138293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>备注：这里只是返回了一个ShardingConnection对象，该对象包含了分库分表上下文，但此时并没有执行具体的分库操作（切换数据源）。</p><p>Connection的获取流程清楚后，我们继续来看一下Statemnet对象的创建。</p><h3 id="3-2-java-sql-Statement对象创建"><a href="#3-2-java-sql-Statement对象创建" class="headerlink" title="3.2 java.sql.Statement对象创建"></a>3.2 java.sql.Statement对象创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stmt = prepareStatement(handler, ms.getStatementLog());            </span><br></pre></td></tr></table></figure><p>上面语句的调用链：RoutingStatementHandler -》BaseStatementHandler</p><h4 id="3-2-1-BaseStatementHandler-prepare"><a href="#3-2-1-BaseStatementHandler-prepare" class="headerlink" title="3.2.1 BaseStatementHandler#prepare"></a>3.2.1 BaseStatementHandler#prepare</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Statement <span class="title">prepare</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().sql(boundSql.getSql());</span><br><span class="line">    Statement statement = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      statement = instantiateStatement(connection);    <span class="comment">// @1</span></span><br><span class="line">      setStatementTimeout(statement);                         <span class="comment">// @2</span></span><br><span class="line">      setFetchSize(statement);                                      <span class="comment">// @3</span></span><br><span class="line">      <span class="keyword">return</span> statement;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      closeStatement(statement);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeStatement(statement);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Error preparing statement.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码@1：根据Connection对象（本文中是ShardingConnection)来创建Statement对象，其默认实现类：PreparedStatementHandler#instantiateStatement方法。</p><p>代码@2：为Statement设置超时时间。</p><p>代码@3：设置fetchSize。</p><h4 id="3-2-2-PreparedStatementHandler-instantiateStatement"><a href="#3-2-2-PreparedStatementHandler-instantiateStatement" class="headerlink" title="3.2.2 PreparedStatementHandler#instantiateStatement"></a>3.2.2 PreparedStatementHandler#instantiateStatement</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Statement <span class="title">instantiateStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    String sql = boundSql.getSql();</span><br><span class="line">    <span class="keyword">if</span> (mappedStatement.getKeyGenerator() <span class="keyword">instanceof</span> Jdbc3KeyGenerator) &#123;</span><br><span class="line">      String[] keyColumnNames = mappedStatement.getKeyColumns();</span><br><span class="line">      <span class="keyword">if</span> (keyColumnNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> connection.prepareStatement(sql, keyColumnNames);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappedStatement.getResultSetType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其实Statement对象的创建，就比较简单了，既然Connection是ShardingConnection，那就看一下其对应的prepareStatement方法即可。</p><h4 id="3-2-2-ShardingConnection-prepareStatement"><a href="#3-2-2-ShardingConnection-prepareStatement" class="headerlink" title="3.2.2 ShardingConnection#prepareStatement"></a>3.2.2 ShardingConnection#prepareStatement</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(<span class="keyword">final</span> String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;   <span class="comment">// sql，为配置在mybatis xml文件中的sql语句</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ShardingPreparedStatement(<span class="keyword">this</span>, sql);</span><br><span class="line">&#125;</span><br><span class="line">ShardingPreparedStatement(<span class="keyword">final</span> ShardingConnection shardingConnection, </span><br><span class="line">            <span class="keyword">final</span> String sql, <span class="keyword">final</span> <span class="keyword">int</span> resultSetType, <span class="keyword">final</span> <span class="keyword">int</span> resultSetConcurrency, <span class="keyword">final</span> <span class="keyword">int</span> resultSetHoldability) &#123;</span><br><span class="line">        <span class="keyword">super</span>(shardingConnection, resultSetType, resultSetConcurrency, resultSetHoldability);</span><br><span class="line">        preparedSQLRouter = shardingConnection.getShardingContext().getSqlRouteEngine().prepareSQL(sql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构建ShardingPreparedStatement对象的时候，会根据SQL语句创建解析SQL路由的解析器对象，但此时并不会执行相关的路由计算，PreparedStatement对象创建完成后，就开始进入SQL执行流程中。</p><h2 id="4、SQL执行流程"><a href="#4、SQL执行流程" class="headerlink" title="4、SQL执行流程"></a>4、SQL执行流程</h2><p>接下来我们继续看SimpleExecutor#doQuery方法的第3步，执行SQL语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handler.&lt;E&gt;query(stmt, resultHandler)。</span><br></pre></td></tr></table></figure><p>首先会进入RoutingStatementHandler这个类中，进行Mybatis层面的路由（主要是根据Statement类型）<br><img src="https://img-blog.csdnimg.cn/20190528212729690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后进入到PreparedStatementHandler#query中。</p><h3 id="4-1-PreparedStatementHandler-query"><a href="#4-1-PreparedStatementHandler-query" class="headerlink" title="4.1 PreparedStatementHandler#query"></a>4.1 PreparedStatementHandler#query</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">    ps.execute();  <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">return</span> resultSetHandler.&lt;E&gt; handleResultSets(ps);  <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：调用PreparedStatement的execute方法，由于本例是使用了Sharding-jdbc分库分表，此时调用的具体实现为：ShardingPreparedStatement。</p><p>代码@2：处理结果。</p><p>我们接下来分别来跟进execute与结果处理方法。</p><h3 id="4-2-ShardingPreparedStatement-execute"><a href="#4-2-ShardingPreparedStatement-execute" class="headerlink" title="4.2 ShardingPreparedStatement#execute"></a>4.2 ShardingPreparedStatement#execute</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PreparedStatementExecutor(getShardingConnection().getShardingContext().getExecutorEngine(), routeSQL()).execute(); <span class="comment">// @1</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        clearRouteContext();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里奥妙无穷，其关键点如下：<br>1）创造PreparedStatementExecutor对象，其两个核心参数：</p><ul><li>ExecutorEngine executorEngine：shardingjdbc执行引擎。</li><li>Collection&lt; PreparedStatementExecutorWrapper&gt; preparedStatemenWrappers<br>一个集合，每一个集合是PreparedStatement的包装类，这个集合如何而来？</li></ul><p>2）preparedStatemenWrappers是通过routeSQL方法产生的。</p><p>3）最终调用PreparedStatementExecutor方法的execute来执行。</p><p>接下来分别看一下routeSQL与execute方法。</p><h3 id="4-3-ShardingPreparedStatement-routeSQL"><a href="#4-3-ShardingPreparedStatement-routeSQL" class="headerlink" title="4.3 ShardingPreparedStatement#routeSQL"></a>4.3 ShardingPreparedStatement#routeSQL</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;PreparedStatementExecutorWrapper&gt; <span class="title">routeSQL</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        List&lt;PreparedStatementExecutorWrapper&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        SQLRouteResult sqlRouteResult = preparedSQLRouter.route(getParameters());   <span class="comment">// @1</span></span><br><span class="line">        MergeContext mergeContext = sqlRouteResult.getMergeContext();                      </span><br><span class="line">        setMergeContext(mergeContext);</span><br><span class="line">        setGeneratedKeyContext(sqlRouteResult.getGeneratedKeyContext());</span><br><span class="line">        <span class="keyword">for</span> (SQLExecutionUnit each : sqlRouteResult.getExecutionUnits()) &#123;                      <span class="comment">// @2          </span></span><br><span class="line">            PreparedStatement preparedStatement = (PreparedStatement) getStatement(getShardingConnection().getConnection(each.getDataSource(), sqlRouteResult.getSqlStatementType()), each.getSql());     <span class="comment">// @3</span></span><br><span class="line">            replayMethodsInvocation(preparedStatement);</span><br><span class="line">            getParameters().replayMethodsInvocation(preparedStatement);</span><br><span class="line">            result.add(wrap(preparedStatement, each));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：根据SQL参数进行路由计算，本文暂不关注其具体实现细节，这些将在具体分析Sharding-jdbc时具体详解，在这里就直观看一下其结果：</p><p>代码@2、@3：对分库分表的结果进行遍历，然后使用底层Datasource来创建Connection，创建PreparedStatement 对象。</p><p>routeSQL就暂时讲到这，从这里我们得知，会在这里根据路由结果，使用底层的具体数据源创建对应的Connection与PreparedStatement 对象。</p><h3 id="4-4-PreparedStatementExecutor-execute"><a href="#4-4-PreparedStatementExecutor-execute" class="headerlink" title="4.4 PreparedStatementExecutor#execute"></a>4.4 PreparedStatementExecutor#execute</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Context context = MetricsContext.start(<span class="string">&quot;ShardingPreparedStatement-execute&quot;</span>);</span><br><span class="line">    eventPostman.postExecutionEvents();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isExceptionThrown = ExecutorExceptionHandler.isExceptionThrown();</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, Object&gt; dataMap = ExecutorDataMap.getDataMap();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == preparedStatementExecutorWrappers.size()) &#123;     <span class="comment">// @1</span></span><br><span class="line">            PreparedStatementExecutorWrapper preparedStatementExecutorWrapper = preparedStatementExecutorWrappers.iterator().next();</span><br><span class="line">            <span class="keyword">return</span> executeInternal(preparedStatementExecutorWrapper, isExceptionThrown, dataMap);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Boolean&gt; result = executorEngine.execute(preparedStatementExecutorWrappers, <span class="keyword">new</span> ExecuteUnit&lt;PreparedStatementExecutorWrapper, Boolean&gt;() &#123;    <span class="comment">// @2</span></span><br><span class="line">        </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">execute</span><span class="params">(<span class="keyword">final</span> PreparedStatementExecutorWrapper input)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (input.getPreparedStatement().getConnection()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> executeInternal(input, isExceptionThrown, dataMap);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span> == result || result.isEmpty()) ? <span class="keyword">false</span> : result.get(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        MetricsContext.stop(context);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果计算出来的路由信息为1个，则同步执行。</p><p>代码@2：如果计算出来的路由信息有多个，则使用线程池异步执行。</p><p>那还有一个问题，通过PreparedStatement#execute方法执行后，如何返回结果呢？特别是异步执行的。</p><p>在上文其实已经谈到：</p><h3 id="4-4-DefaultResultSetHandler-handleResultSets"><a href="#4-4-DefaultResultSetHandler-handleResultSets" class="headerlink" title="4.4 DefaultResultSetHandler#handleResultSets"></a>4.4 DefaultResultSetHandler#handleResultSets</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().activity(<span class="string">&quot;handling results&quot;</span>).object(mappedStatement.getId());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> List&lt;Object&gt; multipleResults = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resultSetCount = <span class="number">0</span>;</span><br><span class="line">    ResultSetWrapper rsw = getFirstResultSet(stmt);         <span class="comment">// @1</span></span><br><span class="line">    <span class="comment">//省略部分代码，完整代码可以查看DefaultResultSetHandler方法。</span></span><br><span class="line">    <span class="keyword">return</span> collapseSingleResultList(multipleResults);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ResultSetWrapper <span class="title">getFirstResultSet</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ResultSet rs = stmt.getResultSet();              <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">while</span> (rs == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// move forward to get the first resultset in case the driver</span></span><br><span class="line">      <span class="comment">// doesn&#x27;t return the resultset as the first result (HSQLDB 2.1)</span></span><br><span class="line">      <span class="keyword">if</span> (stmt.getMoreResults()) &#123;</span><br><span class="line">        rs = stmt.getResultSet();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stmt.getUpdateCount() == -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// no more results. Must be no resultset</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rs != <span class="keyword">null</span> ? <span class="keyword">new</span> ResultSetWrapper(rs, configuration) : <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们看一下其关键代码如下：<br>代码@1：调用Statement#getResultSet()方法，如果使用shardingJdbc，则会调用ShardingStatement#getResultSet()，并会处理分库分表结果集的合并，在这里就不详细进行介绍，该部分会在shardingjdbc专栏详细分析。</p><p>代码@2：jdbc statement中获取结果集的通用写法，这里也不过多的介绍。</p><p>mybatis shardingjdbc SQL执行流程就介绍到这里了，为了方便大家对上述流程的理解，最后给出SQL执行的流程图：<br><img src="https://img-blog.csdnimg.cn/2019052821331476.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>Mybatis Sharding-Jdbc的SQL执行流程就介绍到这里了，从图中也能清晰看到Mybatis的拆件机制，将在下文详细介绍。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将详细介绍Mybatis SQL语句执行的全流程，本文与上篇具有一定的关联性，建议先阅读该系列中的前面3篇文章，重点掌握Mybatis Mapper类的初始化过程，因为在Mybatis中，Mapper是执行SQL语句的入口，类似下面这段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Service&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; UserService implements IUserService &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 	&lt;span class=&quot;meta&quot;&gt;@Autowired&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; UserMapper userMapper;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; User &lt;span class=&quot;title&quot;&gt;findUser&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Integer id)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; userMapper.find(id);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;开始进入本文的主题，以源码为手段，分析Mybatis执行SQL语句的流行，并且使用了数据库分库分表中间件sharding-jdbc,其版本为sharding-jdbc1.4.1。&lt;/p&gt;
&lt;p&gt;为了方便大家对本文的源码分析，先给出Mybatis层面核心类的方法调用序列图。&lt;/p&gt;
&lt;h2 id=&quot;1、SQL执行序列图&quot;&gt;&lt;a href=&quot;#1、SQL执行序列图&quot; class=&quot;headerlink&quot; title=&quot;1、SQL执行序列图&quot;&gt;&lt;/a&gt;1、SQL执行序列图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190528210928807.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://example.com/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://example.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis执行SQL的4大基础组件详解</title>
    <link href="http://example.com/posts/7c04b5f0.html"/>
    <id>http://example.com/posts/7c04b5f0.html</id>
    <published>2020-12-09T14:53:35.000Z</published>
    <updated>2020-12-11T04:18:13.737Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="1、Executor"><a href="#1、Executor" class="headerlink" title="1、Executor"></a>1、Executor</h2><p>sql执行器，其对应的类全路径：org.apache.ibatis.executor.Executor。</p><h3 id="1-1-Executor类图"><a href="#1-1-Executor类图" class="headerlink" title="1.1 Executor类图"></a>1.1 Executor类图</h3><p><img src="https://img-blog.csdnimg.cn/20190526170433414.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>Executor<br>执行器根据接口，定义update(更新或插入)、query(查询)、commit(提交事务)、rollback(回滚事务)。接下来简单介绍几个重要方法：</p><ul><li>int update(MappedStatement ms, Object parameter) throws SQLException<br>更新或插入方法，其参数含义如下：、<br>1）MappedStatement ms：SQL映射语句（Mapper.xml文件每一个方法对应一个MappedStatement对象）<br>2）Object parameter：参数，通常是List集合。</li><li>&lt; E&gt; List&lt; E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)<br>查询方法，其参数含义如下：<br>1）RowBounds：行边界，主要值分页参数limit、offset。<br>2）ResultHandler resultHandler：结果处理器。</li><li>CacheKey createCacheKey(MappedStatement ms, Object parameterObj, RowBounds bounds, BoundSql bSql)<br>创建缓存Key，Mybatis一二级缓存的缓存Key，可以看出Key由上述4个参数来决定。<br>1）BoundSql boundSql：可以通过该对象获取SQL语句。</li></ul></li><li><p>CachingExecutor<br>支持结果缓存的SQL执行器，注意其设计模式的应用，该类中，会持有Executor的一个委托对象，CachingExecutor关注与缓存特定的逻辑，其最终的SQL执行由其委托对象来实现，即其内部的委托对象为BaseExecutor的实现类。</p></li><li><p>BaseExecutor<br>Executor的基础实现类，该类为抽象类，关于查询、更新具体的实现由其子类来实现，下面4个都是其子类。</p></li><li><p>SimpleExecutor<br>简单的Executor执行器。</p></li><li><p>BatchExecutor<br>支持批量执行的Executor执行器。</p></li><li><p>ClosedExecutor<br>表示一个已关闭的Executor。</p></li><li><p>ReuseExecutor<br>支持重复使用Statement,以SQL为键，缓存Statement对象。</p></li></ul><h3 id="1-2-创建Executor"><a href="#1-2-创建Executor" class="headerlink" title="1.2 创建Executor"></a>1.2 创建Executor</h3><p>在Mybatis中，Executor的创建由Configuration对象来创建，具体的代码如下：</p><h4 id="Configuration-newExecitor"><a href="#Configuration-newExecitor" class="headerlink" title="Configuration#newExecitor"></a>Configuration#newExecitor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> newExecutor(transaction, defaultExecutorType);   <span class="comment">// @1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">  Executor executor;</span><br><span class="line">  <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;   <span class="comment">// @2</span></span><br><span class="line">    executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cacheEnabled) &#123; <span class="comment">// @3</span></span><br><span class="line">    executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">  &#125;</span><br><span class="line">  executor = (Executor) interceptorChain.pluginAll(executor);  <span class="comment">// @4</span></span><br><span class="line">  <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，Executor的创建由如下三个关键点：<br>代码@1：默认的ExecutorType为ExecutorType.SIMPLE，即默认创建的Executory为SimpleExecutor。<br>代码@2：根据executorType的值创建对应的Executory。<br>代码@3：如果cacheEnabled为true，则创建CachingExecutory，然后在其内部持有上面创建的Executor,cacheEnabled默认为true，则默认创建的Executor为CachingExecutor，并且其内部包裹着SimpleExecutor。<br>代码@4：使用InterceptorChain.pluginAll为executor创建代理对象，即Mybatis的拆件机制，将在该系列文章中详细介绍。</p><a id="more"></a><h2 id="2、StatementHandler"><a href="#2、StatementHandler" class="headerlink" title="2、StatementHandler"></a>2、StatementHandler</h2><p>在学习StatementHandler之前，我们先来回顾一下JDBC相关的知识。JDBC与语句执行的两大主流对象：java.sql.Statement、java.sql.PrepareStatement对象大家应该不会陌生，该对象的execute方法就是执行SQL语句的入口，通过java.sql.Connection对象创建Statement对象。Mybatis的StatementHandler，是Mybatis创建Statement对象的处理器，即StatementHandler会接管Statement对象的创建。</p><h3 id="2-1-StatementHandler类图"><a href="#2-1-StatementHandler类图" class="headerlink" title="2.1 StatementHandler类图"></a>2.1 StatementHandler类图</h3><p><img src="https://img-blog.csdnimg.cn/20190526171050653.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>StatementHandler<br>根接口，我们重点关注一下其定义的方法：</p><ul><li>Statement prepare(Connection connection)<br>创建Statement对象，即该方法会通过Connection对象创建Statement对象。</li><li>void parameterize(Statement statement)<br>对Statement对象参数化，特别是PreapreStatement对象。</li><li>void batch(Statement statement)<br>批量执行SQL。</li><li>int update(Statement statement)<br>更新操作。</li><li>&lt; E&gt; List&lt; E&gt; query(Statement statement, ResultHandler resultHandler)<br>查询操作。</li><li>BoundSql getBoundSql()<br>获取SQL语句。</li><li>ParameterHandler getParameterHandler()<br>获取对应的参数处理器。</li></ul></li><li><p>BaseStatementHandler<br>StatementHandler的抽象实现类，SimpleStatementHandler、PrepareStatementHandler、CallableStatementHandler是其子类。<br>我们来一一看一下其示例变量：</p><ul><li>Configuration configuration<br>Mybatis全局配置对象。</li><li>ObjectFactory objectFactory<br>对象工厂。</li><li>TypeHandlerRegistry typeHandlerRegistry<br>类型注册器。</li><li>ResultSetHandler resultSetHandler<br>结果集Handler。</li><li>ParameterHandler parameterHandler<br>参数处理器Handler。</li><li>Executor executor<br>SQL执行器。</li><li>MappedStatement mappedStatement<br>SQL映射语句（Mapper.xml文件每一个方法对应一个MappedStatement对象）</li><li>RowBounds rowBounds<br>行边界，主要值分页参数limit、offset。</li><li>BoundSql boundSql<br>可以通过该对象获取SQL语句。</li></ul></li><li><p>SimpleStatementHandler<br>具体的StatementHandler实现器，java.sql.Statement对象创建处理器。</p></li><li><p>PrepareStatementHandler<br>java.sql.PrepareStatement对象的创建处理器。</p></li><li><p>CallableStatementHandler<br>java.sql.CallableStatement对象的创建处理器，可用来执行存储过程调用的Statement。</p></li><li><p>RoutingStatementHandler<br>StatementHandler路由器，我们看一下其构造方法后，就会对该类了然于胸。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (ms.getStatementType()) &#123; <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">case</span> STATEMENT:</span><br><span class="line">      delegate = <span class="keyword">new</span> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PREPARED:</span><br><span class="line">      delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CALLABLE:</span><br><span class="line">      delegate = <span class="keyword">new</span> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Unknown statement type: &quot;</span> + ms.getStatementType());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来是会根据MappedStatement对象的statementType创建对应的StatementHandler。</p></li></ul><h3 id="2-2-创建StatementHandler"><a href="#2-2-创建StatementHandler" class="headerlink" title="2.2 创建StatementHandler"></a>2.2 创建StatementHandler</h3><h4 id="Configuration-newStatementHandler"><a href="#Configuration-newStatementHandler" class="headerlink" title="Configuration#newStatementHandler"></a>Configuration#newStatementHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql); <span class="comment">// @1</span></span><br><span class="line">  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler); <span class="comment">// @2</span></span><br><span class="line">  <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的两个关键点如下：<br>代码@1：创建RoutingStatementHandler对象，在其内部再根据SQL语句的类型，创建对应的StatementHandler对象。<br>代码@2：对StatementHandler引入拆件机制，该部分将在该专题的后续文章中会详细介绍，这里暂时跳过。</p><h2 id="3、ParameterHandler"><a href="#3、ParameterHandler" class="headerlink" title="3、ParameterHandler"></a>3、ParameterHandler</h2><p>参数处理器。同样我们先来看一下其类图。</p><h3 id="3-1-ParameterHandler类图"><a href="#3-1-ParameterHandler类图" class="headerlink" title="3.1 ParameterHandler类图"></a>3.1 ParameterHandler类图</h3><p><img src="https://img-blog.csdnimg.cn/20190526171502281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这个比较简单，就是处理PreparedStatemet接口的参数化处理，也可以顺便看一下其调用链(该部分会在下一篇中详细介绍)。<br><img src="https://img-blog.csdnimg.cn/20190526171635381.png" alt="在这里插入图片描述"></p><h3 id="3-2-创建ParameterHandler"><a href="#3-2-创建ParameterHandler" class="headerlink" title="3.2 创建ParameterHandler"></a>3.2 创建ParameterHandler</h3><h4 id="Configuration-newParameterHandler"><a href="#Configuration-newParameterHandler" class="headerlink" title="Configuration#newParameterHandler"></a>Configuration#newParameterHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">  parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);  <span class="comment">// @1</span></span><br><span class="line">  <span class="keyword">return</span> parameterHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样该接口也支持插件化机制。</p><h2 id="4、ResultSetHandler"><a href="#4、ResultSetHandler" class="headerlink" title="4、ResultSetHandler"></a>4、ResultSetHandler</h2><p>处理结果的Handler。我们同样看一下其类图。</p><h3 id="4-1-ResultSetHandler类图"><a href="#4-1-ResultSetHandler类图" class="headerlink" title="4.1 ResultSetHandler类图"></a>4.1 ResultSetHandler类图</h3><p><img src="https://img-blog.csdnimg.cn/20190526171756530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>处理Jdbc ResultSet的处理器。</p><h3 id="4-2-ResultSetHandler创建"><a href="#4-2-ResultSetHandler创建" class="headerlink" title="4.2 ResultSetHandler创建"></a>4.2 ResultSetHandler创建</h3><h4 id="Configuration-newResultSetHandler"><a href="#Configuration-newResultSetHandler" class="headerlink" title="Configuration#newResultSetHandler"></a>Configuration#newResultSetHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultSetHandler <span class="title">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">    ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  ResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">  resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">  <span class="keyword">return</span> resultSetHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样支持插件化机制，我们也稍微再看一下其调用链：<br><img src="https://img-blog.csdnimg.cn/20190526171844420.png" alt="在这里插入图片描述"><br>可以看出其调用的入口为SQL执行时。</p><p>本文作为下一篇《源码分析Mybatis整合ShardingJdbc SQL执行流程》的前置篇，重点介绍Executor、StatementHandler、ParameterHandler、ResultSetHandler的具体职责，以类图为基础并详细介绍其核心方法的作用，然后详细介绍了这些对象是如何创建，并引出Mybatis拆件机制。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1、Executor&quot;&gt;&lt;a href=&quot;#1、Executor&quot; class=&quot;headerlink&quot; title=&quot;1、Executor&quot;&gt;&lt;/a&gt;1、Executor&lt;/h2&gt;&lt;p&gt;sql执行器，其对应的类全路径：org.apache.ibatis.executor.Executor。&lt;/p&gt;
&lt;h3 id=&quot;1-1-Executor类图&quot;&gt;&lt;a href=&quot;#1-1-Executor类图&quot; class=&quot;headerlink&quot; title=&quot;1.1 Executor类图&quot;&gt;&lt;/a&gt;1.1 Executor类图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190526170433414.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Executor&lt;br&gt;执行器根据接口，定义update(更新或插入)、query(查询)、commit(提交事务)、rollback(回滚事务)。接下来简单介绍几个重要方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;int update(MappedStatement ms, Object parameter) throws SQLException&lt;br&gt;更新或插入方法，其参数含义如下：、&lt;br&gt;1）MappedStatement ms：SQL映射语句（Mapper.xml文件每一个方法对应一个MappedStatement对象）&lt;br&gt;2）Object parameter：参数，通常是List集合。&lt;/li&gt;
&lt;li&gt;&amp;lt; E&amp;gt; List&amp;lt; E&amp;gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)&lt;br&gt;查询方法，其参数含义如下：&lt;br&gt;1）RowBounds：行边界，主要值分页参数limit、offset。&lt;br&gt;2）ResultHandler resultHandler：结果处理器。&lt;/li&gt;
&lt;li&gt;CacheKey createCacheKey(MappedStatement ms, Object parameterObj, RowBounds bounds, BoundSql bSql)&lt;br&gt;创建缓存Key，Mybatis一二级缓存的缓存Key，可以看出Key由上述4个参数来决定。&lt;br&gt;1）BoundSql boundSql：可以通过该对象获取SQL语句。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CachingExecutor&lt;br&gt;支持结果缓存的SQL执行器，注意其设计模式的应用，该类中，会持有Executor的一个委托对象，CachingExecutor关注与缓存特定的逻辑，其最终的SQL执行由其委托对象来实现，即其内部的委托对象为BaseExecutor的实现类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;BaseExecutor&lt;br&gt;Executor的基础实现类，该类为抽象类，关于查询、更新具体的实现由其子类来实现，下面4个都是其子类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SimpleExecutor&lt;br&gt;简单的Executor执行器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;BatchExecutor&lt;br&gt;支持批量执行的Executor执行器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ClosedExecutor&lt;br&gt;表示一个已关闭的Executor。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ReuseExecutor&lt;br&gt;支持重复使用Statement,以SQL为键，缓存Statement对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-2-创建Executor&quot;&gt;&lt;a href=&quot;#1-2-创建Executor&quot; class=&quot;headerlink&quot; title=&quot;1.2 创建Executor&quot;&gt;&lt;/a&gt;1.2 创建Executor&lt;/h3&gt;&lt;p&gt;在Mybatis中，Executor的创建由Configuration对象来创建，具体的代码如下：&lt;/p&gt;
&lt;h4 id=&quot;Configuration-newExecitor&quot;&gt;&lt;a href=&quot;#Configuration-newExecitor&quot; class=&quot;headerlink&quot; title=&quot;Configuration#newExecitor&quot;&gt;&lt;/a&gt;Configuration#newExecitor&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Executor &lt;span class=&quot;title&quot;&gt;newExecutor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Transaction transaction)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; newExecutor(transaction, defaultExecutorType);   &lt;span class=&quot;comment&quot;&gt;// @1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Executor &lt;span class=&quot;title&quot;&gt;newExecutor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Transaction transaction, ExecutorType executorType)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  executorType = executorType == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? defaultExecutorType : executorType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  executorType = executorType == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? ExecutorType.SIMPLE : executorType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Executor executor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ExecutorType.BATCH == executorType) &amp;#123;   &lt;span class=&quot;comment&quot;&gt;// @2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BatchExecutor(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ExecutorType.REUSE == executorType) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ReuseExecutor(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SimpleExecutor(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cacheEnabled) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// @3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CachingExecutor(executor);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  executor = (Executor) interceptorChain.pluginAll(executor);  &lt;span class=&quot;comment&quot;&gt;// @4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; executor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从上面的代码可以看出，Executor的创建由如下三个关键点：&lt;br&gt;代码@1：默认的ExecutorType为ExecutorType.SIMPLE，即默认创建的Executory为SimpleExecutor。&lt;br&gt;代码@2：根据executorType的值创建对应的Executory。&lt;br&gt;代码@3：如果cacheEnabled为true，则创建CachingExecutory，然后在其内部持有上面创建的Executor,cacheEnabled默认为true，则默认创建的Executor为CachingExecutor，并且其内部包裹着SimpleExecutor。&lt;br&gt;代码@4：使用InterceptorChain.pluginAll为executor创建代理对象，即Mybatis的拆件机制，将在该系列文章中详细介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://example.com/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://example.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>源码分析Mybatis MappedStatement的创建流程</title>
    <link href="http://example.com/posts/18c7756d.html"/>
    <id>http://example.com/posts/18c7756d.html</id>
    <published>2020-12-09T14:51:35.000Z</published>
    <updated>2020-12-09T14:52:35.928Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>上文<a href="https://blog.csdn.net/prestigeding/article/details/90415680">源码分析Mybatis MapperProxy创建流程</a>重点阐述MapperProxy的创建流程，但并没有介绍*.Mapper.java(UserMapper.java)是如何与*Mapper.xml文件中的SQL语句是如何建立关联的。本文将重点接开这个谜团。</p><p>接下来重点从源码的角度分析Mybatis MappedStatement的创建流程。</p><h2 id="1、上节回顾"><a href="#1、上节回顾" class="headerlink" title="1、上节回顾"></a>1、上节回顾</h2><p>我们注意到这里有两三个与Mapper相关的配置：</p><ol><li>SqlSessionFactory#mapperLocations，指定xml文件的配置路径。</li><li>SqlSessionFactory#configLocation，指定mybaits的配置文件，该配置文件也可以配置mapper.xml的配置路径信息。</li><li>MapperScannerConfigurer，扫描Mapper的java类(DAO)。</li></ol><p>我们已经详细介绍了Mybatis Mapper对象的扫描与构建，那接下来我们将重点介绍MaperProxy与mapper.xml文件是如何建立关联关系的。</p><p>根据上面的罗列以及上文的讲述，Mapper.xml与Mapper建立联系主要的入口有三：<br>1）MapperScannerConfigurer扫描Bean流程中，在调用MapperReigistry#addMapper时如果Mapper对应的映射文件(Mapper.xml)未加载到内存，会触发加载。<br>2）实例化SqlSessionFactory时，如果配置了mapperLocations。<br>3）示例化SqlSessionFactory时，如果配置了configLocation。</p><p>本节的行文思路：从SqlSessionFacotry的初始化开始讲起，因为mapperLocations、configLocation都是是SqlSessionFactory的属性。</p><blockquote><p>温馨提示：下面开始从源码的角度对其进行介绍，大家可以先跳到文末看看其调用序列图。</p></blockquote><a id="more"></a><h2 id="2、SqlSessionFacotry"><a href="#2、SqlSessionFacotry" class="headerlink" title="2、SqlSessionFacotry"></a>2、SqlSessionFacotry</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (xmlConfigBuilder != <span class="keyword">null</span>) &#123;  <span class="comment">// XMLConfigBuilder   // @1</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        xmlConfigBuilder.parse();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">&quot;Parsed configuration file: &#x27;&quot;</span> + <span class="keyword">this</span>.configLocation + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">&quot;Failed to parse config resource: &quot;</span> + <span class="keyword">this</span>.configLocation, ex);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isEmpty(<span class="keyword">this</span>.mapperLocations)) &#123;   <span class="comment">// @2</span></span><br><span class="line">      <span class="keyword">for</span> (Resource mapperLocation : <span class="keyword">this</span>.mapperLocations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mapperLocation == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          XMLMapperBuilder xmlMapperBuilder = <span class="keyword">new</span> XMLMapperBuilder(mapperLocation.getInputStream(),</span><br><span class="line">              configuration, mapperLocation.toString(), configuration.getSqlFragments());</span><br><span class="line">          xmlMapperBuilder.parse();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">&quot;Failed to parse mapping resource: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          ErrorContext.instance().reset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">&quot;Parsed mapper file: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Property &#x27;mapperLocations&#x27; was not specified or no matching resources found&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上文有两个入口：<br>代码@1：处理configLocation属性。<br>代码@2：处理mapperLocations属性。</p><p>我们先从XMLConfigBuilder#parse开始进行追踪。该方法主要是解析configLocation指定的配置路径，对其进行解析，具体调用parseConfiguration方法。</p><h3 id="2-1-XMLConfigBuilder"><a href="#2-1-XMLConfigBuilder" class="headerlink" title="2.1 XMLConfigBuilder"></a>2.1 XMLConfigBuilder</h3><p>我们直接查看其parseConfiguration方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      propertiesElement(root.evalNode(<span class="string">&quot;properties&quot;</span>)); <span class="comment">//issue #117 read properties first</span></span><br><span class="line">      typeAliasesElement(root.evalNode(<span class="string">&quot;typeAliases&quot;</span>));</span><br><span class="line">      pluginElement(root.evalNode(<span class="string">&quot;plugins&quot;</span>));</span><br><span class="line">      objectFactoryElement(root.evalNode(<span class="string">&quot;objectFactory&quot;</span>));</span><br><span class="line">      objectWrapperFactoryElement(root.evalNode(<span class="string">&quot;objectWrapperFactory&quot;</span>));</span><br><span class="line">      settingsElement(root.evalNode(<span class="string">&quot;settings&quot;</span>));</span><br><span class="line">      environmentsElement(root.evalNode(<span class="string">&quot;environments&quot;</span>)); <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">      databaseIdProviderElement(root.evalNode(<span class="string">&quot;databaseIdProvider&quot;</span>));</span><br><span class="line">      typeHandlerElement(root.evalNode(<span class="string">&quot;typeHandlers&quot;</span>));</span><br><span class="line">      mapperElement(root.evalNode(<span class="string">&quot;mappers&quot;</span>));   <span class="comment">// @1</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>重点关注mapperElement，从名称与参数即可以看出，该方法主要是处理中mappers的定义，即mapper sql语句的解析与处理。如果使用过Mapper的人应该不难知道，我们使用mapper节点，通过resource标签定义具体xml文件的位置。</p><h4 id="2-1-1XMLConfigBuilder-mapperElement"><a href="#2-1-1XMLConfigBuilder-mapperElement" class="headerlink" title="2.1.1XMLConfigBuilder#mapperElement"></a>2.1.1XMLConfigBuilder#mapperElement</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">          String mapperPackage = child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">          configuration.addMappers(mapperPackage);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          String resource = child.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">          String url = child.getStringAttribute(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">          String mapperClass = child.getStringAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ErrorContext.instance().resource(resource);</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());    <span class="comment">// @1</span></span><br><span class="line">            mapperParser.parse();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ErrorContext.instance().resource(url);</span><br><span class="line">            InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">            XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">            mapperParser.parse();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">            configuration.addMapper(mapperInterface);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面的代码比较简单，不难看出，解析出Mapper标签，解析出resource标签的属性，创建对应的文件流，通过构建XMLMapperBuilder来解析对应的mapper.xml文件。此时大家会惊讶的发现，在SqlSessionFacotry的初始化代码中，处理mapperLocations时就是通过构建XMLMapperBuilder来解析mapper文件，其实也不难理解，因为这是mybatis支持的两个地方可以使用mapper标签来定义mapper映射文件，具体解析代码当然是一样的逻辑。那我们解析来重点把目光投向XMLMapperBuilder。</p><h3 id="2-2-XMLMapperBuilder"><a href="#2-2-XMLMapperBuilder" class="headerlink" title="2.2 XMLMapperBuilder"></a>2.2 XMLMapperBuilder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">XMLMapperBuilder#parse</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;     <span class="comment">// @1</span></span><br><span class="line">      configurationElement(parser.evalNode(<span class="string">&quot;/mapper&quot;</span>));</span><br><span class="line">      configuration.addLoadedResource(resource);</span><br><span class="line">      bindMapperForNamespace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parsePendingResultMaps();                                    <span class="comment">// @2</span></span><br><span class="line">    parsePendingChacheRefs();                                   <span class="comment">// @3</span></span><br><span class="line">    parsePendingStatements();                                     <span class="comment">// @4</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果该映射文件(*.Mapper.xml)文件未加载，则首先先加载，完成xml文件的解析，提取xml中与mybatis相关的数据，例如sql、resultMap等等。<br>代码@2：处理mybatis xml中ResultMap。<br>代码@3：处理mybatis缓存相关的配置。<br>代码@4：处理mybatis statment相关配置，这里就是本篇关注的，Sql语句如何与Mapper进行关联的核心实现。</p><p>接下来我们重点探讨parsePendingStatements()方法，解析statement(对应SQL语句)。</p><h4 id="2-2-1-XMLMapperBuilder-parsePendingStatements"><a href="#2-2-1-XMLMapperBuilder-parsePendingStatements" class="headerlink" title="2.2.1 XMLMapperBuilder#parsePendingStatements"></a>2.2.1 XMLMapperBuilder#parsePendingStatements</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parsePendingStatements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Collection&lt;XMLStatementBuilder&gt; incompleteStatements = configuration.getIncompleteStatements();</span><br><span class="line">  <span class="keyword">synchronized</span> (incompleteStatements) &#123;</span><br><span class="line">  Iterator&lt;XMLStatementBuilder&gt; iter = incompleteStatements.iterator();    <span class="comment">// @1</span></span><br><span class="line">  <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  iter.next().parseStatementNode();   <span class="comment">// @2</span></span><br><span class="line">  iter.remove();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">  <span class="comment">// Statement is still missing a resource...</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码@1：遍历解析出来的所有SQL语句，用的是XMLStatementBuilder对象封装的，故接下来重点看一下代码@2，如果解析statmentNode。</p><h4 id="2-2-2-XMLStatementBuilder-parseStatementNode"><a href="#2-2-2-XMLStatementBuilder-parseStatementNode" class="headerlink" title="2.2.2 XMLStatementBuilder#parseStatementNode"></a>2.2.2 XMLStatementBuilder#parseStatementNode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseStatementNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String id = context.getStringAttribute(<span class="string">&quot;id&quot;</span>);                                                                  <span class="comment">// @1 start</span></span><br><span class="line">    String databaseId = context.getStringAttribute(<span class="string">&quot;databaseId&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!databaseIdMatchesCurrent(id, databaseId, <span class="keyword">this</span>.requiredDatabaseId)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Integer fetchSize = context.getIntAttribute(<span class="string">&quot;fetchSize&quot;</span>);</span><br><span class="line">    Integer timeout = context.getIntAttribute(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">    String parameterMap = context.getStringAttribute(<span class="string">&quot;parameterMap&quot;</span>);</span><br><span class="line">    String parameterType = context.getStringAttribute(<span class="string">&quot;parameterType&quot;</span>);</span><br><span class="line">    Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);</span><br><span class="line">    String resultMap = context.getStringAttribute(<span class="string">&quot;resultMap&quot;</span>);</span><br><span class="line">    String resultType = context.getStringAttribute(<span class="string">&quot;resultType&quot;</span>);</span><br><span class="line">    String lang = context.getStringAttribute(<span class="string">&quot;lang&quot;</span>);</span><br><span class="line">    LanguageDriver langDriver = getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">    String resultSetType = context.getStringAttribute(<span class="string">&quot;resultSetType&quot;</span>);</span><br><span class="line">    StatementType statementType = StatementType.valueOf(context.getStringAttribute(<span class="string">&quot;statementType&quot;</span>, StatementType.PREPARED.toString()));</span><br><span class="line">    ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);</span><br><span class="line"></span><br><span class="line">    String nodeName = context.getNode().getNodeName();</span><br><span class="line">    SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">    <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">    <span class="keyword">boolean</span> flushCache = context.getBooleanAttribute(<span class="string">&quot;flushCache&quot;</span>, !isSelect);</span><br><span class="line">    <span class="keyword">boolean</span> useCache = context.getBooleanAttribute(<span class="string">&quot;useCache&quot;</span>, isSelect);</span><br><span class="line">    <span class="keyword">boolean</span> resultOrdered = context.getBooleanAttribute(<span class="string">&quot;resultOrdered&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Include Fragments before parsing</span></span><br><span class="line">    XMLIncludeTransformer includeParser = <span class="keyword">new</span> XMLIncludeTransformer(configuration, builderAssistant);</span><br><span class="line">    includeParser.applyIncludes(context.getNode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse selectKey after includes and remove them.</span></span><br><span class="line">    processSelectKeyNodes(id, parameterTypeClass, langDriver);             <span class="comment">// @1 end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed)</span></span><br><span class="line">    SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);                <span class="comment">// @2</span></span><br><span class="line">    String resultSets = context.getStringAttribute(<span class="string">&quot;resultSets&quot;</span>);</span><br><span class="line">    String keyProperty = context.getStringAttribute(<span class="string">&quot;keyProperty&quot;</span>);</span><br><span class="line">    String keyColumn = context.getStringAttribute(<span class="string">&quot;keyColumn&quot;</span>);</span><br><span class="line">    KeyGenerator keyGenerator;</span><br><span class="line">    String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">    keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">      keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      keyGenerator = context.getBooleanAttribute(<span class="string">&quot;useGeneratedKeys&quot;</span>,</span><br><span class="line">          configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">          ? <span class="keyword">new</span> Jdbc3KeyGenerator() : <span class="keyword">new</span> NoKeyGenerator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,                             <span class="comment">// @3</span></span><br><span class="line">        fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">        resultSetTypeEnum, flushCache, useCache, resultOrdered, </span><br><span class="line">        keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个方法有点长，其关注点主要有3个：<br>代码@1：构建基本属性，其实就是构建MappedStatement的属性，因为MappedStatement对象就是用来描述Mapper-SQL映射的对象。</p><p>代码@2：根据xml配置的内容，解析出实际的SQL语句，使用SqlSource对象来表示。</p><p>代码@3：使用MapperBuilderAssistant对象，根据准备好的属性，构建MappedStatement对象，最终将其存储在Configuration中。</p><h4 id="2-2-3-Configuration-addMappedStatement"><a href="#2-2-3-Configuration-addMappedStatement" class="headerlink" title="2.2.3 Configuration#addMappedStatement"></a>2.2.3 Configuration#addMappedStatement</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMappedStatement</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">   mappedStatements.put(ms.getId(), ms);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MappedStatement的id为：mapperInterface + methodName，例如com.demo.dao.UserMapper.findUser。</p><p>即上述流程完成了xml的解析与初始化，对终极目标是创建MappedStatement对象，上一篇文章介绍了mapperInterface的初始化，最终会初始化为MapperProxy对象，那这两个对象如何关联起来呢？</p><p>从下文可知，MapperProxy与MappedStatement是在调用具Mapper方法时，可以根据mapperInterface.getName + methodName构建出MappedStatement的id，然后就可以从Configuration的mappedStatements容器中根据id获取到对应的MappedStatement对象，这样就建立起联系了。</p><p>其对应的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MapperMethod 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MapperMethod</span><span class="params">(Class&lt;?&gt; mapperInterface, Method method, Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.command = <span class="keyword">new</span> SqlCommand(config, mapperInterface, method);</span><br><span class="line">    <span class="keyword">this</span>.method = <span class="keyword">new</span> MethodSignature(config, method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SqlCommand 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SqlCommand</span><span class="params">(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method)</span> <span class="keyword">throws</span> BindingException </span>&#123;</span><br><span class="line">      String statementName = mapperInterface.getName() + <span class="string">&quot;.&quot;</span> + method.getName();</span><br><span class="line">      MappedStatement ms = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (configuration.hasStatement(statementName)) &#123;</span><br><span class="line">        ms = configuration.getMappedStatement(statementName);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mapperInterface.equals(method.getDeclaringClass().getName())) &#123; <span class="comment">// issue #35</span></span><br><span class="line">        String parentStatementName = method.getDeclaringClass().getName() + <span class="string">&quot;.&quot;</span> + method.getName();</span><br><span class="line">        <span class="keyword">if</span> (configuration.hasStatement(parentStatementName)) &#123;</span><br><span class="line">          ms = configuration.getMappedStatement(parentStatementName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (ms == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Invalid bound statement (not found): &quot;</span> + statementName);</span><br><span class="line">      &#125;</span><br><span class="line">      name = ms.getId();</span><br><span class="line">      type = ms.getSqlCommandType();</span><br><span class="line">      <span class="keyword">if</span> (type == SqlCommandType.UNKNOWN) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Unknown execution method for: &quot;</span> + name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>怎么样，从上面的源码分析中，大家是否已经了解MapperProxy与Xml中的SQL语句是怎样建立的关系了吗？为了让大家更清晰的了解上述过程，现给出其调用时序图：<br><img src="https://img-blog.csdnimg.cn/2019052321283257.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;上文&lt;a href=&quot;https://blog.csdn.net/prestigeding/article/details/90415680&quot;&gt;源码分析Mybatis MapperProxy创建流程&lt;/a&gt;重点阐述MapperProxy的创建流程，但并没有介绍*.Mapper.java(UserMapper.java)是如何与*Mapper.xml文件中的SQL语句是如何建立关联的。本文将重点接开这个谜团。&lt;/p&gt;
&lt;p&gt;接下来重点从源码的角度分析Mybatis MappedStatement的创建流程。&lt;/p&gt;
&lt;h2 id=&quot;1、上节回顾&quot;&gt;&lt;a href=&quot;#1、上节回顾&quot; class=&quot;headerlink&quot; title=&quot;1、上节回顾&quot;&gt;&lt;/a&gt;1、上节回顾&lt;/h2&gt;&lt;p&gt;我们注意到这里有两三个与Mapper相关的配置：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SqlSessionFactory#mapperLocations，指定xml文件的配置路径。&lt;/li&gt;
&lt;li&gt;SqlSessionFactory#configLocation，指定mybaits的配置文件，该配置文件也可以配置mapper.xml的配置路径信息。&lt;/li&gt;
&lt;li&gt;MapperScannerConfigurer，扫描Mapper的java类(DAO)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们已经详细介绍了Mybatis Mapper对象的扫描与构建，那接下来我们将重点介绍MaperProxy与mapper.xml文件是如何建立关联关系的。&lt;/p&gt;
&lt;p&gt;根据上面的罗列以及上文的讲述，Mapper.xml与Mapper建立联系主要的入口有三：&lt;br&gt;1）MapperScannerConfigurer扫描Bean流程中，在调用MapperReigistry#addMapper时如果Mapper对应的映射文件(Mapper.xml)未加载到内存，会触发加载。&lt;br&gt;2）实例化SqlSessionFactory时，如果配置了mapperLocations。&lt;br&gt;3）示例化SqlSessionFactory时，如果配置了configLocation。&lt;/p&gt;
&lt;p&gt;本节的行文思路：从SqlSessionFacotry的初始化开始讲起，因为mapperLocations、configLocation都是是SqlSessionFactory的属性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;温馨提示：下面开始从源码的角度对其进行介绍，大家可以先跳到文末看看其调用序列图。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://example.com/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://example.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>源码分析Mybatis MapperProxy初始化之Mapper对象的扫描与构建</title>
    <link href="http://example.com/posts/47c4bb93.html"/>
    <id>http://example.com/posts/47c4bb93.html</id>
    <published>2020-12-09T14:49:35.000Z</published>
    <updated>2020-12-09T14:50:16.029Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>MapperScannerConfigurer，Spring整合Mybatis的核心类，其作用是扫描项目中Dao类，将其创建为Mybatis的Maper对象即MapperProxy对象。</p><p>首先进入源码学习之前，我们先看一下在项目中的配置文件信息。<br><img src="https://img-blog.csdnimg.cn/20190521205718910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们注意到这里有两三个与Mapper相关的配置：</p><ol><li>SqlSessionFactory#mapperLocations，指定xml文件的配置路径。</li><li>SqlSessionFactory#configLocation，指定mybaits的配置文件，该配置文件也可以配置mapper.xml的配置路径信息。</li><li>MapperScannerConfigurer，扫描Mapper的java类(DAO)。</li></ol><p>本文的行文思路如下：</p><ol><li>Mybatis MapperProxy对象的扫描与构建</li><li>Mapper类与SQL语句如何建立关联<br>这部分主要阐述Java类的运行实例Mapper对象（例如UserMapper、BookMapper)是如何与mapper.xml(UserMapper.xml、BookMapper.xml文件建立联系的)。</li></ol><h2 id="Mybatis-MapperProxy对象创建流程"><a href="#Mybatis-MapperProxy对象创建流程" class="headerlink" title="Mybatis MapperProxy对象创建流程"></a>Mybatis MapperProxy对象创建流程</h2><p>下面的源码分析或许会比较枯燥，进入源码分析之前，先给出MapperProxy的创建序列图。</p><h3 id="1-1-MapperProxy创建序列图"><a href="#1-1-MapperProxy创建序列图" class="headerlink" title="1.1 MapperProxy创建序列图"></a>1.1 MapperProxy创建序列图</h3><p><img src="https://img-blog.csdnimg.cn/20190521215333400.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-2-MapperScannerConfigurer详解"><a href="#1-2-MapperScannerConfigurer详解" class="headerlink" title="1.2 MapperScannerConfigurer详解"></a>1.2 MapperScannerConfigurer详解</h3><p>MapperScannerConfigurer的类图如下所示：<br><img src="https://img-blog.csdnimg.cn/20190521210119671.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>MapperScannerConfigurer实现Spring Bean生命周期相关的类：BeanNameAware、ApplicationContextAware、BeanFactoryPostProcessor、InitializingBean、BeanDefinitionRegistryPostProcessor，我们先来看一下这些接口对应的方法的调用时机：</p><a id="more"></a><ul><li>BeanNameAware<br>是Bean对自己的名称感知，也就是在Bean创建的时候，自动将Bean的名称设置在Bean中，外部应用程序不需要调用setBeanName，就可以通过getBeanName()方法获取其bean名称。</li><li>ApplicationContextAware<br>自动感知ApplicationContext对象，即在Bean创建的时候，Spring工厂会自动将当前的ApplicationContext注入该Bean中。</li><li>InitializingBean<br>实现该接口，Spring在初始化Bean后会自动调用InitializingBean#afterPropertiesSet方法。</li><li>BeanFactoryPostProcessor<br>BeanFactory后置处理器，这个时候只是创建好了Bean的定义信息(BeanDefinition)，在BeanFactoryPostProcessor接口的postProcessBeanFactory方法中，我们可以修改bean的定义信息，例如修改属性的值，修改bean的scope为单例或者多例。与其相似的是BeanPostProcessor，这个是在bean初始化前后对Bean执行，即bean的构造方法调用后，init-method前执行。</li><li>BeanDefinitionRegistryPostProcessor<br>主要用来增加Bean的定义，增加BeanDefinition。由于MapperScannerConfigurer主要的目的就是扫描特定的包，并创建对应的Mapper对象，估这里是MapperScannerConfigurer重点实现的接口。</li></ul><p>那我们接下来从BeanDefinitionRegistryPostProcessor的实现接口开始跟踪。</p><h4 id="BeanDefinitionRegistryPostProcessor-postProcessBeanDefinitionRegistry"><a href="#BeanDefinitionRegistryPostProcessor-postProcessBeanDefinitionRegistry" class="headerlink" title="BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry"></a>BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123;</span><br><span class="line">    if (this.processPropertyPlaceHolders) &#123;</span><br><span class="line">      processPropertyPlaceHolders();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClassPathMapperScanner scanner &#x3D; new ClassPathMapperScanner(registry);</span><br><span class="line">    scanner.setAddToConfig(this.addToConfig);</span><br><span class="line">    scanner.setAnnotationClass(this.annotationClass);</span><br><span class="line">    scanner.setMarkerInterface(this.markerInterface);</span><br><span class="line">    scanner.setSqlSessionFactory(this.sqlSessionFactory);     &#x2F;&#x2F; @1</span><br><span class="line">    scanner.setSqlSessionTemplate(this.sqlSessionTemplate);</span><br><span class="line">    scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName);   </span><br><span class="line">    scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName);</span><br><span class="line">    scanner.setResourceLoader(this.applicationContext);</span><br><span class="line">    scanner.setBeanNameGenerator(this.nameGenerator);</span><br><span class="line">    scanner.registerFilters();</span><br><span class="line">    scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));    &#x2F;&#x2F; @2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先设置SqlSessionFactory，从该Scan器生成的Mapper最终都是受该SqlSessionFactory的管辖。<br>代码@2：调用ClassPathMapperScanner的scan方法进行扫描动作，接下来详细介绍。</p><h4 id="ClassPathMapperScanner-doScan"><a href="#ClassPathMapperScanner-doScan" class="headerlink" title="ClassPathMapperScanner#doScan"></a>ClassPathMapperScanner#doScan</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123;</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions &#x3D; super.doScan(basePackages);   &#x2F;&#x2F;@1</span><br><span class="line">    if (beanDefinitions.isEmpty()) &#123;</span><br><span class="line">      logger.warn(&quot;No MyBatis mapper was found in &#39;&quot; + Arrays.toString(basePackages) + &quot;&#39; package. Please check your configuration.&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      processBeanDefinitions(beanDefinitions);   &#x2F;&#x2F; @2</span><br><span class="line">    &#125;</span><br><span class="line">    return beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先调用父类(org.springframework.context.annotation.ClassPathBeanDefinitionScanner)方法，根据扫描的文件，构建对应的BeanDefinitionHolder对象。<br>代码@2：对这些BeanDefinitions进行处理，对Bean进行加工，加入Mybatis特性。</p><h4 id="ClassPathMapperScanner-processBeanDefinitions"><a href="#ClassPathMapperScanner-processBeanDefinitions" class="headerlink" title="ClassPathMapperScanner#processBeanDefinitions"></a>ClassPathMapperScanner#processBeanDefinitions</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">private void processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt; beanDefinitions) &#123;</span><br><span class="line">    GenericBeanDefinition definition;</span><br><span class="line">    for (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">      definition &#x3D; (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">      if (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(&quot;Creating MapperFactoryBean with name &#39;&quot; + holder.getBeanName() </span><br><span class="line">          + &quot;&#39; and &#39;&quot; + definition.getBeanClassName() + &quot;&#39; mapperInterface&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; the mapper interface is the original class of the bean</span><br><span class="line">      &#x2F;&#x2F; but, the actual class of the bean is MapperFactoryBean</span><br><span class="line">      definition.getPropertyValues().add(&quot;mapperInterface&quot;, definition.getBeanClassName());</span><br><span class="line">      definition.setBeanClass(this.mapperFactoryBean.getClass());   &#x2F;&#x2F; @1</span><br><span class="line">      definition.getPropertyValues().add(&quot;addToConfig&quot;, this.addToConfig);</span><br><span class="line">      boolean explicitFactoryUsed &#x3D; false;</span><br><span class="line">      if (StringUtils.hasText(this.sqlSessionFactoryBeanName)) &#123;    &#x2F;&#x2F; @2 start</span><br><span class="line">        definition.getPropertyValues().add(&quot;sqlSessionFactory&quot;, new RuntimeBeanReference(this.sqlSessionFactoryBeanName));</span><br><span class="line">        explicitFactoryUsed &#x3D; true;</span><br><span class="line">      &#125; else if (this.sqlSessionFactory !&#x3D; null) &#123;</span><br><span class="line">        definition.getPropertyValues().add(&quot;sqlSessionFactory&quot;, this.sqlSessionFactory);</span><br><span class="line">        explicitFactoryUsed &#x3D; true;</span><br><span class="line">      &#125;    &#x2F;&#x2F; @2 end</span><br><span class="line"></span><br><span class="line">      if (StringUtils.hasText(this.sqlSessionTemplateBeanName)) &#123;  &#x2F;&#x2F; @3</span><br><span class="line">        if (explicitFactoryUsed) &#123;</span><br><span class="line">          logger.warn(&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;, new RuntimeBeanReference(this.sqlSessionTemplateBeanName));</span><br><span class="line">        explicitFactoryUsed &#x3D; true;</span><br><span class="line">      &#125; else if (this.sqlSessionTemplate !&#x3D; null) &#123;</span><br><span class="line">        if (explicitFactoryUsed) &#123;</span><br><span class="line">          logger.warn(&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;, this.sqlSessionTemplate);</span><br><span class="line">        explicitFactoryUsed &#x3D; true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!explicitFactoryUsed) &#123;</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(&quot;Enabling autowire by type for MapperFactoryBean with name &#39;&quot; + holder.getBeanName() + &quot;&#39;.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>该方法有3个关键点：<br>代码@1：BeanDefinition中的beanClass设置的类为MapperFactoryBean，即该BeanDefinition初始化的实例为MapperFactoryBean，其名字可以看出，这是一个FactoryBean对象，会通过其getObject方法进行构建具体实例。</p><p>代码@2：将为MapperFactoryBean设置属性，将SqlSessionFactory放入其属性中，在实例化时可以自动获取到该SqlSessionFactory。</p><p>代码@3：如果sqlSessionTemplate不为空，则放入到属性中，以便Spring在实例化MapperFactoryBean时可以得到对应的SqlSessionTemplate。</p><p>分析到这里，MapperScannerConfigurer的doScan方法就结束了，但并没有初始化Mapper，只是创建了很多的BeanDefinition,并且其beanClass为MapperFactoryBean，那我们将目光转向MapperFactoryBean。</p><h3 id="1-3-MapperFactoryBean"><a href="#1-3-MapperFactoryBean" class="headerlink" title="1.3 MapperFactoryBean"></a>1.3 MapperFactoryBean</h3><p>MapperFactoryBean的类图如下：<br><img src="https://img-blog.csdnimg.cn/20190521210725838.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>先对上述核心类做一个简述：</p><h4 id="DaoSupport"><a href="#DaoSupport" class="headerlink" title="DaoSupport"></a>DaoSupport</h4><p>Dao层的基类，定义一个模板方法，供其子类实现具体的逻辑，DaoSupport的模板方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final void afterPropertiesSet() throws IllegalArgumentException, BeanInitializationException &#123;</span><br><span class="line">&#x2F;&#x2F; Let abstract subclasses check their configuration.</span><br><span class="line">checkDaoConfig(); &#x2F;&#x2F; @1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Let concrete implementations initialize themselves.</span><br><span class="line">try &#123;</span><br><span class="line">initDao();           &#x2F;&#x2F; @2</span><br><span class="line">&#125; catch (Exception ex) &#123;</span><br><span class="line">throw new BeanInitializationException(&quot;Initialization of DAO failed&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：检查或构建dao的配置信息，该方法为抽象类，供子类实现，等下我们本节的主角MapperFactoryBean主要实现该方法，从而实现与Mybatis相关的整合信息。<br>代码@2：初始化Dao相关的方法，该方法为一个空实现。</p><h4 id="SqlSessionDaoSupport"><a href="#SqlSessionDaoSupport" class="headerlink" title="SqlSessionDaoSupport"></a>SqlSessionDaoSupport</h4><p>SqlSession支持父类，通过使用SqlSessionFactory或SqlSessionTemplate创建SqlSession，那下面两个方法会在什么时候被调用呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory)</span><br><span class="line">public void setSqlSessionTemplate(SqlSessionTemplate sqlSessionTemplate)</span><br></pre></td></tr></table></figure><p>不知道大家还记不记得，在创建MapperFactoryBean的时候，其属性里会设置SqlSessionFacotry或SqlSessionTemplate，见上文代码(processBeanDefinitions)，这样的话在示例化Bean时，Spring会自动注入实例，即在实例化Bean时，上述方法中的一个或多个会被调用。</p><h4 id="MapperFactoryBean"><a href="#MapperFactoryBean" class="headerlink" title="MapperFactoryBean"></a>MapperFactoryBean</h4><p>主要看它是如何实现checkDaoConfig的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MapperFactoryBean#checkDaoConfig</span><br><span class="line">protected void checkDaoConfig() &#123;</span><br><span class="line">    super.checkDaoConfig();   &#x2F;&#x2F; @1</span><br><span class="line"></span><br><span class="line">    notNull(this.mapperInterface, &quot;Property &#39;mapperInterface&#39; is required&quot;);</span><br><span class="line"></span><br><span class="line">    Configuration configuration &#x3D; getSqlSession().getConfiguration();</span><br><span class="line">    if (this.addToConfig &amp;&amp; !configuration.hasMapper(this.mapperInterface)) &#123;     &#x2F;&#x2F; @2</span><br><span class="line">      try &#123;</span><br><span class="line">        configuration.addMapper(this.mapperInterface);                                        </span><br><span class="line">      &#125; catch (Throwable t) &#123;</span><br><span class="line">        logger.error(&quot;Error while adding the mapper &#39;&quot; + this.mapperInterface + &quot;&#39; to configuration.&quot;, t);</span><br><span class="line">        throw new IllegalArgumentException(t);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先先调用父类的checkDaoConfig方法。<br>代码@2：mapperInterface，就是具体的Mapper的接口类，例如com.demo.dao.UserMapper，如果以注册，则抛出异常，否则调用configuration增加Mapper。</p><p>接下来进入到org.apache.ibatis.session.Configuration中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; void addMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">    mapperRegistry.addMapper(type);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line">    return mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean hasMapper(Class&lt;?&gt; type) &#123;</span><br><span class="line">   return mapperRegistry.hasMapper(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，正在注册(添加)、查询、获取Mapper的核心类为MapperRegistry。</p><h3 id="1-4-MapperRegistry"><a href="#1-4-MapperRegistry" class="headerlink" title="1.4 MapperRegistry"></a>1.4 MapperRegistry</h3><p>其核心类图如下所示：<br><img src="https://img-blog.csdnimg.cn/20190521211339211.png" alt="在这里插入图片描述"><br>对其属性做个简单的介绍：</p><ul><li>Configuration config<br>Mybatis全局配置对象。</li><li>Map&lt;Class<?>, MapperProxyFactory<?>&gt; knownMappers<br>已注册Map，这里的键值为mapper接口，例如com.demo.dao.UserMapper，值为MapperProxyFactory，创建MapperProxy的工厂。</li></ul><p>下面简单介绍MapperRegistry的几个方法，其实现都比较简单。</p><h4 id="MapperRegistry-addMapper"><a href="#MapperRegistry-addMapper" class="headerlink" title="MapperRegistry#addMapper"></a>MapperRegistry#addMapper</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; void addMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">    if (type.isInterface()) &#123;</span><br><span class="line">      if (hasMapper(type)) &#123;   &#x2F;&#x2F; @1</span><br><span class="line">        throw new BindingException(&quot;Type &quot; + type + &quot; is already known to the MapperRegistry.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      boolean loadCompleted &#x3D; false;</span><br><span class="line">      try &#123;</span><br><span class="line">        knownMappers.put(type, new MapperProxyFactory&lt;T&gt;(type));    &#x2F;&#x2F; @2</span><br><span class="line">        MapperAnnotationBuilder parser &#x3D; new MapperAnnotationBuilder(config, type);    &#x2F;&#x2F; @3</span><br><span class="line">        parser.parse();</span><br><span class="line">        loadCompleted &#x3D; true;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        if (!loadCompleted) &#123;</span><br><span class="line">          knownMappers.remove(type);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果该接口已经注册，则抛出已经绑定的异常。<br>代码@2：为该接口注册MapperProxyFactory，但这里只是注册其创建MapperProxy的工厂，并不是创建MapperProxy。<br>代码@3：如果Mapper对应的xml资源未加载，触发xml的绑定操作，将xml中的sql语句与Mapper建立关系。本文将不详细介绍，在下一篇中详细介绍。</p><p>注意：addMapper方法，只是为*Mapper创建对应对应的MapperProxyFactory。</p><h4 id="MapperRegistry-getMapper"><a href="#MapperRegistry-getMapper" class="headerlink" title="MapperRegistry#getMapper"></a>MapperRegistry#getMapper</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line">    final MapperProxyFactory&lt;T&gt; mapperProxyFactory &#x3D; (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);   &#x2F;&#x2F; @1</span><br><span class="line">    if (mapperProxyFactory &#x3D;&#x3D; null)</span><br><span class="line">      throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">      return mapperProxyFactory.newInstance(sqlSession);                                                                                 &#x2F;&#x2F; @2</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>根据Mapper接口与SqlSession创建MapperProxy对象。<br>代码@1：根据接口获取MapperProxyFactory。<br>代码@2：调用MapperProxyFactory的newInstance创建MapperProxy对象。</p><p>到目前为止Mybatis Mapper的初始化构造过程就完成一半了，即MapperScannerConfigurer通过包扫描，然后构建MapperProxy，但此时MapperProxy还未与mapper.xml文件中的sql语句建立关联，由于篇幅的原因，将在下一节重点介绍其关联关系建立的流程。接下来我们先一睹MapperProxy对象，毕竟这是本文最终要创建的对象，也为后续SQL的执行流程做个简单准备。</p><h3 id="1-5-MapperProxy"><a href="#1-5-MapperProxy" class="headerlink" title="1.5 MapperProxy"></a>1.5 MapperProxy</h3><p>类图如下：<br><img src="https://img-blog.csdnimg.cn/2019052121164389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上面的类都比较简单，MapperMethod，代表一个一个的Mapper方法，从SqlCommand可以看出，每一个MapperMethod都会对应一条SQL语句。</p><p>下面以一张以SqlSessionFacotry为视角的各核心类的关系图：<br><img src="https://img-blog.csdnimg.cn/20190521211724837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>温馨提示：本文只阐述了Mybatis MapperProxy的创建流程，MapperProxy与*.Mapper.xml即SQL是如何关联的本文未涉及到，这部分的内容请看下文，即将发布。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;MapperScannerConfigurer，Spring整合Mybatis的核心类，其作用是扫描项目中Dao类，将其创建为Mybatis的Maper对象即MapperProxy对象。&lt;/p&gt;
&lt;p&gt;首先进入源码学习之前，我们先看一下在项目中的配置文件信息。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190521205718910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;我们注意到这里有两三个与Mapper相关的配置：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SqlSessionFactory#mapperLocations，指定xml文件的配置路径。&lt;/li&gt;
&lt;li&gt;SqlSessionFactory#configLocation，指定mybaits的配置文件，该配置文件也可以配置mapper.xml的配置路径信息。&lt;/li&gt;
&lt;li&gt;MapperScannerConfigurer，扫描Mapper的java类(DAO)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文的行文思路如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Mybatis MapperProxy对象的扫描与构建&lt;/li&gt;
&lt;li&gt;Mapper类与SQL语句如何建立关联&lt;br&gt;这部分主要阐述Java类的运行实例Mapper对象（例如UserMapper、BookMapper)是如何与mapper.xml(UserMapper.xml、BookMapper.xml文件建立联系的)。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Mybatis-MapperProxy对象创建流程&quot;&gt;&lt;a href=&quot;#Mybatis-MapperProxy对象创建流程&quot; class=&quot;headerlink&quot; title=&quot;Mybatis MapperProxy对象创建流程&quot;&gt;&lt;/a&gt;Mybatis MapperProxy对象创建流程&lt;/h2&gt;&lt;p&gt;下面的源码分析或许会比较枯燥，进入源码分析之前，先给出MapperProxy的创建序列图。&lt;/p&gt;
&lt;h3 id=&quot;1-1-MapperProxy创建序列图&quot;&gt;&lt;a href=&quot;#1-1-MapperProxy创建序列图&quot; class=&quot;headerlink&quot; title=&quot;1.1 MapperProxy创建序列图&quot;&gt;&lt;/a&gt;1.1 MapperProxy创建序列图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190521215333400.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-2-MapperScannerConfigurer详解&quot;&gt;&lt;a href=&quot;#1-2-MapperScannerConfigurer详解&quot; class=&quot;headerlink&quot; title=&quot;1.2 MapperScannerConfigurer详解&quot;&gt;&lt;/a&gt;1.2 MapperScannerConfigurer详解&lt;/h3&gt;&lt;p&gt;MapperScannerConfigurer的类图如下所示：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190521210119671.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;MapperScannerConfigurer实现Spring Bean生命周期相关的类：BeanNameAware、ApplicationContextAware、BeanFactoryPostProcessor、InitializingBean、BeanDefinitionRegistryPostProcessor，我们先来看一下这些接口对应的方法的调用时机：&lt;/p&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://example.com/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://example.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>使用流收集数据之toList、joining、groupBy(多字段分组)</title>
    <link href="http://example.com/posts/79082d0a.html"/>
    <id>http://example.com/posts/79082d0a.html</id>
    <published>2020-12-09T14:45:35.000Z</published>
    <updated>2020-12-11T04:25:11.168Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文将从Collectos中构建收集器入手，详细介绍java8提供了哪些收集器，重点介绍:toList、toSet、toCollection、joining、groupBy(包含多级分组)、reducing的核心实现原理与使用示例。</p><h2 id="1、toList、toSet、toCollection"><a href="#1、toList、toSet、toCollection" class="headerlink" title="1、toList、toSet、toCollection"></a>1、toList、toSet、toCollection</h2><p>首先对流中的数据进行计算，最终返回的数据类型为集合。Collectors中定义了如下3集合类收集器，其声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, C extends Collection&lt;T&gt;&gt; Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory)</span><br></pre></td></tr></table></figure><blockquote><p>温馨提示：建议根据上篇的理论，再来反推一下这些Collector中的核心属性的值，例如supplier、accumulator、combiner、characteristics。不过特别注意，toList、toCollection是不支持并行运行的，但toSet()方法支持并行运行。</p></blockquote><p>我们首先来看一个一直使用的示例，返回菜单中所有菜品的名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_toList</span><span class="params">(List&lt;Dish&gt; menu)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; names = menu.stream().map(Dish::getName)</span><br><span class="line">                        .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于toList方法的实现原理已经在 <a href="https://blog.csdn.net/prestigeding/article/details/90813819">java8读书笔记：探究java8流收集数据原理</a>中也详细介绍，故本篇不再重点介绍。</p><h2 id="2、joining"><a href="#2、joining" class="headerlink" title="2、joining"></a>2、joining</h2><p>Collectors定义了如下3个重载方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter,</span><br><span class="line">    CharSequence prefix, CharSequence suffix)</span><br></pre></td></tr></table></figure><h3 id="2-1-joining"><a href="#2-1-joining" class="headerlink" title="2.1 joining"></a>2.1 joining</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;CharSequence, StringBuilder, String&gt;(</span><br><span class="line">        StringBuilder::<span class="keyword">new</span>, StringBuilder::append,</span><br><span class="line">        (r1, r2) -&gt; &#123; r1.append(r2); <span class="keyword">return</span> r1; &#125;,</span><br><span class="line">        StringBuilder::toString, CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Supplier&lt; A&gt; supplier()<br>其函数为StringBuilder::new，即通过该方法创建一个StringBuilder方法，作为累积器的初始值。</li><li>BiConsumer&lt;A, T&gt; accumulator<br>累积器：StringBuilder::append，即会对流中的元素执行追加。</li><li>BinaryOperator&lt; A&gt; combiner<br>组合器，也是调用append方法，进行字符串的规约。</li><li>Function&lt;A,R&gt; finisher<br>转换器：由于累积器返回的最终对象为StringBuilder，并不是目标String类型，故需要调用StringBuilder#toString方法进行转换</li><li>Set&lt; Characteristics&gt; characteristics<br>无任何行为。</li></ul><p>从上面的函数定义我们可以得出该方法的作用：针对字符串流，会对流中的元素执行字符的追加动作，流元素之间没有分隔符号，示例如下：<br><img src="https://img-blog.csdnimg.cn/20190609173712998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2-2-joining-CharSequence-delimiter"><a href="#2-2-joining-CharSequence-delimiter" class="headerlink" title="2.2 joining(CharSequence delimiter)"></a>2.2 joining(CharSequence delimiter)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter) &#123;</span><br><span class="line">    <span class="keyword">return</span> joining(delimiter, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter,</span><br><span class="line">                                                         CharSequence prefix,</span><br><span class="line">                                                         CharSequence suffix) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(</span><br><span class="line">            () -&gt; <span class="keyword">new</span> StringJoiner(delimiter, prefix, suffix),</span><br><span class="line">            StringJoiner::add, StringJoiner::merge,</span><br><span class="line">            StringJoiner::toString, CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Supplier&lt; A&gt; supplier()<br>其函数为() -&gt; new StringJoiner(delimiter, prefix, suffix)，累积器的初始值为StringJoiner。</li><li>BiConsumer&lt;A, T&gt; accumulator<br>累积器：StringJoiner::append，即会对流中的元素执行追加。</li><li>BinaryOperator&lt; A&gt; combiner<br>组合器，StringJoiner::merge。</li><li>Function&lt;A,R&gt; finisher<br>转换器：由于累积器返回的最终对象为StringBuilder，并不是目标String类型，故需要调用StringBuilder#toString方法进行转换</li><li>Set&lt; Characteristics&gt; characteristics<br>无任何行为。</li></ul><p>其示例如下：<br><img src="https://img-blog.csdnimg.cn/20190609173901452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><a id="more"></a><h2 id="3、聚合相关收集器"><a href="#3、聚合相关收集器" class="headerlink" title="3、聚合相关收集器"></a>3、聚合相关收集器</h2><p>聚合相关收集器，主要包括minBy、maxBy、sum、avg等相关函数，其主要方法声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; minBy(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; maxBy(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Long&gt; summingLong(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; summingDouble(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingLong(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingDouble(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br></pre></td></tr></table></figure><p>上面这些方法比较简单，下面举个简单的例子介绍其使用：<br><img src="https://img-blog.csdnimg.cn/20190609174021453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4-分组"><a href="#4-分组" class="headerlink" title="4 分组"></a>4 分组</h2><p>Collectors提供了3个groupingBy重载方法，我们一个一个来理解。</p><h3 id="4-1-从示例入手"><a href="#4-1-从示例入手" class="headerlink" title="4.1 从示例入手"></a>4.1 从示例入手</h3><p>我们从其中一个最简单的函数说起，从而慢慢引出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(</span><br><span class="line">             Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier)</span><br></pre></td></tr></table></figure><ul><li>Collector&lt;T, ?, Map&lt;K, List&lt; T&gt;&gt;&gt;<br>首先我们先来关注该方法的返回值Collector&lt;T, ?, Map&lt;K,List&lt; T&gt;&gt;，其最终返回的数据类型为：Map&lt;K, List&lt; T&gt;&gt;</li><li>Function&lt;? super T, ? extends K&gt; classifier<br>分类函数。</li></ul><p>示例如下：例如如下是购物车实体类，并且初始化数据如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShopCar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sellerId;</span><br><span class="line">    <span class="keyword">private</span> String sellerName;</span><br><span class="line">    <span class="keyword">private</span> String goodsName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> buyerId;</span><br><span class="line">    <span class="keyword">private</span> String buyerName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化数据如下：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;ShopCar&gt; <span class="title">initShopCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> ShopCar(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;天猫&quot;</span> , <span class="string">&quot;华为手机&quot;</span>, <span class="number">1</span> , <span class="string">&quot;dingw&quot;</span>, <span class="number">5</span>),</span><br><span class="line">            <span class="keyword">new</span> ShopCar(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;京东&quot;</span> , <span class="string">&quot;华为手机&quot;</span>, <span class="number">2</span> , <span class="string">&quot;ly&quot;</span>, <span class="number">2</span>),</span><br><span class="line">            <span class="keyword">new</span> ShopCar(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;京东&quot;</span> , <span class="string">&quot;小米手机&quot;</span>, <span class="number">3</span> , <span class="string">&quot;zhl&quot;</span>, <span class="number">3</span>),</span><br><span class="line">            <span class="keyword">new</span> ShopCar(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;1号店&quot;</span> , <span class="string">&quot;华为手机&quot;</span>, <span class="number">1</span> , <span class="string">&quot;dingw&quot;</span>, <span class="number">5</span>),</span><br><span class="line">            <span class="keyword">new</span> ShopCar(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;天猫&quot;</span> , <span class="string">&quot;苹果手机&quot;</span>, <span class="number">1</span> , <span class="string">&quot;dingw&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们看一下java8之前的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_group_jdk7</span><span class="params">(List&lt;ShopCar&gt; shopCars)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, List&lt;ShopCar&gt;&gt; shopBySellerNameMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(ShopCar c : shopCars ) &#123;</span><br><span class="line">        <span class="keyword">if</span>(shopBySellerNameMap.containsKey( c.getSellerName() )) &#123;</span><br><span class="line">            shopBySellerNameMap.get(c.getSellerName()).add(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;ShopCar&gt; aList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            shopBySellerNameMap.put(c.getSellerName(), aList);</span><br><span class="line">            aList.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print(shopBySellerNameMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码应该很容易理解，根据商家名称进行分组，拥有相同商家的名称的购物车项组成一个集合，最终返回Map&lt;String, List&lt; ShopCar &gt;&gt;类型的数据。</p><p>那如何使用java8的流分组特性来编写对应的代码呢？下面的思考过程非常关键，经过前面的学习，我想大家应该也具备了如下分析与编写的能力？</p><p>首先其声明如下：public static &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt; T&gt;&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier)，那在本例中，T,K这两个参数代表什么意思呢？</p><ul><li>T : ShopCar</li><li>K : String (sellerName的类型)<br>其判断的主要依据为groupingBy方法返回的参数Collector&lt;T, ?, Map&lt;K, List&lt; T&gt;&gt;&gt;，代表&lt;T, A, R&gt;，其中最后一个泛型参数R对应的就是本例需要返回的Map&lt;K, List&lt; T&gt;&gt;，故分析出T,K代表的含义。</li></ul><p>然后再看其参数：Function&lt;? super T, ? extends K&gt; classifier,即接受的函数式编程接口为T -&gt; K，即通过ShopCar 返回一个String，又根据其名称可知，该函数为一个分类函数，故基本可以写成如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_group_jdk8</span><span class="params">(List&lt;ShopCar&gt; shopCars)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, List&lt;ShopCar&gt;&gt; shopBySellerNameMap =  </span><br><span class="line">                 shopCars</span><br><span class="line">                     .stream()</span><br><span class="line">                     .collect(Collectors.groupingBy(ShopCar::getSellerName));</span><br><span class="line">                   <span class="comment">//.collect(Collectors.groupingBy( (ShopCar c) -&gt; c.getSellerName() ))</span></span><br><span class="line">    print(shopBySellerNameMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其运行效果如下：<br><img src="https://img-blog.csdnimg.cn/20190609174540775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">为了加深对groupingBy方法的理解，接下来我们重点分析一下其源码的实现。</p><h3 id="4-2-源码分析groupingBy方法"><a href="#4-2-源码分析groupingBy方法" class="headerlink" title="4.2 源码分析groupingBy方法"></a>4.2 源码分析groupingBy方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier) &#123;  <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">return</span> groupingBy(classifier, toList());                                                                     <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：分类参数，已经在上文中详细介绍。<br>代码@2：调用groupingBy重载方法，传入的参数为toList()，有点意思，传入的参数为Collectors.toList()，结合上文中的示例，需要返回值类型为：Map&lt;String, List&lt; ShopCar&gt;&gt;，与这里的List对应起来了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier, Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</span><br><span class="line">    <span class="keyword">return</span> groupingBy(classifier, HashMap::<span class="keyword">new</span>, downstream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该重载方法，再次调用3个参数的groupingBy方法，其中第二个参数为HashMap::new，即创建一个Map对象，我们重点关注3个参数的groupingBy。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt; Collector&lt;T, ?, M&gt; groupingBy(</span><br><span class="line">                          Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier, </span><br><span class="line">Supplier&lt;M&gt; mapFactory,</span><br><span class="line">Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123; <span class="comment">// @1</span></span><br><span class="line">    Supplier&lt;A&gt; downstreamSupplier = downstream.supplier();        <span class="comment">// @2 start</span></span><br><span class="line">    BiConsumer&lt;A, ? <span class="keyword">super</span> T&gt; downstreamAccumulator = downstream.accumulator();</span><br><span class="line">    BiConsumer&lt;Map&lt;K, A&gt;, T&gt; accumulator = (m, t) -&gt; &#123;</span><br><span class="line">        K key = Objects.requireNonNull(classifier.apply(t), <span class="string">&quot;element cannot be mapped to a null key&quot;</span>);</span><br><span class="line">        A container = m.computeIfAbsent(key, k -&gt; downstreamSupplier.get());</span><br><span class="line">        downstreamAccumulator.accept(container, t);</span><br><span class="line">    &#125;; <span class="comment">// @2 end</span></span><br><span class="line"></span><br><span class="line">    BinaryOperator&lt;Map&lt;K, A&gt;&gt; merger = Collectors.&lt;K, A, Map&lt;K, A&gt;&gt;mapMerger(downstream.combiner());   <span class="comment">// @3</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Supplier&lt;Map&lt;K, A&gt;&gt; mangledFactory = (Supplier&lt;Map&lt;K, A&gt;&gt;) mapFactory;                            </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) &#123;           <span class="comment">// @4</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, CH_ID);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                                                                                            <span class="comment">// @5</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Function&lt;A, A&gt; downstreamFinisher = (Function&lt;A, A&gt;) downstream.finisher();</span><br><span class="line">        Function&lt;Map&lt;K, A&gt;, M&gt; finisher = intermediate -&gt; &#123;</span><br><span class="line">            intermediate.replaceAll((k, v) -&gt; downstreamFinisher.apply(v));</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            M castResult = (M) intermediate;</span><br><span class="line">            <span class="keyword">return</span> castResult;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, finisher, CH_NOID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：参数介绍：</p><ul><li>Function&lt;? super T, ? extends K&gt; classifier<br>分类函数。</li><li>Supplier&lt; M&gt; mapFactory<br>map构建函数。（）-&gt; Map</li><li>Collector&lt;? super T, A, D&gt; downstream<br>下游收集器，在上面的示例中，该参数为Collectos.toList()。</li></ul><p>代码@2：构建最终的累积器。其实现要点如下：</p><ul><li>对流中的元素，使用Function&lt;? super T, ? extends K&gt; classifier，获取对应的分类键值。</li><li>使用mangledFactory创建累积初始值，并调用Map#computeIfAbsent方法，放入的值为：downstreamSupplier.get()。可以类比上例中Map&lt;String, List&lt; T&gt;&gt;，请结合如下代码进行理解：<br><img src="https://img-blog.csdnimg.cn/20190609174846127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><p>代码@3：构建最终的组合器，这里使用的是Collectos.mapMerger，其内部的实现就是对每个元素，执行map#merge方法。</p><p>代码@4：如果收集器的行为为IDENTITY_FINISH，直接根据上面已创建的累积器、组合器，创建一个最终的收集器。</p><p>代码@5：如果收集器的行为不包含IDENTITY_FINISH，则需要最终调用原收集器的finisher方法。才能最终需要返回的类型。</p><p>groupingBy的原理就讲解到这里，我们接下来思考如下场景：<br>还是上面的购物车场景，现在要求先按照供应商名称分组，然后按照购买人分组（即多级分组），类似于SQL group by sellerId,buyerId。</p><p>思考过程：首先二级分类需要返回的数据类型为Map&lt;String /** sellerName*/,   Map&lt;String、/** buyerId*/，List&lt; ShopCar&gt;&gt; &gt;,而只有一个参数的groupingBy(Function&lt;? super T, ? extends K&gt; classifier)，只接受一个分类参数，其内部会调用两个参数的groupingBy(Function&lt;? super T, ? extends K&gt; classifier,Collector&lt;? super T, A, D&gt; downstream)，默认第二个参数为Collectors.toList()，故我们可以做的文章是改变这个默认值，传入符合业务场景的收集器，结合目前的需求，很显然，该参数应该是支持分组的收集器，即应该可以通过嵌套groupingBy方法，实现二级分组，其具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二级分组示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> shopCars</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_level_group</span><span class="params">(List&lt;ShopCar&gt; shopCars)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Map&lt;String, List&lt;ShopCar&gt;&gt;&gt;  result = </span><br><span class="line">        shopCars.stream().collect(Collectors.groupingBy(ShopCar::getSellerName,</span><br><span class="line">                                    Collectors.groupingBy(ShopCar::getBuyerName)));</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>温馨提示：上面介绍的分组，主要的Map存储结构为HashMap，java8为ConcurrentMap对应类继承体系提供了对应的分组函数：groupingByConcurrent，其使用方法与groupingBy方法类型，故不重复介绍。</p><h2 id="5、-partitioningBy"><a href="#5、-partitioningBy" class="headerlink" title="5、 partitioningBy"></a>5、 partitioningBy</h2><p>分区，分区可以看出是分组的特殊化，接受的分类函数返回boolean类型，即是谓词Predicate&lt;? super T&gt; predicate。其声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, D, A&gt; Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate, Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) </span><br></pre></td></tr></table></figure><p>由于其用法与分组类似，故这里就一笔带过了。</p><h2 id="6、-reducing"><a href="#6、-reducing" class="headerlink" title="6、 reducing"></a>6、 reducing</h2><p>规约。其函数声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U&gt; Collector&lt;T, ?, U&gt; reducing(U identity, Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper, BinaryOperator&lt;U&gt; op)</span><br></pre></td></tr></table></figure><p>其参数如下：</p><ul><li>U identity<br>规约初始值。</li><li>Function&lt;? super T, ? extends U&gt; mapper<br>累加器函数。</li><li>BinaryOperator<U> op<br>组合器函数。<br>关于Collectors.reducing，建议可以直接使用Stream自身提供的reducing方法。</li></ul></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将从Collectos中构建收集器入手，详细介绍java8提供了哪些收集器，重点介绍:toList、toSet、toCollection、joining、groupBy(包含多级分组)、reducing的核心实现原理与使用示例。&lt;/p&gt;
&lt;h2 id=&quot;1、toList、toSet、toCollection&quot;&gt;&lt;a href=&quot;#1、toList、toSet、toCollection&quot; class=&quot;headerlink&quot; title=&quot;1、toList、toSet、toCollection&quot;&gt;&lt;/a&gt;1、toList、toSet、toCollection&lt;/h2&gt;&lt;p&gt;首先对流中的数据进行计算，最终返回的数据类型为集合。Collectors中定义了如下3集合类收集器，其声明如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; Collector&amp;lt;T, ?, List&amp;lt;T&amp;gt;&amp;gt; toList()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; Collector&amp;lt;T, ?, Set&amp;lt;T&amp;gt;&amp;gt; toSet()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T, C extends Collection&amp;lt;T&amp;gt;&amp;gt; Collector&amp;lt;T, ?, C&amp;gt; toCollection(Supplier&amp;lt;C&amp;gt; collectionFactory)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;温馨提示：建议根据上篇的理论，再来反推一下这些Collector中的核心属性的值，例如supplier、accumulator、combiner、characteristics。不过特别注意，toList、toCollection是不支持并行运行的，但toSet()方法支持并行运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们首先来看一个一直使用的示例，返回菜单中所有菜品的名称：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test_toList&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(List&amp;lt;Dish&amp;gt; menu)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List&amp;lt;String&amp;gt; names = menu.stream().map(Dish::getName)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .collect(Collectors.toList());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于toList方法的实现原理已经在 &lt;a href=&quot;https://blog.csdn.net/prestigeding/article/details/90813819&quot;&gt;java8读书笔记：探究java8流收集数据原理&lt;/a&gt;中也详细介绍，故本篇不再重点介绍。&lt;/p&gt;
&lt;h2 id=&quot;2、joining&quot;&gt;&lt;a href=&quot;#2、joining&quot; class=&quot;headerlink&quot; title=&quot;2、joining&quot;&gt;&lt;/a&gt;2、joining&lt;/h2&gt;&lt;p&gt;Collectors定义了如下3个重载方法。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Collector&amp;lt;CharSequence, ?, String&amp;gt; joining()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Collector&amp;lt;CharSequence, ?, String&amp;gt; joining(CharSequence delimiter)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Collector&amp;lt;CharSequence, ?, String&amp;gt; joining(CharSequence delimiter,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CharSequence prefix, CharSequence suffix)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;2-1-joining&quot;&gt;&lt;a href=&quot;#2-1-joining&quot; class=&quot;headerlink&quot; title=&quot;2.1 joining&quot;&gt;&lt;/a&gt;2.1 joining&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Collector&amp;lt;CharSequence, ?, String&amp;gt; joining() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CollectorImpl&amp;lt;CharSequence, StringBuilder, String&amp;gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        StringBuilder::&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;, StringBuilder::append,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        (r1, r2) -&amp;gt; &amp;#123; r1.append(r2); &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; r1; &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        StringBuilder::toString, CH_NOID);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Supplier&amp;lt; A&amp;gt; supplier()&lt;br&gt;其函数为StringBuilder::new，即通过该方法创建一个StringBuilder方法，作为累积器的初始值。&lt;/li&gt;
&lt;li&gt;BiConsumer&amp;lt;A, T&amp;gt; accumulator&lt;br&gt;累积器：StringBuilder::append，即会对流中的元素执行追加。&lt;/li&gt;
&lt;li&gt;BinaryOperator&amp;lt; A&amp;gt; combiner&lt;br&gt;组合器，也是调用append方法，进行字符串的规约。&lt;/li&gt;
&lt;li&gt;Function&amp;lt;A,R&amp;gt; finisher&lt;br&gt;转换器：由于累积器返回的最终对象为StringBuilder，并不是目标String类型，故需要调用StringBuilder#toString方法进行转换&lt;/li&gt;
&lt;li&gt;Set&amp;lt; Characteristics&amp;gt; characteristics&lt;br&gt;无任何行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上面的函数定义我们可以得出该方法的作用：针对字符串流，会对流中的元素执行字符的追加动作，流元素之间没有分隔符号，示例如下：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190609173712998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-2-joining-CharSequence-delimiter&quot;&gt;&lt;a href=&quot;#2-2-joining-CharSequence-delimiter&quot; class=&quot;headerlink&quot; title=&quot;2.2 joining(CharSequence delimiter)&quot;&gt;&lt;/a&gt;2.2 joining(CharSequence delimiter)&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Collector&amp;lt;CharSequence, ?, String&amp;gt; joining(CharSequence delimiter) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; joining(delimiter, &lt;span class=&quot;string&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Collector&amp;lt;CharSequence, ?, String&amp;gt; joining(CharSequence delimiter,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                         CharSequence prefix,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                         CharSequence suffix) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CollectorImpl&amp;lt;&amp;gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            () -&amp;gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; StringJoiner(delimiter, prefix, suffix),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            StringJoiner::add, StringJoiner::merge,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            StringJoiner::toString, CH_NOID);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Supplier&amp;lt; A&amp;gt; supplier()&lt;br&gt;其函数为() -&amp;gt; new StringJoiner(delimiter, prefix, suffix)，累积器的初始值为StringJoiner。&lt;/li&gt;
&lt;li&gt;BiConsumer&amp;lt;A, T&amp;gt; accumulator&lt;br&gt;累积器：StringJoiner::append，即会对流中的元素执行追加。&lt;/li&gt;
&lt;li&gt;BinaryOperator&amp;lt; A&amp;gt; combiner&lt;br&gt;组合器，StringJoiner::merge。&lt;/li&gt;
&lt;li&gt;Function&amp;lt;A,R&amp;gt; finisher&lt;br&gt;转换器：由于累积器返回的最终对象为StringBuilder，并不是目标String类型，故需要调用StringBuilder#toString方法进行转换&lt;/li&gt;
&lt;li&gt;Set&amp;lt; Characteristics&amp;gt; characteristics&lt;br&gt;无任何行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其示例如下：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190609173901452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="java8" scheme="http://example.com/categories/java8/"/>
    
    
    <category term="java8" scheme="http://example.com/tags/java8/"/>
    
    <category term="Lambda" scheme="http://example.com/tags/Lambda/"/>
    
    <category term="流计算" scheme="http://example.com/tags/%E6%B5%81%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>探究java8流收集数据原理</title>
    <link href="http://example.com/posts/bfa9fca1.html"/>
    <id>http://example.com/posts/bfa9fca1.html</id>
    <published>2020-12-09T14:43:35.000Z</published>
    <updated>2020-12-11T04:24:53.250Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文揭示如何学习一门新技术，从示例入手，重点阐述Stream#collect方法的实现原理，为更好的使用java8中流来收集数据。</p><p>我们在前面的文章中反复使用的场景：获取菜单中所有菜品的名称，返回一个集合，其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_toList</span><span class="params">(List&lt;Dish&gt; menu)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; names = menu.stream().map(Dish::getName)</span><br><span class="line">                        .collect(Collectors.toList()); <span class="comment">// @1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(String s : names) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Stream.collect这个终端操作进行数据收集，至于如何收集，则由该方法的参数来决定(Collector)，即行为参数化。</p><p>代码@1：collect(Collectors.toList()) 的意思就是返回List，这里涉及到两个关键，一个是Stream#collect方法，另外一个就是其参数Collectors.toList()。</p><p>接下来我们将以上述两个突破点来揭开如何使用java8的流来收集数据。</p><h2 id="1、Stream-collect"><a href="#1、Stream-collect" class="headerlink" title="1、Stream#collect"></a>1、Stream#collect</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ReferencePipeline#collect</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> P_OUT, A, R&gt; collector)</span> </span>&#123;   <span class="comment">// @1</span></span><br><span class="line">    A container;</span><br><span class="line">    <span class="keyword">if</span> (isParallel()</span><br><span class="line">            &amp;&amp; (collector.characteristics().contains(Collector.Characteristics.CONCURRENT))</span><br><span class="line">            &amp;&amp; (!isOrdered() || collector.characteristics().contains(Collector.Characteristics.UNORDERED))) &#123;   <span class="comment">// @2</span></span><br><span class="line">        container = collector.supplier().get();                                                                 <span class="comment">// @3</span></span><br><span class="line">        BiConsumer&lt;A, ? <span class="keyword">super</span> P_OUT&gt; accumulator = collector.accumulator();</span><br><span class="line">        forEach(u -&gt; accumulator.accept(container, u));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                                                                                                     <span class="comment">// @4</span></span><br><span class="line">        container = evaluate(ReduceOps.makeRef(collector));                                                                                              </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)                    <span class="comment">// @5</span></span><br><span class="line">           ? (R) container</span><br><span class="line">           : collector.finisher().apply(container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：函数声明，该方法返回的结果类型为R，传入的行为参数接口为Collector。<br>代码@2：判断是否符合并行化累积与规约的条件。</p><ul><li>是否是并行流，例如上例中创建流的代码为menu.stream()，该方法的流是非并行化流，如果要支持并行化执行，需要满足的第一个条件就是需要使用menu.parallelStream()方法返回的流。</li><li>Collector(收集器，行为化参数)中收集器行为集合中是否包含Characteristics.CONCURRENT(并行执行)，如果不包含该行为，则不支持并行执行。</li><li>原始流是否有顺序 或 者 收集器的行为集合中明确包含Characteristics.UNORDERED(不要求顺序性)。<br>上述三个条件必须同时满足，才能并行执行，否则串行执行。</li></ul><p>代码@3：并行执行收集动作。</p><p>代码@4：串行执行收集动作。</p><p>代码@5：如果收集器收集行为集合中包含Characteristics.IDENTITY_FINISH，则直接返回原始值，否则使用Collector.finishier()方式对计算的值进行函数式计算。</p><p>通过上面的代码，我们应该对Characteristics枚举类型中的3个值不难得出如下类型：</p><ul><li>CONCURRENT<br>收集器行为，表示收集其中的累积函数是否支持并行执行。</li><li>Characteristics.UNORDERED<br>收集器行为，表示整个收集期间，没有顺序要求。</li><li>Characteristics.IDENTITY_FINISH<br>收集器行为，表示可以忽略Collector.finsher()定义的最终转换函数，直接返回累积之后的结果即可。</li></ul><blockquote><p>疑问？代码@3,这段代码不是很好理解，该怎么继续往下深入呢？</p></blockquote><p>针对上面看不太懂的代码，我的处理办法是先转移思路，看一下Collector接口以及示例中Collectos.toList()返回的收集器是什么(重点关注返回的Collector中具体属性)。</p><a id="more"></a><h2 id="2、Collector接口"><a href="#2、Collector接口" class="headerlink" title="2、Collector接口"></a>2、Collector接口</h2><p><img src="https://img-blog.csdnimg.cn/20190604211337662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>收集器中的泛型参数说明如下：</p><ul><li>T ：累积器中一个操作数类型</li><li>A： 累积器中的初始值类型</li><li>R：返回值的类型，例如List&lt; R &gt;。</li></ul><p>其属性一览如下：</p><ul><li>Supplier&lt; A &gt; supplier()<br>该函数式接口，大家应该都非常熟悉了，其函数声明如下：() -&gt; T，通常用于构建对象，那这里是构建什么对象呢？这是下一个待解疑问。</li><li>BiConsumer&lt;A, T&gt; accumulator()<br>从名字命名来看，应该是返回累积器，（T,U）-&gt; void。通常用于输入两个参数，对其进行处理，但返回void类型。</li><li>BinaryOperator&lt; A &gt; combiner()<br>从名字命令来看，应该是组合器（请参考流计算函数reduce)。</li><li>Function&lt;A, R&gt; finisher()<br>最终函数，如果收集器行为包含IDENTITY_FINISH，则无需使用该函数对累积器产生的结果进行处理，否则使用该函数对累积器结果进行最后的处理。</li><li>Set&lt; Characteristics &gt; characteristics()<br>累积器行为，在上文已做详细介绍。</li></ul><p>其supplier函数到底是干什么的呢？对上面的方法都是基于名字来推测的（当然JDK代码非常优雅，根据名字去猜测，准确度还是很高的），但如何确认呢？这个时候我们还是结合Collectos.toList()方法返回的Collector来做进一步推断。</p><h2 id="3、Collectors-toList"><a href="#3、Collectors-toList" class="headerlink" title="3、Collectors.toList()"></a>3、Collectors.toList()</h2><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>, List::add,</span><br><span class="line">                               (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">                               CH_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Collector的第一个参数Supplier，在这里为ArrayList::new，即调用supper.get()方法将返回一个List。</li><li>Collector的第二个参数accumulator:累积器，这里是List:add方法。</li><li>Collector的第三个参数combiner:组合器，这里就是(left, right) -&gt; {left.addAll(right);return left;}</li><li>Collector的第四个函数characteristics：收集器的行为，这里为CH_IL，其选项为：IDENTITY_FINISH。</li></ul><p>有了上面这些知识，我们再来看如下这段代码：<br><img src="https://img-blog.csdnimg.cn/2019060421180264.png" alt="在这里插入图片描述"><br>1、A container：累积器的初始值，如果使用Collectors.toList()，则这里会返回List<T>的对象。<br>2、获取collector中定义的累积器。<br>3、遍历流，执行累积器动作，其中形式参数u，代表流中的一个个元素。</p><p>至于forEach方法，底层流的具体实现，本文就不再往深探究。</p><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>java8 使用流来收集数据的基本用法：</p><ul><li>使用流stream的collect对象进行数据收集，其参数为Collector函数是编程接口，具体的收集逻辑由该接口来指定。</li><li>流的收集其具备基本的属性即作用：<ul><li>Supplier&lt; A &gt; supplier()<br>通过该函数式编程接口，返回累积器的初始值。</li><li>BiConsumer&lt;A, T&gt; accumulator<br>累积器函数。</li><li>BinaryOperator&lt; A &gt; combiner<br>组合器，可以参考函数式编程接口的reduce方法。</li><li>Set&lt; Characteristics &gt; characteristics<br>收集器行为。</li></ul></li><li>java8中的Collectors提供了很多默认的收集器，例如Collectors.toList()方法，下一节我们会根据该类，详细介绍在java8中默认提供的收集器，指导我们如何使用java8中的流来收集数据。</li></ul><p>下一节，将以Collectos类为入口，详细介绍java8中默认提供的收集器，已经如何使用。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文揭示如何学习一门新技术，从示例入手，重点阐述Stream#collect方法的实现原理，为更好的使用java8中流来收集数据。&lt;/p&gt;
&lt;p&gt;我们在前面的文章中反复使用的场景：获取菜单中所有菜品的名称，返回一个集合，其代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test_toList&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(List&amp;lt;Dish&amp;gt; menu)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List&amp;lt;String&amp;gt; names = menu.stream().map(Dish::getName)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .collect(Collectors.toList()); &lt;span class=&quot;comment&quot;&gt;// @1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(String s : names) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(s);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过Stream.collect这个终端操作进行数据收集，至于如何收集，则由该方法的参数来决定(Collector)，即行为参数化。&lt;/p&gt;
&lt;p&gt;代码@1：collect(Collectors.toList()) 的意思就是返回List，这里涉及到两个关键，一个是Stream#collect方法，另外一个就是其参数Collectors.toList()。&lt;/p&gt;
&lt;p&gt;接下来我们将以上述两个突破点来揭开如何使用java8的流来收集数据。&lt;/p&gt;
&lt;h2 id=&quot;1、Stream-collect&quot;&gt;&lt;a href=&quot;#1、Stream-collect&quot; class=&quot;headerlink&quot; title=&quot;1、Stream#collect&quot;&gt;&lt;/a&gt;1、Stream#collect&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ReferencePipeline#collect&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &amp;lt;R, A&amp;gt; &lt;span class=&quot;function&quot;&gt;R &lt;span class=&quot;title&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Collector&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; P_OUT, A, R&amp;gt; collector)&lt;/span&gt; &lt;/span&gt;&amp;#123;   &lt;span class=&quot;comment&quot;&gt;// @1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    A container;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isParallel()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;amp;&amp;amp; (collector.characteristics().contains(Collector.Characteristics.CONCURRENT))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;amp;&amp;amp; (!isOrdered() || collector.characteristics().contains(Collector.Characteristics.UNORDERED))) &amp;#123;   &lt;span class=&quot;comment&quot;&gt;// @2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        container = collector.supplier().get();                                                                 &lt;span class=&quot;comment&quot;&gt;// @3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        BiConsumer&amp;lt;A, ? &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; P_OUT&amp;gt; accumulator = collector.accumulator();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        forEach(u -&amp;gt; accumulator.accept(container, u));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;                                                                                                     &lt;span class=&quot;comment&quot;&gt;// @4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        container = evaluate(ReduceOps.makeRef(collector));                                                                                              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)                    &lt;span class=&quot;comment&quot;&gt;// @5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           ? (R) container&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           : collector.finisher().apply(container);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码@1：函数声明，该方法返回的结果类型为R，传入的行为参数接口为Collector。&lt;br&gt;代码@2：判断是否符合并行化累积与规约的条件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否是并行流，例如上例中创建流的代码为menu.stream()，该方法的流是非并行化流，如果要支持并行化执行，需要满足的第一个条件就是需要使用menu.parallelStream()方法返回的流。&lt;/li&gt;
&lt;li&gt;Collector(收集器，行为化参数)中收集器行为集合中是否包含Characteristics.CONCURRENT(并行执行)，如果不包含该行为，则不支持并行执行。&lt;/li&gt;
&lt;li&gt;原始流是否有顺序 或 者 收集器的行为集合中明确包含Characteristics.UNORDERED(不要求顺序性)。&lt;br&gt;上述三个条件必须同时满足，才能并行执行，否则串行执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码@3：并行执行收集动作。&lt;/p&gt;
&lt;p&gt;代码@4：串行执行收集动作。&lt;/p&gt;
&lt;p&gt;代码@5：如果收集器收集行为集合中包含Characteristics.IDENTITY_FINISH，则直接返回原始值，否则使用Collector.finishier()方式对计算的值进行函数式计算。&lt;/p&gt;
&lt;p&gt;通过上面的代码，我们应该对Characteristics枚举类型中的3个值不难得出如下类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CONCURRENT&lt;br&gt;收集器行为，表示收集其中的累积函数是否支持并行执行。&lt;/li&gt;
&lt;li&gt;Characteristics.UNORDERED&lt;br&gt;收集器行为，表示整个收集期间，没有顺序要求。&lt;/li&gt;
&lt;li&gt;Characteristics.IDENTITY_FINISH&lt;br&gt;收集器行为，表示可以忽略Collector.finsher()定义的最终转换函数，直接返回累积之后的结果即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;疑问？代码@3,这段代码不是很好理解，该怎么继续往下深入呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;针对上面看不太懂的代码，我的处理办法是先转移思路，看一下Collector接口以及示例中Collectos.toList()返回的收集器是什么(重点关注返回的Collector中具体属性)。&lt;/p&gt;</summary>
    
    
    
    <category term="java8" scheme="http://example.com/categories/java8/"/>
    
    
    <category term="java8" scheme="http://example.com/tags/java8/"/>
    
    <category term="Lambda" scheme="http://example.com/tags/Lambda/"/>
    
    <category term="流计算" scheme="http://example.com/tags/%E6%B5%81%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>数值流、Stream创建与Optional类的使用</title>
    <link href="http://example.com/posts/fcb673e6.html"/>
    <id>http://example.com/posts/fcb673e6.html</id>
    <published>2020-12-09T14:32:35.000Z</published>
    <updated>2020-12-11T04:25:49.211Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="1、数值流"><a href="#1、数值流" class="headerlink" title="1、数值流"></a>1、数值流</h2><p>不知大家还记不得，在介绍函数式编程接口中为了避免基础数据类型的装箱/拆箱带来的性能损耗，特意为函数式接口引入了基础数据类型的函数式编程接口，例如IntPredicate、LongPredicate、DoublePredicate。同样，流API也考虑到基本数据类型的装箱/拆箱会带来性能损耗，引入了数值流，例如IntStream、LongStream、DoubleStream。</p><h3 id="1-1-原始数据特化流"><a href="#1-1-原始数据特化流" class="headerlink" title="1.1 原始数据特化流"></a>1.1 原始数据特化流</h3><p>java8中提供了3个原始数据特化流，分别为IntStream、LongStream、DoubleStream。本文将以IntStream进行讲解，其他流类似，只是数据类型分别代表Long或Double。</p><h4 id="1-1-1-映射到数据流"><a href="#1-1-1-映射到数据流" class="headerlink" title="1.1.1 映射到数据流"></a>1.1.1 映射到数据流</h4><p>首先我们还是从一个示例开始本节的学习：计算菜单中所有菜品的卡路里之和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_reduce_caluli</span><span class="params">(List&lt;Dish&gt; menu)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> calories = menu.stream()</span><br><span class="line">                    .map(Dish::getCalories)</span><br><span class="line">                    .reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">    System.out.println(<span class="string">&quot;菜品中的总卡路里：&quot;</span> + calories);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面包含了一个基本数据类型的装箱/拆箱动作，java8的流API提供了mapToInt方法，直接返回int类型的流</p><p>我们先稍微看一下mapToInt的方法声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IntStream <span class="title">mapToInt</span><span class="params">(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span></span><br></pre></td></tr></table></figure><p>接受一个T-&gt;int的函数式编程接口，直接返回IntStream流对象，而且IntStream本身提供了一些常用的聚合函数，例如sum。<br>使用IntStream来实现计算菜单中所有菜品的卡路里之和，其示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_reduce_caluli_intStream</span><span class="params">(List&lt;Dish&gt; menu)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> calories = menu.stream()</span><br><span class="line">            .mapToInt(Dish::getCalories)</span><br><span class="line">            .sum();</span><br><span class="line">    System.out.println(<span class="string">&quot;菜品中的总卡路里：&quot;</span> + calories);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-2-转换回对象流"><a href="#1-1-2-转换回对象流" class="headerlink" title="1.1.2 转换回对象流"></a>1.1.2 转换回对象流</h4><p>使用了特化流例如IntStream后，将不能再自动转换为其对应的封装对象流Stream&lt; T &gt;了，我们可以随意从IntStream对象中对应的通用方法的函数声明，例如IntStream#map函数的声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IntStream <span class="title">map</span><span class="params">(IntUnaryOperator mapper)</span></span>;</span><br></pre></td></tr></table></figure><p>只能接受int -&gt; int的函数式编程接口，如果想将IntStream转回到Stream&lt; Integer &gt;，该如何处理呢？</p><p>IntStream提供了boxed()方法来实现将基础数据类型转换回对应的包装类型的流。</p><h4 id="1-1-3-常用函数"><a href="#1-1-3-常用函数" class="headerlink" title="1.1.3 常用函数"></a>1.1.3 常用函数</h4><p>Stream中定义的方法，IntStream也可以使用，例如map、flatMap、distinict等，IntStream除这些之外，还提供了常用的聚合函数，例如sum、min、max、average(平均数)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OptionalDouble <span class="title">average</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">OptionalInt <span class="title">max</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">OptionalInt <span class="title">min</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>有关Optional相关的类将在下文详细介绍。</p><p>另外除了上面提到的聚合函数，IntStream还提供了两个与数值范围的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title">range</span><span class="params">(<span class="keyword">int</span> startInclusive, <span class="keyword">int</span> endExclusive)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title">rangeClosed</span><span class="params">(<span class="keyword">int</span> startInclusive, <span class="keyword">int</span> endExclusive)</span></span>;</span><br></pre></td></tr></table></figure><p>rangeClosed与range的区别就是rangeClosed包含结束边界，举一个简单示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_range</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = IntStream.range(<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">                        .filter( i -&gt; i % <span class="number">2</span> == <span class="number">0</span> )</span><br><span class="line">                         .count();</span><br><span class="line">    System.out.println(<span class="string">&quot;count:&quot;</span> + count);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算【1，100）中包含的偶数个数，将输出49。如果将range(1,100)修改为rangeClosed(1,100)，在输出的个数为50。</p><h2 id="2、构建流"><a href="#2、构建流" class="headerlink" title="2、构建流"></a>2、构建流</h2><h3 id="2-1-通过值构建流"><a href="#2-1-通过值构建流" class="headerlink" title="2.1 通过值构建流"></a>2.1 通过值构建流</h3><p>java 8的Stream提供了两个重载的of函数来显示的构建流，其声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span></span></span><br></pre></td></tr></table></figure><h3 id="2-2-通过数组构建流"><a href="#2-2-通过数组构建流" class="headerlink" title="2.2 通过数组构建流"></a>2.2 通过数组构建流</h3><p>通过Arrays.stream构建流，其声明如下：<br>Arrays#stream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">(T[] array)</span></span></span><br></pre></td></tr></table></figure><h3 id="2-3-通过文件流"><a href="#2-3-通过文件流" class="headerlink" title="2.3 通过文件流"></a>2.3 通过文件流</h3><p>可以通过文件流创建流，在java.nio.file.Files类中定义了如下创建流的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Path&gt; <span class="title">list</span><span class="params">(Path dir)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Path&gt; <span class="title">walk</span><span class="params">(Path start, <span class="keyword">int</span> maxDepth, FileVisitOption... options)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Path&gt; <span class="title">walk</span><span class="params">(Path start, FileVisitOption... options)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Path&gt; <span class="title">find</span><span class="params">(Path start, <span class="keyword">int</span> maxDepth,BiPredicate&lt;Path, BasicFileAttributes&gt; matcher,   </span></span></span><br><span class="line"><span class="function"><span class="params">    FileVisitOption... options)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;String&gt; <span class="title">lines</span><span class="params">(Path path, Charset cs)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;String&gt; <span class="title">lines</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><p>下面我们举一个示例：找出一个文件中不同词的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_file_stram</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> uniqueWords = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span>(Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">&quot;d:/tmp/words.txt&quot;</span>), Charset.defaultCharset())) &#123;  </span><br><span class="line">        uniqueWords = lines.flatMap(line -&gt; Arrays.stream(line.split(<span class="string">&quot;&quot;</span> )))</span><br><span class="line">                .distinct()</span><br><span class="line">                .count();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;不重复字符个数：&quot;</span> + uniqueWords);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-4-函数生成流：创建无限流"><a href="#2-4-函数生成流：创建无限流" class="headerlink" title="2.4 函数生成流：创建无限流"></a>2.4 函数生成流：创建无限流</h3><p>Stream API提供了两个静态方法从函数生成流：iterate、generate，我们先来看一下其函数声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">generate</span><span class="params">(Supplier&lt;T&gt; s)</span></span></span><br></pre></td></tr></table></figure><h4 id="2-4-1-iterate"><a href="#2-4-1-iterate" class="headerlink" title="2.4.1 iterate"></a>2.4.1 iterate</h4><p>iterate方法的第一个参数类型为T，表示其初始值，第二个参数如下：<br><img src="https://img-blog.csdnimg.cn/20190602202005106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>即其函数式声明为为T-T。其示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_iterate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream.iterate(<span class="number">0</span>, a -&gt; a + <span class="number">2</span>)</span><br><span class="line">            .limit(<span class="number">10</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：由于是无限流，故千万记得使用limit截断流，否则会无限循环下去。</p></blockquote><h4 id="2-4-2-generate"><a href="#2-4-2-generate" class="headerlink" title="2.4.2 generate"></a>2.4.2 generate</h4><p>其参数为Supplier&lt; T &gt;，其定义如下：<br><img src="https://img-blog.csdnimg.cn/20190602202222354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>即构造一个T类型的对象，举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_iterate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream.iterate(<span class="number">0</span>, a -&gt; a + <span class="number">2</span>)</span><br><span class="line">            .limit(<span class="number">10</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-集合对象的stream"><a href="#2-5-集合对象的stream" class="headerlink" title="2.5 集合对象的stream"></a>2.5 集合对象的stream</h3><p>这个在前面的示例中用的最多，就不做过多介绍。</p><h2 id="3、Optional类"><a href="#3、Optional类" class="headerlink" title="3、Optional类"></a>3、Optional类</h2><p>为了更优雅的处理null值，避免空指针错误，java8中引入Optional类。<br><img src="https://img-blog.csdnimg.cn/20190602202332539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来对这些方法一一做个介绍。</p><ul><li>public static&lt; T&gt; Optional&lt; T&gt; empty()<br>创建一个Optional对象，其内部持有的对象为null。</li><li>public static &lt; T &gt; Optional&lt; T &gt; of(T value)<br>使用value的值，创建一个Optional对象。</li><li>public static &lt; T &gt; Optional&lt; T &gt; ofNullable(T value)<br>使用v去创建一个Optional对象，如果value为null，则返回empty()。</li><li>public T get()<br>从Optional对象获取内嵌的对象，如果为空，则抛出NoSuchElementException。</li><li>public boolean isPresent()<br>判断Optional对象中包含的值是否存在。</li><li>public void ifPresent(Consumer<? super T> consumer)如果Optional包裹的对象存在，则消费该对象。Consumer<?>的函数式编程接口：T -&gt; void。</li><li>public Optional&lt; T &gt; filter(Predicate&lt;? super T&gt; predicate)<br>如果Optional中包裹的对象为空，则返回自身，否则如果包裹的对象满足predicate表达式，则返回自身，否则返回empty()。</li><li>public&lt; U &gt; Optional&lt; U &gt; map(Function&lt;? super T, ? extends U&gt; mapper)<br>如果Optional对象中包裹的对象为空，则返回empty()，否则运用(T-U)，包裹U,当然如果U为空，则返回empty()。</li><li>public&lt; U &gt; Optional&lt; U &gt; flatMap(Function&lt;? super T, Optional&lt; U &gt;&gt; mapper)<br>如果Option对象中包裹的对象为空，则返回empty()，否则使用对Optional中的包裹的对象value应用Function，最终返回Optional对象。</li><li>public T orElse(T other)<br>返回Optional中包裹的对象，如果其值为空，则返回other。</li><li>public T orElseGet(Supplier&lt;? extends T&gt; other)<br>返回Optional中包裹的对象，如果其值为空，则返回 Supplier函数式编辑接口中创建的值。</li><li>public &lt; X extends Throwable&gt; T orElseThrow(Supplier&lt; ? extends X&gt; exceptionSupplier) throws X<br>返回Optional中包裹的对象，如果其值为空，则抛出自定义一次，由Supplier函数式编程接口返回。</li></ul><p> 其示例代码如下：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_option</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Optional&lt;String&gt; value = Optional.ofNullable(data.get(<span class="string">&quot;userName&quot;</span>));</span><br><span class="line">    <span class="comment">// 如果存在userName值，则输出</span></span><br><span class="line">    value.ifPresent(System.out::println);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>本文就介绍到这里了，本文详细介绍了java8中的数值流、Stream的创建以及java8中Optional类的使用。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1、数值流&quot;&gt;&lt;a href=&quot;#1、数值流&quot; class=&quot;headerlink&quot; title=&quot;1、数值流&quot;&gt;&lt;/a&gt;1、数值流&lt;/h2&gt;&lt;p&gt;不知大家还记不得，在介绍函数式编程接口中为了避免基础数据类型的装箱/拆箱带来的性能损耗，特意为函数式接口引入了基础数据类型的函数式编程接口，例如IntPredicate、LongPredicate、DoublePredicate。同样，流API也考虑到基本数据类型的装箱/拆箱会带来性能损耗，引入了数值流，例如IntStream、LongStream、DoubleStream。&lt;/p&gt;
&lt;h3 id=&quot;1-1-原始数据特化流&quot;&gt;&lt;a href=&quot;#1-1-原始数据特化流&quot; class=&quot;headerlink&quot; title=&quot;1.1 原始数据特化流&quot;&gt;&lt;/a&gt;1.1 原始数据特化流&lt;/h3&gt;&lt;p&gt;java8中提供了3个原始数据特化流，分别为IntStream、LongStream、DoubleStream。本文将以IntStream进行讲解，其他流类似，只是数据类型分别代表Long或Double。&lt;/p&gt;
&lt;h4 id=&quot;1-1-1-映射到数据流&quot;&gt;&lt;a href=&quot;#1-1-1-映射到数据流&quot; class=&quot;headerlink&quot; title=&quot;1.1.1 映射到数据流&quot;&gt;&lt;/a&gt;1.1.1 映射到数据流&lt;/h4&gt;&lt;p&gt;首先我们还是从一个示例开始本节的学习：计算菜单中所有菜品的卡路里之和。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test_reduce_caluli&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(List&amp;lt;Dish&amp;gt; menu)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; calories = menu.stream()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    .map(Dish::getCalories)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    .reduce(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, Integer::sum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;菜品中的总卡路里：&amp;quot;&lt;/span&gt; + calories);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面包含了一个基本数据类型的装箱/拆箱动作，java8的流API提供了mapToInt方法，直接返回int类型的流&lt;/p&gt;
&lt;p&gt;我们先稍微看一下mapToInt的方法声明：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;IntStream &lt;span class=&quot;title&quot;&gt;mapToInt&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ToIntFunction&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; T&amp;gt; mapper)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接受一个T-&amp;gt;int的函数式编程接口，直接返回IntStream流对象，而且IntStream本身提供了一些常用的聚合函数，例如sum。&lt;br&gt;使用IntStream来实现计算菜单中所有菜品的卡路里之和，其示例如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test_reduce_caluli_intStream&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(List&amp;lt;Dish&amp;gt; menu)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; calories = menu.stream()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .mapToInt(Dish::getCalories)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .sum();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;菜品中的总卡路里：&amp;quot;&lt;/span&gt; + calories);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;1-1-2-转换回对象流&quot;&gt;&lt;a href=&quot;#1-1-2-转换回对象流&quot; class=&quot;headerlink&quot; title=&quot;1.1.2 转换回对象流&quot;&gt;&lt;/a&gt;1.1.2 转换回对象流&lt;/h4&gt;&lt;p&gt;使用了特化流例如IntStream后，将不能再自动转换为其对应的封装对象流Stream&amp;lt; T &amp;gt;了，我们可以随意从IntStream对象中对应的通用方法的函数声明，例如IntStream#map函数的声明如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;IntStream &lt;span class=&quot;title&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(IntUnaryOperator mapper)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;只能接受int -&amp;gt; int的函数式编程接口，如果想将IntStream转回到Stream&amp;lt; Integer &amp;gt;，该如何处理呢？&lt;/p&gt;
&lt;p&gt;IntStream提供了boxed()方法来实现将基础数据类型转换回对应的包装类型的流。&lt;/p&gt;
&lt;h4 id=&quot;1-1-3-常用函数&quot;&gt;&lt;a href=&quot;#1-1-3-常用函数&quot; class=&quot;headerlink&quot; title=&quot;1.1.3 常用函数&quot;&gt;&lt;/a&gt;1.1.3 常用函数&lt;/h4&gt;&lt;p&gt;Stream中定义的方法，IntStream也可以使用，例如map、flatMap、distinict等，IntStream除这些之外，还提供了常用的聚合函数，例如sum、min、max、average(平均数)。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;OptionalDouble &lt;span class=&quot;title&quot;&gt;average&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;OptionalInt &lt;span class=&quot;title&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;OptionalInt &lt;span class=&quot;title&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有关Optional相关的类将在下文详细介绍。&lt;/p&gt;
&lt;p&gt;另外除了上面提到的聚合函数，IntStream还提供了两个与数值范围的方法：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; IntStream &lt;span class=&quot;title&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; startInclusive, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; endExclusive)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; IntStream &lt;span class=&quot;title&quot;&gt;rangeClosed&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; startInclusive, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; endExclusive)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;rangeClosed与range的区别就是rangeClosed包含结束边界，举一个简单示例如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test_range&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; count = IntStream.range(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .filter( i -&amp;gt; i % &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                         .count();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;count:&amp;quot;&lt;/span&gt; + count);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;计算【1，100）中包含的偶数个数，将输出49。如果将range(1,100)修改为rangeClosed(1,100)，在输出的个数为50。&lt;/p&gt;
&lt;h2 id=&quot;2、构建流&quot;&gt;&lt;a href=&quot;#2、构建流&quot; class=&quot;headerlink&quot; title=&quot;2、构建流&quot;&gt;&lt;/a&gt;2、构建流&lt;/h2&gt;&lt;h3 id=&quot;2-1-通过值构建流&quot;&gt;&lt;a href=&quot;#2-1-通过值构建流&quot; class=&quot;headerlink&quot; title=&quot;2.1 通过值构建流&quot;&gt;&lt;/a&gt;2.1 通过值构建流&lt;/h3&gt;&lt;p&gt;java 8的Stream提供了两个重载的of函数来显示的构建流，其声明如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt;&amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; &lt;span class=&quot;title&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T t)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt;&amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; &lt;span class=&quot;title&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T... values)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;2-2-通过数组构建流&quot;&gt;&lt;a href=&quot;#2-2-通过数组构建流&quot; class=&quot;headerlink&quot; title=&quot;2.2 通过数组构建流&quot;&gt;&lt;/a&gt;2.2 通过数组构建流&lt;/h3&gt;&lt;p&gt;通过Arrays.stream构建流，其声明如下：&lt;br&gt;Arrays#stream&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;Stream&amp;lt;T&amp;gt; &lt;span class=&quot;title&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T[] array)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;2-3-通过文件流&quot;&gt;&lt;a href=&quot;#2-3-通过文件流&quot; class=&quot;headerlink&quot; title=&quot;2.3 通过文件流&quot;&gt;&lt;/a&gt;2.3 通过文件流&lt;/h3&gt;&lt;p&gt;可以通过文件流创建流，在java.nio.file.Files类中定义了如下创建流的方法。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Stream&amp;lt;Path&amp;gt; &lt;span class=&quot;title&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Path dir)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Stream&amp;lt;Path&amp;gt; &lt;span class=&quot;title&quot;&gt;walk&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Path start, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxDepth, FileVisitOption... options)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Stream&amp;lt;Path&amp;gt; &lt;span class=&quot;title&quot;&gt;walk&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Path start, FileVisitOption... options)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Stream&amp;lt;Path&amp;gt; &lt;span class=&quot;title&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Path start, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxDepth,BiPredicate&amp;lt;Path, BasicFileAttributes&amp;gt; matcher,   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;    FileVisitOption... options)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Stream&amp;lt;String&amp;gt; &lt;span class=&quot;title&quot;&gt;lines&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Path path, Charset cs)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Stream&amp;lt;String&amp;gt; &lt;span class=&quot;title&quot;&gt;lines&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Path path)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面我们举一个示例：找出一个文件中不同词的个数。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test_file_stram&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; uniqueWords = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;(Stream&amp;lt;String&amp;gt; lines = Files.lines(Paths.get(&lt;span class=&quot;string&quot;&gt;&amp;quot;d:/tmp/words.txt&amp;quot;&lt;/span&gt;), Charset.defaultCharset())) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        uniqueWords = lines.flatMap(line -&amp;gt; Arrays.stream(line.split(&lt;span class=&quot;string&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt; )))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .distinct()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .count();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;不重复字符个数：&amp;quot;&lt;/span&gt; + uniqueWords);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (IOException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="java8" scheme="http://example.com/categories/java8/"/>
    
    
    <category term="java8" scheme="http://example.com/tags/java8/"/>
    
    <category term="Lambda" scheme="http://example.com/tags/Lambda/"/>
    
    <category term="流计算" scheme="http://example.com/tags/%E6%B5%81%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>初识Stream、流的基本操作（流计算）</title>
    <link href="http://example.com/posts/3f62c87c.html"/>
    <id>http://example.com/posts/3f62c87c.html</id>
    <published>2020-12-09T14:32:35.000Z</published>
    <updated>2020-12-11T04:25:28.567Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文中的部分示例基于如下场景：餐厅点菜，Dish为餐厅中可提供的菜品，Dish的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Dish &#123;</span><br><span class="line">    &#x2F;** 菜品名称 *&#x2F;</span><br><span class="line">private final String name;</span><br><span class="line">&#x2F;** 是否是素食 *&#x2F;</span><br><span class="line">private final boolean vegetarian;</span><br><span class="line">&#x2F;** 含卡路里 *&#x2F;</span><br><span class="line">private final int calories;</span><br><span class="line">&#x2F;** 类型 *&#x2F;</span><br><span class="line">private final Type type;</span><br><span class="line"></span><br><span class="line">public Dish(String name, boolean vegetarian, int calories, Type type) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">this.vegetarian &#x3D; vegetarian;</span><br><span class="line">this.calories &#x3D; calories;</span><br><span class="line">this.type &#x3D; type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public enum Type &#123; MEAT, FISH, OTHER &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 省略set get方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>菜单的数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dish&gt; menu &#x3D; Arrays.asList(</span><br><span class="line">new Dish(&quot;pork&quot;, false, 800, Dish.Type.MEAT),</span><br><span class="line">new Dish(&quot;beef&quot;, false, 700, Dish.Type.MEAT),</span><br><span class="line">new Dish(&quot;chicken&quot;, false, 400, Dish.Type.MEAT),</span><br><span class="line">new Dish(&quot;french fries&quot;, true, 530, Dish.Type.OTHER),</span><br><span class="line">new Dish(&quot;rice&quot;, true, 350, Dish.Type.OTHER),</span><br><span class="line">new Dish(&quot;season fruit&quot;, true, 120, Dish.Type.OTHER),</span><br><span class="line">new Dish(&quot;pizza&quot;, true, 550, Dish.Type.OTHER),</span><br><span class="line">new Dish(&quot;prawns&quot;, false, 300, Dish.Type.FISH),</span><br><span class="line">new Dish(&quot;salmon&quot;, false, 450, Dish.Type.FISH) );</span><br></pre></td></tr></table></figure><p>我们以一个简单的示例来引入流：从菜单列表中，查找出是素食的菜品，并打印其菜品的名称。</p><p>在Java8之前，我们通常是这样实现该需求的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; dishNames &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">for(Dish d menu) &#123;</span><br><span class="line">    if(d.isVegetarian()) &#123;</span><br><span class="line">        dishNames.add(d.getName()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出帅选出来的菜品的名称：</span><br><span class="line">for(String n : dishNames) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那在java8中，我们可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">menu.streams() .filter( Dish::isVegetarian).map( Dish::getName) .forEach( a -&gt; System.out.println(a) );</span><br></pre></td></tr></table></figure><p>其运行输出的结果：<br><img src="https://img-blog.csdnimg.cn/20190518134242508.png" alt="在这里插入图片描述"><br>怎么样，神奇吧！！！</p><p>在解释上面的代码之前，我们先对流做一个理论上的介绍。</p><h2 id="1、流是什么？"><a href="#1、流是什么？" class="headerlink" title="1、流是什么？"></a>1、流是什么？</h2><p>流，就是数据流，是元素序列，在Java8中，流的接口定义在 java.util.stream.Stream包中，并且在Collection(集合)接口中新增一个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">default Stream&lt;E&gt; stream() &#123;</span><br><span class="line">        return StreamSupport.stream(spliterator(), false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流的简短定义：从支持数据处理操作的源生成的元素序列。例如集合、数组都是支持数据操作的数据结构（容器），都可以做为流的创建源，该定义的核心要素如下：</p><ul><li>源<br>流是从一个源创建来而来，而且这个源是支持数据处理的，例如集合、数组等。</li><li>元素序列<br>流代表一个元素序列（流水线），因为是从根据一个数据处理源而创建得来的。</li><li>数据处理操作<br>流的侧重点并不在数据存储，而在于数据处理，例如示例中的filter、map、forEach等。</li><li>迭代方式<br>流的迭代方式为内部迭代，而集合的迭代方式为外部迭代。例如我们遍历Collection接口需要用户去做迭代，例如for-each，然后在循环体中写对应的处理代码，这叫外部迭代。相反，Stream库使用内部迭代，我们只需要对流传入对应的函数即可，表示要做什么就行。</li></ul><blockquote><p>注意：流和迭代器Iterator一样，只能遍历一次，如果要多次遍历，请创建多个流。</p></blockquote><p>接下来我们将重点先介绍流的常用操作方法。</p><h2 id="2、常用的流操作方法"><a href="#2、常用的流操作方法" class="headerlink" title="2、常用的流操作方法"></a>2、常用的流操作方法</h2><h4 id="2-1-filter"><a href="#2-1-filter" class="headerlink" title="2.1 filter"></a>2.1 filter</h4><p>filter函数的方法声明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.stream.Stream#filter</span><br><span class="line">Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</span><br></pre></td></tr></table></figure><p>该方法接收一个谓词，返回一个流，即filter方法接收的lambda表达式需要满足 （  T  -&gt; Boolean ）。</p><p>示例：从菜单中选出所有是素食的菜品：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dish&gt; vegetarianDishs &#x3D; menu.stream().filter(  Dish::isVegetarian )    &#x2F;&#x2F; 使用filter过滤流中的菜品。</span><br><span class="line">                                          .collect(toList())；              &#x2F;&#x2F; 将流转换成List，该方法将在后面介绍。</span><br></pre></td></tr></table></figure><blockquote><p>温馨提示：流的操作可以分成中间件操作和终端操作。中间操作通常的返回结果还是流，并且在调用终端操作之前，并不会立即调用，等终端方法调用后，中间操作才会真正触发执行，该示例中的collect方法为终端方法。</p></blockquote><p>我们类比一下数据库查询操作，除了基本的筛选动作外，还有去重，分页等功能，那java8的流API能支持这些操作吗？<br>答案当然是肯定。</p><h4 id="2-1-1-distinct"><a href="#2-1-1-distinct" class="headerlink" title="2.1.1 distinct"></a>2.1.1 distinct</h4><p>distinct，类似于数据库中的排重函数，就是对结果集去重。<br>例如有一个数值numArr = [1,5,8,6,5,2,6]，现在要输出该数值中的所有奇数并且不能重复输出，那该如何实现呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(numArr).filter(  a -&gt; a % 2 &#x3D;&#x3D; 0 ).distinict().forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="2-1-2-limit"><a href="#2-1-2-limit" class="headerlink" title="2.1.2 limit"></a>2.1.2 limit</h4><p>截断流，返回一个i不超过指定元素个数的流。<br>还是以上例举例，如果要输出的元素是偶数，不能重复输出，并且只输出1个元素，那又该如何实现呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(numArr).filter(  a -&gt; a % 2 &#x3D;&#x3D; 0 ).distinict().limit(1).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="2-1-3-skip"><a href="#2-1-3-skip" class="headerlink" title="2.1.3 skip"></a>2.1.3 skip</h4><p>跳过指定元素，返回剩余元素的流，与limit互补。</p><a id="more"></a><h4 id="2-2-Map"><a href="#2-2-Map" class="headerlink" title="2.2 Map"></a>2.2 Map</h4><p>还是类比数据库操作，我们通常可以只选择一个表中的某一列，java8流操作也提供了类似的方法。<br>例如，我们需要从菜单中提取所有菜品的名称，在java8中我们可以使用如下代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">版本1：List&lt;String&gt; dishNames &#x3D; menu.stream().map( (Dish d) -&gt; d.getName() ).collect(Collectors.toList());</span><br><span class="line">版本2：List&lt;String&gt; dishNames &#x3D; menu.stream().map( d -&gt; d.getName() ).collect(Collectors.toList());</span><br><span class="line">版本3：List&lt;String&gt; dishNames &#x3D; menu.stream().map(Dish::getName).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><blockquote><p>文章的后续部分尽量使用最简洁的lambda表达式。</p></blockquote><p>我们来看一下Stream关于map方法的声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</span><br></pre></td></tr></table></figure><p>接受一个函数Function，其函数声明为：T -&gt; R，接收一个T类型的对象，返回一个R类型的对象。</p><p>当然，java为了高效的处理基础数据类型（避免装箱、拆箱带来性能损耗）也定义了如下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper)</span><br><span class="line">LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper)</span><br><span class="line">DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper)</span><br></pre></td></tr></table></figure><p>思考题：对于字符数值[“Hello”,”World”] ，输出字符序列，并且去重。<br>第一次尝试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void test_flat_map() &#123;</span><br><span class="line">    String[] strArr &#x3D; new String[] &#123;&quot;hello&quot;, &quot;world&quot;&#125;;</span><br><span class="line">    List&lt;String&gt; strList &#x3D; Arrays.asList(strArr);</span><br><span class="line">    strList.stream().map( s -&gt; s.split(&quot;&quot;))</span><br><span class="line">                    .distinct().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><img src="https://img-blog.csdnimg.cn/20190518134853228.png" alt="在这里插入图片描述"><br>为什么会返回两个String[]元素呢？因为map(s -&gt; s.split()) 此时返回的流为Stream&lt;String[]&gt;，那我们是不是可以继续对该Steam[String[]],把String[]转换为字符流，其代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void test_flat_map() &#123;</span><br><span class="line">    String[] strArr &#x3D; new String[] &#123;&quot;hello&quot;, &quot;world&quot;&#125;;</span><br><span class="line">    List&lt;String&gt; strList &#x3D; Arrays.asList(strArr);</span><br><span class="line">    strList.stream().map( s -&gt; s.split(&quot;&quot;))</span><br><span class="line">                    .map(Arrays::stream)</span><br><span class="line">                    .distinct().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其返回结果：<br><img src="https://img-blog.csdnimg.cn/20190518134944653.png" alt="在这里插入图片描述"><br>还是不符合预期，其实原因也很好理解，再次经过map(Arrays:stream)后，返回的结果为 Stream&lt;Stream&lt; String&gt;&gt;，即包含两个元素，每一个元素为一个字符流，可以通过如下代码验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void test_flat_map() &#123;</span><br><span class="line">    String[] strArr &#x3D; new String[] &#123;&quot;hello&quot;, &quot;world&quot;&#125;;</span><br><span class="line">    List&lt;String&gt; strList &#x3D; Arrays.asList(strArr);</span><br><span class="line">    strList.stream().map( s -&gt; s.split(&quot;&quot;))</span><br><span class="line">                    .map(Arrays::stream)</span><br><span class="line">                    .forEach(  (Stream&lt;String&gt; s) -&gt; &#123;</span><br><span class="line">                        System.out.println(&quot;\n --start---&quot;);</span><br><span class="line">                        s.forEach(a -&gt; System.out.print(a + &quot; &quot;));</span><br><span class="line">                        System.out.println(&quot;\n --end---&quot;);</span><br><span class="line">                    &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综合上述分析，之所以不符合预期，主要是原数组中的两个字符，经过map后返回的是两个独立的流，那有什么方法将这两个流合并成一个流，然后再进行disinic去重呢？</p><p>答案当然是可以的，flatMap方法闪亮登场：先看代码和显示结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void test_flat_map() &#123;</span><br><span class="line">    String[] strArr &#x3D; new String[] &#123;&quot;hello&quot;, &quot;world&quot;&#125;;</span><br><span class="line">    List&lt;String&gt; strList &#x3D; Arrays.asList(strArr);</span><br><span class="line">    strList.stream().map( s -&gt; s.split(&quot;&quot;))</span><br><span class="line">                    .flatMap(Arrays::stream)</span><br><span class="line">                    .distinct().forEach( a -&gt; System.out.print(a +&quot; &quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其输出结果：<br><img src="https://img-blog.csdnimg.cn/20190518135118267.png" alt="在这里插入图片描述"><br>符合预期。一言以蔽之，flatMap可以把两个流合并成一个流进行操作。</p><h4 id="2-3-查找和匹配"><a href="#2-3-查找和匹配" class="headerlink" title="2.3 查找和匹配"></a>2.3 查找和匹配</h4><p>Stream API提供了allMatch、anyMatch、noneMatch、findFirst和findAny方法来实现对流中数据的匹配与查找。</p><h5 id="2-3-1-allMatch"><a href="#2-3-1-allMatch" class="headerlink" title="2.3.1 allMatch"></a>2.3.1 allMatch</h5><p>我们先看一下该方法的声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean allMatch(Predicate&lt;? super T&gt; predicate);</span><br></pre></td></tr></table></figure><p>接收一个谓词函数(T-&gt;boolean)，返回一个boolean值，是一个终端操作，用于判断流中的所有元素是否与Predicate相匹配，只要其中一个元素不复合，该表达式将返回false。<br>示例如下：例如存在这样一个List a,其中元素为 1,2,4,6,8。判断流中的元素是否都是偶数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean result &#x3D; a.stream().allMatch(  a -&gt; a % 2 &#x3D;&#x3D; 0 )；  &#x2F;&#x2F; 将返回false。</span><br></pre></td></tr></table></figure><h5 id="2-3-2-anyMatch"><a href="#2-3-2-anyMatch" class="headerlink" title="2.3.2 anyMatch"></a>2.3.2 anyMatch</h5><p>该方法的函数声明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean anyMatch(Predicate&lt;? super T&gt; predicate)</span><br></pre></td></tr></table></figure><p>同样接收一个谓词Predicate( T -&gt; boolean )，表示只要流中的元素至少一个匹配谓词，即返回真。</p><p>示例如下：例如存在这样一个List a,其中元素为 1,2,4,6,8。判断流中的元素是否包含偶数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean result &#x3D; a.stream().anyMatch(  a -&gt; a % 2 &#x3D;&#x3D; 0 )；  &#x2F;&#x2F; 将返回true。</span><br></pre></td></tr></table></figure><h5 id="2-3-3-noneMatch"><a href="#2-3-3-noneMatch" class="headerlink" title="2.3.3 noneMatch"></a>2.3.3 noneMatch</h5><p>该方法的函数声明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean noneMatch(Predicate&lt;? super T&gt; predicate);</span><br></pre></td></tr></table></figure><p>同样接收一个谓词Predicate( T -&gt; boolean )，表示只要流中的元素全部不匹配谓词表达式，则返回true。</p><p>示例如下：例如存在这样一个List a,其中元素为 2,4,6,8。判断流中的所有元素都不式奇数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean result &#x3D; a.stream().noneMatch(  a -&gt; a % 2 &#x3D;&#x3D; 1 )；  &#x2F;&#x2F; 将返回true。</span><br></pre></td></tr></table></figure><h5 id="2-3-4-findFirst"><a href="#2-3-4-findFirst" class="headerlink" title="2.3.4 findFirst"></a>2.3.4 findFirst</h5><p>查找流中的一个元素，其函数声明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; findFirst();</span><br></pre></td></tr></table></figure><p>返回流中的一个元素。其返回值为Optional<T>，这是jdk8中引入的一个类，俗称值容器类，其主要左右是用来避免值空指针，一种更加优雅的方式来处理null。该类的具体使用将在下一篇详细介绍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void test_find_first(List&lt;Dish&gt; menu) &#123;</span><br><span class="line">    Optional&lt;Dish&gt; dish &#x3D; menu.stream().findFirst();</span><br><span class="line">    &#x2F;&#x2F; 这个方法表示，Optional中包含Dish对象，则执行里面的代码，否则什么事不干，是不是比判断是否为null更友好</span><br><span class="line">    dish.ifPresent(a -&gt; System.out.println(a.getName()));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-5-findAny"><a href="#2-3-5-findAny" class="headerlink" title="2.3.5 findAny"></a>2.3.5 findAny</h5><p>返回流中任意一个元素，其函数声明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; findAny();</span><br></pre></td></tr></table></figure><h4 id="2-4-reduce"><a href="#2-4-reduce" class="headerlink" title="2.4 reduce"></a>2.4 reduce</h4><p>reduce归约，看过大数据的人用过会非常敏感，目前的java8的流操作是不是有点map-reduce的味道，归约，就是对流中所有的元素进行统计分析，归约成一个数值。<br>首先我们看一下reduce的函数说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</span><br></pre></td></tr></table></figure><ul><li>T identity：累积器的初始值。</li><li>BinaryOperator&lt; T&gt; accumulator：累积函数。BinaryOperator&lt; T&gt; extend BiFunction&lt;T, U, R&gt;。BinaryOperator<T>的函数式表示，接受两个T类型的入参，返回T类型的返回值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);</span><br></pre></td></tr></table></figure>可以理解为没有初始值的归约，如果流为空，则会返回空，故其返回值使用了Optional类来优雅处理null值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner);</span><br></pre></td></tr></table></figure><p>首先，最后的返回值类型为U。</p><ul><li>U identity：累积函数的初始值。</li><li>BiFunction&lt;U, ? super T, U&gt; accumulator：累积器函数，对流中的元素使用该累积器进行归约，在具体执行时accumulator.apply(  identity,  第二个参数的类型不做限制 )，只要最终返回U即可。</li><li>BinaryOperator&lt; U&gt; combiner：组合器。对累积器的结果进行组合，因为归约reduce，java流计算内部使用了fork-join框架，会对流的中的元素使用并行累积，每个线程处理流中一部分数据，最后对结果进行组合，得出最终的值。</li></ul><blockquote><p>温馨提示：对流API的学习，一个最最重点的就是要掌握这些函数式编程接口，然后掌握如何使用Lambda表达式进行行为参数化（lambda表达当成参数传入到函数中）。</p></blockquote><p>接下来我们举例来展示如何使用reduce。<br>示例1：对集合中的元素求和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; goodsNumber &#x3D; Arrays.asList(   3, 5, 8, 4, 2, 13 );</span><br><span class="line">java7之前的示例：</span><br><span class="line">int sum &#x3D; 0;</span><br><span class="line">for(Integer i : goodsNumber) &#123;</span><br><span class="line">sum +&#x3D; i;&#x2F;&#x2F;  sum &#x3D; sum + i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;sum:&quot; + sum);</span><br></pre></td></tr></table></figure><p>求和运算符： c = a + b，也就是接受2个参数，返回一个值，并且这三个值的类型一致。</p><p>故我们可以使用T reduce(T identity, BinaryOperator&lt; T&gt; accumulator)来实现我们的需求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void test_reduce() &#123;</span><br><span class="line">    List&lt;Integer&gt; goodsNumber &#x3D; Arrays.asList(   3, 5, 8, 4, 2, 13 );</span><br><span class="line">    int sum &#x3D; goodsNumber.stream().reduce(0, (a,b) -&gt; a + b);</span><br><span class="line">    &#x2F;&#x2F;这里也可以写成这样：</span><br><span class="line">    &#x2F;&#x2F; int sum &#x3D; goodsNumber.stream().reduce(0, Integer::sum);</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知大家是否只读(a,b)这两个参数的来源，其实第一个参数为初始值T identity，第二个参数为流中的元素。</p><p>那三个参数的reduce函数主要用在什么场景下呢？接下来还是用求和的例子来展示其使用场景。在java多线程编程模型中，引入了fork-join框架，就是对一个大的任务进行先拆解，用多线程分别并行执行，最终再两两进行合并，得出最终的结果。reduce函数的第三个函数，就是组合这个动作，下面给出并行执行的流式处理示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> public static void test_reduce_combiner() &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 初始化待操作的流 *&#x2F;</span><br><span class="line">    List&lt;Integer&gt; nums &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    int s &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; 200; i ++) &#123;</span><br><span class="line">        nums.add(i);</span><br><span class="line">        s &#x3D; s + i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对流进行归并，求和,这里使用了流的并行执行版本 parallelStream，内部使用Fork-Join框架多线程并行执行，</span><br><span class="line">    &#x2F;&#x2F; 关于流的内部高级特性，后续再进行深入，目前先以掌握其用法为主。</span><br><span class="line">    int sum2 &#x3D; nums.parallelStream().reduce(0,Integer::sum, Integer::sum);</span><br><span class="line">    System.out.println(&quot;和为：&quot; + sum2);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 下面给出上述版本的debug版本。</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 累积器执行的次数</span><br><span class="line">    AtomicInteger accumulatorCount &#x3D; new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 组合器执行的次数（其实就是内部并行度）</span><br><span class="line">    AtomicInteger combinerCount &#x3D; new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    int sum &#x3D; nums.parallelStream().reduce(0,(a,b) -&gt; &#123;</span><br><span class="line">                accumulatorCount.incrementAndGet();</span><br><span class="line">                return a + b;</span><br><span class="line">           &#125;, (c,d) -&gt; &#123;</span><br><span class="line">                combinerCount.incrementAndGet();</span><br><span class="line">                return  c+d;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;accumulatorCount:&quot; + accumulatorCount.get());</span><br><span class="line">    System.out.println(&quot;combinerCountCount:&quot; + combinerCount.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从结果上可以看出，执行了100次累积动作，但只进行了15次合并。</p><p>流的基本操作就介绍到这里，在此总结一下，目前接触到的流操作：<br>1、filter</p><ul><li>函数功能：过滤</li><li>操作类型：中间操作</li><li>返回类型：Stream<T></li><li>函数式接口：Predicate<T></li><li>函数描述符：T -&gt; boolean</li></ul><p>2、distinct</p><ul><li>函数功能：去重</li><li>操作类型：中间操作</li><li>返回类型：Stream<T></li></ul><p>3、skip</p><ul><li>函数功能：跳过n个元素</li><li>操作类型：中间操作</li><li>返回类型：Stream<T></li><li>接受参数：long</li></ul><p>4、limit</p><ul><li>函数功能：截断流，值返回前n个元素的流</li><li>操作类型：中间操作</li><li>返回类型：Stream<T></li><li>接受参数：long</li></ul><p>5、map</p><ul><li>函数功能：映射</li><li>操作类型：中间操作</li><li>返回类型：Stream<R></li><li>函数式接口：Function&lt;T,R&gt;</li><li>函数描述符：T -&gt; R<br>6、flatMap</li><li>函数功能：扁平化流，将多个流合并成一个流</li><li>操作类型：中间操作</li><li>返回类型：Stream<R></li><li>函数式接口：Function&lt;T, Stream<R>&gt;</li><li>函数描述符：T -&gt; Stream<R><br>7、sorted</li><li>函数功能：排序</li><li>操作类型：中间操作</li><li>返回类型：Stream<T></li><li>函数式接口：Comparator<T></li><li>函数描述符：(T,T) -&gt; int<br>8、anyMatch</li><li>函数功能：流中任意一个匹配则返回true</li><li>操作类型：终端操作</li><li>返回类型：boolean</li><li>函数式接口：Predicate<T></li><li>函数描述符：T -&gt; boolean<br>9、allMatch</li><li>函数功能：流中全部元素匹配则返回true</li><li>操作类型：终端操作</li><li>返回类型：boolean</li><li>函数式接口：Predicate<T></li><li>函数描述符：T -&gt; boolean<br>10、 noneMatch</li><li>函数功能：流中所有元素都不匹配则返回true</li><li>操作类型：终端操作</li><li>返回类型：boolean</li><li>函数式接口：Predicate<T></li><li>函数描述符：T -&gt; boolean<br>11、findAny</li><li>函数功能：从流中任意返回一个元素</li><li>操作类型：终端操作</li><li>返回类型：Optional<T><br>12、findFirst</li><li>函数功能：返回流中第一个元素</li><li>操作类型：终端操作</li><li>返回类型：Optional<T><br>13、forEach</li><li>函数功能：遍历流</li><li>操作类型：终端操作</li><li>返回类型：void</li><li>函数式接口：Consumer<T></li><li>函数描述符：T -&gt; void<br>14、collect</li><li>函数功能：将流进行转换</li><li>操作类型：终端操作</li><li>返回类型：R</li><li>函数式接口：Collector&lt;T,A,R&gt;</li></ul><p>15、reduce</p><ul><li><p>函数功能：规约流</p></li><li><p>操作类型：终端操作 </p></li><li><p>返回类型：Optional<T></p></li><li><p>函数式接口：BinaryOperator<T></p></li><li><p>函数描述符：(T,T) -&gt; T</p><p>16、count</p></li><li><p>函数功能：返回流中总元素个数</p></li><li><p>操作类型：终端操作</p></li><li><p>返回类型：long</p></li></ul><p>由于篇幅的原因，流的基本计算就介绍到这里了，下文还将重点介绍流的创建，数值流与Optional类的使用。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文中的部分示例基于如下场景：餐厅点菜，Dish为餐厅中可提供的菜品，Dish的定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Dish &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#x2F;** 菜品名称 *&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	private final String name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#x2F;** 是否是素食 *&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	private final boolean vegetarian;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#x2F;** 含卡路里 *&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	private final int calories;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#x2F;** 类型 *&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	private final Type type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public Dish(String name, boolean vegetarian, int calories, Type type) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		this.name &amp;#x3D; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		this.vegetarian &amp;#x3D; vegetarian;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		this.calories &amp;#x3D; calories;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		this.type &amp;#x3D; type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public enum Type &amp;#123; MEAT, FISH, OTHER &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#x2F;&amp;#x2F; 省略set get方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;菜单的数据如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;Dish&amp;gt; menu &amp;#x3D; Arrays.asList(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;new Dish(&amp;quot;pork&amp;quot;, false, 800, Dish.Type.MEAT),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;new Dish(&amp;quot;beef&amp;quot;, false, 700, Dish.Type.MEAT),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;new Dish(&amp;quot;chicken&amp;quot;, false, 400, Dish.Type.MEAT),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;new Dish(&amp;quot;french fries&amp;quot;, true, 530, Dish.Type.OTHER),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;new Dish(&amp;quot;rice&amp;quot;, true, 350, Dish.Type.OTHER),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;new Dish(&amp;quot;season fruit&amp;quot;, true, 120, Dish.Type.OTHER),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;new Dish(&amp;quot;pizza&amp;quot;, true, 550, Dish.Type.OTHER),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;new Dish(&amp;quot;prawns&amp;quot;, false, 300, Dish.Type.FISH),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;new Dish(&amp;quot;salmon&amp;quot;, false, 450, Dish.Type.FISH) );&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们以一个简单的示例来引入流：从菜单列表中，查找出是素食的菜品，并打印其菜品的名称。&lt;/p&gt;
&lt;p&gt;在Java8之前，我们通常是这样实现该需求的：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;String&amp;gt; dishNames &amp;#x3D; new ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(Dish d menu) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(d.isVegetarian()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dishNames.add(d.getName()); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F;输出帅选出来的菜品的名称：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(String n : dishNames) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那在java8中，我们可以这样写：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;menu.streams() .filter( Dish::isVegetarian).map( Dish::getName) .forEach( a -&amp;gt; System.out.println(a) );&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其运行输出的结果：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190518134242508.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;怎么样，神奇吧！！！&lt;/p&gt;
&lt;p&gt;在解释上面的代码之前，我们先对流做一个理论上的介绍。&lt;/p&gt;
&lt;h2 id=&quot;1、流是什么？&quot;&gt;&lt;a href=&quot;#1、流是什么？&quot; class=&quot;headerlink&quot; title=&quot;1、流是什么？&quot;&gt;&lt;/a&gt;1、流是什么？&lt;/h2&gt;&lt;p&gt;流，就是数据流，是元素序列，在Java8中，流的接口定义在 java.util.stream.Stream包中，并且在Collection(集合)接口中新增一个方法：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;default Stream&amp;lt;E&amp;gt; stream() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return StreamSupport.stream(spliterator(), false);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;流的简短定义：从支持数据处理操作的源生成的元素序列。例如集合、数组都是支持数据操作的数据结构（容器），都可以做为流的创建源，该定义的核心要素如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源&lt;br&gt;流是从一个源创建来而来，而且这个源是支持数据处理的，例如集合、数组等。&lt;/li&gt;
&lt;li&gt;元素序列&lt;br&gt;流代表一个元素序列（流水线），因为是从根据一个数据处理源而创建得来的。&lt;/li&gt;
&lt;li&gt;数据处理操作&lt;br&gt;流的侧重点并不在数据存储，而在于数据处理，例如示例中的filter、map、forEach等。&lt;/li&gt;
&lt;li&gt;迭代方式&lt;br&gt;流的迭代方式为内部迭代，而集合的迭代方式为外部迭代。例如我们遍历Collection接口需要用户去做迭代，例如for-each，然后在循环体中写对应的处理代码，这叫外部迭代。相反，Stream库使用内部迭代，我们只需要对流传入对应的函数即可，表示要做什么就行。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：流和迭代器Iterator一样，只能遍历一次，如果要多次遍历，请创建多个流。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来我们将重点先介绍流的常用操作方法。&lt;/p&gt;
&lt;h2 id=&quot;2、常用的流操作方法&quot;&gt;&lt;a href=&quot;#2、常用的流操作方法&quot; class=&quot;headerlink&quot; title=&quot;2、常用的流操作方法&quot;&gt;&lt;/a&gt;2、常用的流操作方法&lt;/h2&gt;&lt;h4 id=&quot;2-1-filter&quot;&gt;&lt;a href=&quot;#2-1-filter&quot; class=&quot;headerlink&quot; title=&quot;2.1 filter&quot;&gt;&lt;/a&gt;2.1 filter&lt;/h4&gt;&lt;p&gt;filter函数的方法声明如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java.util.stream.Stream#filter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stream&amp;lt;T&amp;gt; filter(Predicate&amp;lt;? super T&amp;gt; predicate);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该方法接收一个谓词，返回一个流，即filter方法接收的lambda表达式需要满足 （  T  -&amp;gt; Boolean ）。&lt;/p&gt;
&lt;p&gt;示例：从菜单中选出所有是素食的菜品：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;Dish&amp;gt; vegetarianDishs &amp;#x3D; menu.stream().filter(  Dish::isVegetarian )    &amp;#x2F;&amp;#x2F; 使用filter过滤流中的菜品。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                          .collect(toList())；              &amp;#x2F;&amp;#x2F; 将流转换成List，该方法将在后面介绍。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;温馨提示：流的操作可以分成中间件操作和终端操作。中间操作通常的返回结果还是流，并且在调用终端操作之前，并不会立即调用，等终端方法调用后，中间操作才会真正触发执行，该示例中的collect方法为终端方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们类比一下数据库查询操作，除了基本的筛选动作外，还有去重，分页等功能，那java8的流API能支持这些操作吗？&lt;br&gt;答案当然是肯定。&lt;/p&gt;
&lt;h4 id=&quot;2-1-1-distinct&quot;&gt;&lt;a href=&quot;#2-1-1-distinct&quot; class=&quot;headerlink&quot; title=&quot;2.1.1 distinct&quot;&gt;&lt;/a&gt;2.1.1 distinct&lt;/h4&gt;&lt;p&gt;distinct，类似于数据库中的排重函数，就是对结果集去重。&lt;br&gt;例如有一个数值numArr = [1,5,8,6,5,2,6]，现在要输出该数值中的所有奇数并且不能重复输出，那该如何实现呢？&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Arrays.stream(numArr).filter(  a -&amp;gt; a % 2 &amp;#x3D;&amp;#x3D; 0 ).distinict().forEach(System.out::println);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;2-1-2-limit&quot;&gt;&lt;a href=&quot;#2-1-2-limit&quot; class=&quot;headerlink&quot; title=&quot;2.1.2 limit&quot;&gt;&lt;/a&gt;2.1.2 limit&lt;/h4&gt;&lt;p&gt;截断流，返回一个i不超过指定元素个数的流。&lt;br&gt;还是以上例举例，如果要输出的元素是偶数，不能重复输出，并且只输出1个元素，那又该如何实现呢？&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Arrays.stream(numArr).filter(  a -&amp;gt; a % 2 &amp;#x3D;&amp;#x3D; 0 ).distinict().limit(1).forEach(System.out::println);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;2-1-3-skip&quot;&gt;&lt;a href=&quot;#2-1-3-skip&quot; class=&quot;headerlink&quot; title=&quot;2.1.3 skip&quot;&gt;&lt;/a&gt;2.1.3 skip&lt;/h4&gt;&lt;p&gt;跳过指定元素，返回剩余元素的流，与limit互补。&lt;/p&gt;</summary>
    
    
    
    <category term="java8" scheme="http://example.com/categories/java8/"/>
    
    
    <category term="java8" scheme="http://example.com/tags/java8/"/>
    
    <category term="Lambda" scheme="http://example.com/tags/Lambda/"/>
    
    <category term="流计算" scheme="http://example.com/tags/%E6%B5%81%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>复合Lambda表达式</title>
    <link href="http://example.com/posts/4c12373d.html"/>
    <id>http://example.com/posts/4c12373d.html</id>
    <published>2020-12-09T14:25:35.000Z</published>
    <updated>2020-12-11T04:27:07.763Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="1、比较器复合"><a href="#1、比较器复合" class="headerlink" title="1、比较器复合"></a>1、比较器复合</h2><p><img src="https://img-blog.csdnimg.cn/20190515201329740.png" alt="在这里插入图片描述"><br>上面是JDK8中java.util.Comparator接口，相比jdk1.7增加了好多方法，也许你会觉得奇怪，为什么接口中还能定义方法，原因是JDK8中，可以为接口添加默认实现，使用default关键字定义。</p><p>例如，我们可以这样定义一个比较器：<br>Comparator&lt; Apple&gt;  c = Comparator.comparing(Apple::getWeight());<br>其等价为：<br>Comparator&lt; Apple&gt;  c = Comparator.comparing(  (a) -&gt; a.getWeight()  );</p><p>为什么可以这样写呢？因为Comparator定义了如下静态方法：<br><img src="https://img-blog.csdnimg.cn/20190515202531959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="1-1-逆序"><a href="#1-1-逆序" class="headerlink" title="1.1 逆序"></a>1.1 逆序</h4><p>Comparator定义了一个静态方法，reversed，故我们不需要重新再定义一个比较器，我们可以这样就能实现逆序排序：<br>List&lt; Apple&gt; apples = new ArrayList&lt;&gt;();<br>apples.sort(  Comparator.comparing(Apple::getWeight()).reversed()  );</p><h4 id="1-2-比较器链"><a href="#1-2-比较器链" class="headerlink" title="1.2 比较器链"></a>1.2 比较器链</h4><p>如果要支持多重排序呢？例如先根据苹果的重量，如果重量相同就按照颜色排序，那如何来实现呢？<br>apples.sort(  Comparator.comparing(Apple::getWeight()).thenComparing(  Apple::getColor()  ) );<br>之所以可以使用上述表达式，是因为Comparator定义了如下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default &lt;U extends Comparable&lt;? super U&gt;&gt; Comparator&lt;T&gt; thenComparing( Function&lt;? super T, ? extends U&gt; keyExtractor)</span><br><span class="line">&#123;</span><br><span class="line">    return thenComparing(comparing(keyExtractor));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>温馨提示：Comparator中定义很多thenComparing重载方法,在具体使用过程中，可以先看看其函数声明。</p></blockquote><a id="more"></a><h4 id="2、谓词复合"><a href="#2、谓词复合" class="headerlink" title="2、谓词复合"></a>2、谓词复合</h4><p>提到谓词复合，我们就不得不提Predicate&lt; T &gt;函数式编程接口，其类图如下所示：<br><img src="https://img-blog.csdnimg.cn/20190515203712938.png" alt="在这里插入图片描述"></p><ul><li>and：与</li><li>negate：非</li><li>or：或</li></ul><blockquote><p>温馨提示：and 和 or 方法是按照在表达式链中的位置，从左向右确定优先级的。因此， a.or(b).and(c) 可以看作 (a || b) &amp;&amp; c 。</p></blockquote><p>使用示例：从苹果列表中找出所有红色的，并且重量超过150的苹果：</p><p>apples.filter(   (a -&gt; “red”.equals(a.getColor()) ).and(  a -&gt; a.getWeight() &gt; 150  )   );</p><p>a -&gt; “red”.equals(a.getColor())  是 (Apple a ) -&gt; “red”.equals(a.getColor())的简写。</p><h2 id="3、函数复合"><a href="#3、函数复合" class="headerlink" title="3、函数复合"></a>3、函数复合</h2><p>函数复合，其对应的函数式编程接口为Function&lt;T,R&gt;，其类图如下：<br><img src="https://img-blog.csdnimg.cn/20190515204237920.png" alt="在这里插入图片描述"></p><ul><li>addThen<br>andThen 方法会返回一个函数，它先对输入应用一个给定函数，再对输出应用另一个函数。<br>例如：<br>Function&lt;Integer, Integer&gt; f = x -&gt; x + 1;<br>Function&lt;Integer, Integer&gt; g = x -&gt; x * 2;<br>Function&lt;Integer, Integer&gt; h = f.andThen(g);<br>int result = h.apply(1);  // 其结果返回4，类似与数学公式  f(g(x))。</li><li>compose<br>先把给定的函数用作 compose 的参数里面给的那个函数，然后再把函数本身用于结果。与addThen的函数应用方向相反，同样举例说明如下：<br>Function&lt;Integer, Integer&gt; f = x -&gt; x + 1;<br>Function&lt;Integer, Integer&gt; g = x -&gt; x * 2;<br>Function&lt;Integer, Integer&gt; h = f.compose(g);<br>int result = h.apply(1);  // 其结果返回3，类似与数学公式  g(f(x))。</li></ul></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1、比较器复合&quot;&gt;&lt;a href=&quot;#1、比较器复合&quot; class=&quot;headerlink&quot; title=&quot;1、比较器复合&quot;&gt;&lt;/a&gt;1、比较器复合&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515201329740.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;上面是JDK8中java.util.Comparator接口，相比jdk1.7增加了好多方法，也许你会觉得奇怪，为什么接口中还能定义方法，原因是JDK8中，可以为接口添加默认实现，使用default关键字定义。&lt;/p&gt;
&lt;p&gt;例如，我们可以这样定义一个比较器：&lt;br&gt;Comparator&amp;lt; Apple&amp;gt;  c = Comparator.comparing(Apple::getWeight());&lt;br&gt;其等价为：&lt;br&gt;Comparator&amp;lt; Apple&amp;gt;  c = Comparator.comparing(  (a) -&amp;gt; a.getWeight()  );&lt;/p&gt;
&lt;p&gt;为什么可以这样写呢？因为Comparator定义了如下静态方法：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515202531959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-1-逆序&quot;&gt;&lt;a href=&quot;#1-1-逆序&quot; class=&quot;headerlink&quot; title=&quot;1.1 逆序&quot;&gt;&lt;/a&gt;1.1 逆序&lt;/h4&gt;&lt;p&gt;Comparator定义了一个静态方法，reversed，故我们不需要重新再定义一个比较器，我们可以这样就能实现逆序排序：&lt;br&gt;List&amp;lt; Apple&amp;gt; apples = new ArrayList&amp;lt;&amp;gt;();&lt;br&gt;apples.sort(  Comparator.comparing(Apple::getWeight()).reversed()  );&lt;/p&gt;
&lt;h4 id=&quot;1-2-比较器链&quot;&gt;&lt;a href=&quot;#1-2-比较器链&quot; class=&quot;headerlink&quot; title=&quot;1.2 比较器链&quot;&gt;&lt;/a&gt;1.2 比较器链&lt;/h4&gt;&lt;p&gt;如果要支持多重排序呢？例如先根据苹果的重量，如果重量相同就按照颜色排序，那如何来实现呢？&lt;br&gt;apples.sort(  Comparator.comparing(Apple::getWeight()).thenComparing(  Apple::getColor()  ) );&lt;br&gt;之所以可以使用上述表达式，是因为Comparator定义了如下方法：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;default &amp;lt;U extends Comparable&amp;lt;? super U&amp;gt;&amp;gt; Comparator&amp;lt;T&amp;gt; thenComparing( Function&amp;lt;? super T, ? extends U&amp;gt; keyExtractor)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return thenComparing(comparing(keyExtractor));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;温馨提示：Comparator中定义很多thenComparing重载方法,在具体使用过程中，可以先看看其函数声明。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="java8" scheme="http://example.com/categories/java8/"/>
    
    
    <category term="java8" scheme="http://example.com/tags/java8/"/>
    
    <category term="Lambda" scheme="http://example.com/tags/Lambda/"/>
    
    <category term="函数式编程" scheme="http://example.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Lambda表达式语法与函数式编程接口</title>
    <link href="http://example.com/posts/26a08b7d.html"/>
    <id>http://example.com/posts/26a08b7d.html</id>
    <published>2020-12-09T14:23:35.000Z</published>
    <updated>2020-12-11T04:16:55.018Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="1、lambda语法初探"><a href="#1、lambda语法初探" class="headerlink" title="1、lambda语法初探"></a>1、lambda语法初探</h2><p>java8 lambda表达式语法的两种格式：</p><ul><li>(parameters)  -&gt;  expression</li><li>(parameters) -&gt; {statements;}</li></ul><p>语法解读：</p><ol><li>(parameters)，lambda表达式的参数列表，其定义方法为JAVA普通的方法相同，例如(Object a, Object b)。</li><li>-&gt; 箭头，是参数列表与lambda表达式主题部分的分隔符号。</li><li>expression 单表达式</li><li>{statements; } 语句。</li></ol><p>测试：如下语句是否是正确的lambda表达式。<br>(1)  () -&gt; {}<br>(2)  () -&gt; “Raoul”<br>(3)  () -&gt; {return “Mario”;}<br>(4)  (Integer i) -&gt; return “Alan” + i;<br>(5)  (String s) -&gt; {“IronMan”;}</p><p>正解：<br>(1) 正确。如果使用匿名类(接口名统一使用IDemoLambda)表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> new IDemoLambda() &#123;</span><br><span class="line">     public void test() &#123;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)正确。如果使用匿名类(接口名统一使用IDemoLambda)表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> new IDemoLambda() &#123;</span><br><span class="line">     public String test() &#123;</span><br><span class="line">           return &quot;Raoul&quot;;  &#x2F;&#x2F; 如果直接接一个值，表示返回该值</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)正确。如果使用匿名类(接口名统一使用IDemoLambda)表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> new IDemoLambda() &#123;</span><br><span class="line">     public String test() &#123;</span><br><span class="line">          return &quot;Mario&quot;;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4)错误。因为return是流程控制语句，表示返回，不是一个表达式，故不符合lambda语法，正确的表示方法应该是 (Integer i) -&gt;{ return “Alan” + i;}。如果使用匿名类(接口名统一使用IDemoLambda)表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> new IDemoLambda() &#123;</span><br><span class="line">     public String test(Integer i) &#123;</span><br><span class="line">          return &quot;Alan&quot; + i;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(5)错误。因为”IronMan”是一个表达式，并不是一个语句，故不能使用{}修饰，应修改为 (String s) -&gt; “IronMan”。如果使用匿名类(接口名统一使用IDemoLambda)表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> new IDemoLambda() &#123;</span><br><span class="line">     public String test(String s) &#123;</span><br><span class="line">          return &quot;IronMan&quot;;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、初步接触函数式接口"><a href="#2、初步接触函数式接口" class="headerlink" title="2、初步接触函数式接口"></a>2、初步接触函数式接口</h2><p>在java8中，一个接口如果只定义了一个抽象方法，那这个接口就可以称为函数式接口，就可以使用lambda表达式来简化程序代码。Lambda表达式可以直接赋值给变量，也可以直接作为参数传递给函数，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void startThread(Runnable a) &#123;</span><br><span class="line">    (new Thread(a)).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F; lambda表达式可以直接赋值给变量，也可以直接以参数的形式传递给方法、</span><br><span class="line">    Runnable a &#x3D; () -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;Hello World,Lambda...&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F; JDK8之前使用匿名类来实现</span><br><span class="line">    Runnable b &#x3D; new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;Hello World,Lambda...&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    startThread(a);</span><br><span class="line">    startThread(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;Hello World,Lambda...&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那能将(int a) -&gt; {System.out.println(“Hello World, Lambda…”);}表达式赋值给Runnable a变量吗？答案是不能，因为该表达式不符合函数式编程接口(Runnable)唯一抽象方法的函数签名列表。<br>Runnable的函数式签名列表为public abstract void run();</p><blockquote><p>温馨提示：如果我们有留意JDK8的Runnable接口的定义，你会发现给接口相对JDK8之前的版本多了一个注解：@FunctionalInterface，该注解是一个标识注解，用来标识这个接口是一个函数式接口。如果我们人为在一个不满足函数式定义的接口上增加@FunctionalInterface，则会在编译时提示错误。</p></blockquote><a id="more"></a><h2 id="3、-Lambda表达式实战思考"><a href="#3、-Lambda表达式实战思考" class="headerlink" title="3、 Lambda表达式实战思考"></a>3、 Lambda表达式实战思考</h2><p>例如有如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 处理文件：当前需求是处理文件的第一行数据</span><br><span class="line"> * @return</span><br><span class="line"> * @throws IOException</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static String processFile() throws IOException &#123;</span><br><span class="line">    try(BufferedReader br &#x3D; new BufferedReader(new FileReader(&quot;data.txt&quot;))) &#123;</span><br><span class="line">        return  br.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前需求为处理文件的第一行数据，那问题来了，如果需求变化需要返回文件的第一行和第二行数据，那该如何进行改造呢？<br>在理想的情况下，需要重用执行设置和关闭流的代码，并告诉processFile()方法对文件执行不同的操作，换句话说就是要实现对processFile的行为进行参数化。</p><p>Step·1：行为参数化<br>要读取文件的头两行，用Lambda语法如何实现呢？思考一下，下面这条语句是否可以实现？</p><p>(BufferedReader bf) -&gt; br.readLine() + br.readLine()<br>答案是当然可以，接下来就要思考，定义一个什么样的方法，能接收上面这个参数。</p><p>Step2：使用函数式接口来传递行为<br>要使用(bufferedReader bf) -&gt; br.readLine() + br.readLine()，则需要定义一个接受参数为BufferedReader，并返回String类型的函数式接口。<br>定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface BufferedReaderProcessor &#123;</span><br><span class="line">     public String process(BufferedReader b) throws IoException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那把processFile方法改造成如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 处理文件：当前需求是处理文件的第一行数据</span><br><span class="line"> * @return</span><br><span class="line"> * @throws IOException</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static String processFile(BufferedReaderProcess brp) throws IOException &#123;</span><br><span class="line">    try(BufferedReader br &#x3D; new BufferedReader(new FileReader(&quot;data.txt&quot;))) &#123;</span><br><span class="line">        return  brp.process(br);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step3：使用lambda表达式作为参数进行传递<br>将行为参数化后，并对方法进行改造，使方法接受一个函数式编程接口后，就可以将Lambda表达式直接传递给方法，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">processFile(  (BufferedReader br)  -&gt; br.readLine()  );</span><br><span class="line">processFile( (BufferedReader bf) -&gt; br.readLine() + br.readLine()); </span><br></pre></td></tr></table></figure><h2 id="4、Java8中自定义函数式接口"><a href="#4、Java8中自定义函数式接口" class="headerlink" title="4、Java8中自定义函数式接口"></a>4、Java8中自定义函数式接口</h2><p>从上面的讲解中我们已然能够得知，要能够将Lambda表达式当成方法参数进行参数行为化的一个前提条件是首先要在方法列表中使用一个函数式接口，例如上例中的BufferReaderProcess，那如果每次使用Labmbda表达式之前都要定义各自的函数式编程接口，那也够麻烦的，那有没有一种方式，或定义一种通用的函数式编程接口呢？答案是肯定的，Java8的设计者，利用泛型，定义了一整套函数式编程接口，下面将介绍java8中常用的函数式编程接口。</p><h4 id="4-1-Predicate"><a href="#4-1-Predicate" class="headerlink" title="4.1 Predicate"></a>4.1 Predicate</h4><p><img src="https://img-blog.csdnimg.cn/20190512222228610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>所谓函数式编程接口就是只能定义一个抽象方法，Predicate 函数接口中定义的抽象方法为 boolean test(T t)，对应的函数式行为为接收一类对象 t，返回 boolean 类型，其可用的 lambda 表达式为 (T t) -&gt; boolean 类型的表达式，例如(Sample a) -&gt; a.isEmpty() 。</p><p>该接口通常的应用场景为过滤。例如，要定义一个方法，从集合中进行刷选，具体的刷选逻辑（行为）由参数进行指定，那我们可以定义这样一个刷选的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, Predicate&lt;T&gt; p) &#123;</span><br><span class="line">List&lt;T&gt; results &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">for(T s: list)&#123;</span><br><span class="line">if(p.test(s))&#123;</span><br><span class="line">results.add(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数，我们可以这样进行调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; behaviorFilter &#x3D; (String s) -&gt; !s.isEmpty();  &#x2F;&#x2F; lambda表达式赋值给一个变量</span><br><span class="line">filter(behaviorFilter);  </span><br></pre></td></tr></table></figure><p>其它add等方法，将在下文介绍（复合lambda表达式）。</p><p>另外，为了避免java基本类型与包装类型的装箱与拆箱带来的性能损耗，JDK8的设计者们提供了如下函数式编程接口：IntPredicate、LongPredicate、DoublePredicate。我们选择LongPredicate看一下其函数接口的声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean test(long value);</span><br></pre></td></tr></table></figure><h4 id="4-2-Consumer"><a href="#4-2-Consumer" class="headerlink" title="4.2 Consumer"></a>4.2 Consumer</h4><p><img src="https://img-blog.csdnimg.cn/20190512222420653.png" alt="在这里插入图片描述"><br>该函数式编程接口适合对对象进行处理，但没有返回值,对应的函数描述符：T -&gt; void</p><p>举例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; void forEach(List&lt;T&gt; list, Consumer&lt;T&gt; c) &#123;</span><br><span class="line">    for(T t : list) &#123;</span><br><span class="line">        c.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其调用示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forEach(  Arrays.asList(1,2,3,4,5),   (Integer i) -&gt; System.out.println(i) ); </span><br></pre></td></tr></table></figure><p>另外，为了避免java基本类型与包装类型的装箱与拆箱带来的性能损耗，JDK8的设计者们提供了如下函数式编程接口：IntConsumer、LongConsumer、DoubleConsumer。</p><h4 id="4-3-Function-lt-T-R-gt"><a href="#4-3-Function-lt-T-R-gt" class="headerlink" title="4.3 Function&lt;T,R&gt;"></a>4.3 Function&lt;T,R&gt;</h4><p><img src="https://img-blog.csdnimg.cn/20190512222646904.png" alt="在这里插入图片描述"><br>其适合的场景是，接收一个泛型T的对象，返回一个泛型为R的对象，其对应的函数描述符:  T -&gt; R。</p><p>示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T,R&gt; List&lt;R&gt; map(List&lt;T&gt; list, Function&lt;T,R&gt; f) &#123;</span><br><span class="line">          List&lt;R&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">          for(T t : list) &#123;</span><br><span class="line">                result.add(  f.apply(t) );</span><br><span class="line">          &#125;</span><br><span class="line">          return result;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Integer&gt; l &#x3D; map(Arrays.asList(&quot;lambdas&quot;, &quot;in&quot;, &quot;action&quot;),  (String s)  -&gt; s.length  );</span><br></pre></td></tr></table></figure><p>另外，为了避免java基本类型与包装类型的装箱与拆箱带来的性能损耗，JDK8的设计者们提供了如下函数式编程接口：IntFunction&lt; R&gt;、LongFunction&lt; R&gt;、DoubleFunction&lt; R&gt;、IntToDoubleFunction、IntToLongFunction、LongToIntFunction、LongToDoubleFunction、ToIntFunction&lt; T&gt;、ToDoubleFunction&lt; T&gt;、ToLongFunction&lt; T&gt;。</p><h4 id="4-4-Supplier-lt-T-gt"><a href="#4-4-Supplier-lt-T-gt" class="headerlink" title="4.4 Supplier&lt; T&gt;"></a>4.4 Supplier&lt; T&gt;</h4><p><img src="https://img-blog.csdnimg.cn/20190512222740390.png" alt="在这里插入图片描述"><br>函数描述符：() -&gt; T。适合创建对象的场景，例如  () -&gt; new Object();</p><p>另外，为了避免java基本类型与包装类型的装箱与拆箱带来的性能损耗，JDK8的设计者们提供了如下函数式编程接口：BooleanSupplier、IntSupplier、LongSupplier、DoubleSupplier。</p><h4 id="4-5-UnaryOperator-lt-T-gt"><a href="#4-5-UnaryOperator-lt-T-gt" class="headerlink" title="4.5 UnaryOperator&lt; T &gt;"></a>4.5 UnaryOperator&lt; T &gt;</h4><p><img src="https://img-blog.csdnimg.cn/20190512222814465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>一元运算符函数式接口，接收一个泛型T的对象，同样返回一个泛型T的对象。<br>示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; List&lt;T&gt; map(List&lt;T&gt; list, UnaryOperator&lt;T&gt; f) &#123;</span><br><span class="line">          List&lt;R&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">          for(T t : list) &#123;</span><br><span class="line">                result.add(  f.apply(t) );</span><br><span class="line">          &#125;</span><br><span class="line">          return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map(  list, (int i) -&gt; i ++ );</span><br></pre></td></tr></table></figure><p>另外，为了避免java基本类型与包装类型的装箱与拆箱带来的性能损耗，JDK8的设计者们提供了如下函数式编程接口：IntUnaryOperator、LongUnaryOperator、DoubleUnaryOperator。</p><h4 id="4-6-BiPredicate-lt-T-U-gt"><a href="#4-6-BiPredicate-lt-T-U-gt" class="headerlink" title="4.6 BiPredicate&lt;T,U&gt;"></a>4.6 BiPredicate&lt;T,U&gt;</h4><p><img src="https://img-blog.csdnimg.cn/20190512222852671.png" alt="在这里插入图片描述"><br>接收两个参数，返回boolean类型。其对应的函数描述符：(T,U) -&gt; boolean。</p><h4 id="4-7-BiConsumer-lt-T-U-gt"><a href="#4-7-BiConsumer-lt-T-U-gt" class="headerlink" title="4.7 BiConsumer&lt;T,U&gt;"></a>4.7 BiConsumer&lt;T,U&gt;</h4><p><img src="https://img-blog.csdnimg.cn/20190512222914785.png" alt="在这里插入图片描述"><br>与Consume函数式接口类似，只是该接口接收两个参数，对应的函数描述符(T,U)  -&gt; void。</p><p>另外，为了避免java基本类型与包装类型的装箱与拆箱带来的性能损耗，JDK8的设计者们提供了如下函数式编程接口：ObjIntConsumer、ObjLongConsumer、ObjDoubleConsumer。</p><h4 id="4-8-BiFunction-lt-T-U-R-gt"><a href="#4-8-BiFunction-lt-T-U-R-gt" class="headerlink" title="4.8 BiFunction&lt;T,U,R&gt;"></a>4.8 BiFunction&lt;T,U,R&gt;</h4><p><img src="https://img-blog.csdnimg.cn/20190512222939113.png" alt="在这里插入图片描述"><br>与Function函数式接口类似，其对应的函数描述符：(T,U) -&gt; R。</p><p>另外，为了避免java基本类型与包装类型的装箱与拆箱带来的性能损耗，JDK8的设计者们提供了如下函数式编程接口：ToIntBiFunction(T,U)、ToLongBiFunction(T,U)、ToDoubleBiFunction(T,U)。</p><h4 id="4-9-BinaryOperator-lt-T-gt"><a href="#4-9-BinaryOperator-lt-T-gt" class="headerlink" title="4.9 BinaryOperator&lt; T &gt;"></a>4.9 BinaryOperator&lt; T &gt;</h4><p><img src="https://img-blog.csdnimg.cn/20190512223009303.png" alt="在这里插入图片描述"><br>二维运算符，接收两个T类型的对象，返回一个T类型的对象。</p><p>另外，为了避免java基本类型与包装类型的装箱与拆箱带来的性能损耗，JDK8的设计者们提供了如下函数式编程接口：IntBinaryOperator、LongBinaryOperator、DoubleBinaryOperator。</p><p>上述就是JDK8定义在java.util.function中的函数式编程接口。重点关注的是其定义的函数式编程接口，其复合操作相关的API将在下文中详细介绍。</p><h2 id="5、类型检查、类型推断以及限制"><a href="#5、类型检查、类型推断以及限制" class="headerlink" title="5、类型检查、类型推断以及限制"></a>5、类型检查、类型推断以及限制</h2><h4 id="5-1-类型检查"><a href="#5-1-类型检查" class="headerlink" title="5.1 类型检查"></a>5.1 类型检查</h4><p>java8是如何检查传入的Lambda表示式是否符合约定的类型呢？<br>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, Predicate&lt;T&gt; p) &#123;</span><br><span class="line">    List&lt;T&gt; results &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for(T s: list)&#123;</span><br><span class="line">        if(p.test(s))&#123;</span><br><span class="line">            results.add(s);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Apple&gt; heavierThan150g &#x3D; filter(inventory, (Apple a) -&gt; a.getWeight() &gt; 150);</span><br></pre></td></tr></table></figure><p>其类型检测的步骤：<br>1）首先查看filter函数的参数列表，得出Lambda对应的参数类型为Predicate&lt; T &gt;。<br>2）函数式接口Predicate中定义的抽象接口为  boolean test(T t),对应的函数描述符(  T  -&gt;  boolean)。<br>3）验证Lambda表达式是否符合函数描述符。</p><p>注意：如果一个Lambda的主体式一个语句表达式，它就和一个返回void的函数描述符兼容（当然参数列表也必须兼容）。例如，以下两行都是合法的，尽管List的add方法返回一个boolean，而不式Consumer上下文(T -&gt; void)所要求的void：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Predicate返回了一个boolean</span><br><span class="line">Predicate&lt;String&gt; p &#x3D; s -&gt; list.add(s);</span><br><span class="line">&#x2F;&#x2F; Consumer返回了一个void</span><br><span class="line">Consumer&lt;String&gt; b &#x3D; s -&gt; list.add(s);</span><br></pre></td></tr></table></figure><p>思考题：如下表达式是否正确？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o &#x3D; () -&gt; &#123;System.out.println(&quot;Tricky example&quot;); &#125;;</span><br></pre></td></tr></table></figure><p>答案是错误的，该语句的含义就是把lambda表达式复制给目标对象(Object o)，lambda对应的函数描述符为() -&gt; void，期望目标对象拥有一个唯一的抽象方法，参数列表为空，返回值为void的方法，显然目标对象Object不满足该条件，如果换成如下示例，则能编译通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable r &#x3D; () &#123;System.out.println(&quot;Tricky example&quot;); &#125;;</span><br></pre></td></tr></table></figure><p>因为Runnable的定义如下：<br><img src="https://img-blog.csdnimg.cn/20190512223153712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="5-2-类型推断"><a href="#5-2-类型推断" class="headerlink" title="5.2 类型推断"></a>5.2 类型推断</h4><p>所谓的类型推断，指的式java编译器能根据目标类型来推断出用什么函数式接口来配合Lambda表达式，这也意味着它也可以推断出适合Lambda的签名，因为函数描述符可以通过目标类型得到。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; greenApples &#x3D;  filter(inventory, （Apple a） -&gt; &quot;green&quot;.equals(a.getColor()));</span><br><span class="line">也可以写成</span><br><span class="line">List&lt;Apple&gt; greenApples &#x3D;  filter(inventory, a  -&gt; &quot;green&quot;.equals(a.getColor()));</span><br><span class="line"></span><br><span class="line">Lambda表达式有多个参数，代码可读性的好处就更为明显。例如，你可以这样来创建一个Comparator 对象：</span><br><span class="line">Comparator&lt;Apple&gt; c &#x3D;  (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight());</span><br><span class="line">Comparator&lt;Apple&gt; c &#x3D; (a1, a2) -&gt; a1.getWeight().compareTo(a2.getWeight());</span><br></pre></td></tr></table></figure><p>由于java编译器能根据目标类型来推导出Lambda的函数签名，故lambda的函数签名列表时，可以去掉参数的类型。</p><h4 id="5-3-局部变量"><a href="#5-3-局部变量" class="headerlink" title="5.3 局部变量"></a>5.3 局部变量</h4><p>Lambda表达式主体部分也能引入外部的变量，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int portNumber &#x3D; 1337;</span><br><span class="line">Runnable r &#x3D; () -&gt; System.out.println(portNumber);</span><br></pre></td></tr></table></figure><p>其中portNumber参数并不是方法签名参数，但这样有一个限制条件，引入的局部变量必须是常量（实际意义上的常量，可以不用final来定义，但不能改变其值。例如如下示例是错误的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int portNumber &#x3D; 1337;</span><br><span class="line">Runnable r &#x3D; () -&gt; System.out.println(portNumber);</span><br><span class="line">portNumber &#x3D; 1228;  &#x2F;&#x2F; 因为portNumber的值已改变，不符合局部变量的捕获条件，上述代码无法编译通过。</span><br></pre></td></tr></table></figure><h4 id="5-4-方法引用"><a href="#5-4-方法引用" class="headerlink" title="5.4 方法引用"></a>5.4 方法引用</h4><h5 id="5-4-1-方法引用常用的构造方法"><a href="#5-4-1-方法引用常用的构造方法" class="headerlink" title="5.4.1 方法引用常用的构造方法"></a>5.4.1 方法引用常用的构造方法</h5><p>JDK8中有3中方法引用：</p><ol><li>指向静态方法的方法引用<br>Integer.parseInt  对应的方法引用可以写成： Integer::parseInt。</li><li>指向任意类型的实例方法的引用<br>  (Strng str ) -&gt; str.length  对应的方法引用：String::length。(注意这里的属性为方法列表)</li><li>lambda捕获外部的实例对象<br>例如如下代码：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Apple a &#x3D; new Apple();</span><br><span class="line">process(  () -&gt; a.getColor()  );  &#x2F;&#x2F; 则可以写成  process ( a::getColor ); </span><br></pre></td></tr></table></figure><h5 id="5-4-2-构造函数引用"><a href="#5-4-2-构造函数引用" class="headerlink" title="5.4.2 构造函数引用"></a>5.4.2 构造函数引用</h5><p>大家可以回想一下，jdk8中定义了一个创建对象的函数式编程接口Supplier,函数描述符：() -&gt; T。适合创建对象的场景，例如  () -&gt; new Object();<br>对于没有构造函数的，我们可以这样来创建对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Apple&gt; c1 &#x3D; Apple:new;</span><br><span class="line">Apple a1 &#x3D; c1.get();</span><br></pre></td></tr></table></figure><p>如果有1个参数的构造方法呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Apple&gt; c2 &#x3D; Apple::new;</span><br><span class="line">Apple a2 &#x3D; c2.apply(weight);</span><br></pre></td></tr></table></figure><p>Lambda语法的基础知识就介绍到这里，本文详细介绍了Lambda表达式的语法格式、函数式编程接口、lambda与函数式编程接口的关系、方法引用。</p><p>下一节主要介绍复合Lambda表达式使用。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1、lambda语法初探&quot;&gt;&lt;a href=&quot;#1、lambda语法初探&quot; class=&quot;headerlink&quot; title=&quot;1、lambda语法初探&quot;&gt;&lt;/a&gt;1、lambda语法初探&lt;/h2&gt;&lt;p&gt;java8 lambda表达式语法的两种格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(parameters)  -&amp;gt;  expression&lt;/li&gt;
&lt;li&gt;(parameters) -&amp;gt; {statements;}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;语法解读：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;(parameters)，lambda表达式的参数列表，其定义方法为JAVA普通的方法相同，例如(Object a, Object b)。&lt;/li&gt;
&lt;li&gt;-&amp;gt; 箭头，是参数列表与lambda表达式主题部分的分隔符号。&lt;/li&gt;
&lt;li&gt;expression 单表达式&lt;/li&gt;
&lt;li&gt;{statements; } 语句。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;测试：如下语句是否是正确的lambda表达式。&lt;br&gt;(1)  () -&amp;gt; {}&lt;br&gt;(2)  () -&amp;gt; “Raoul”&lt;br&gt;(3)  () -&amp;gt; {return “Mario”;}&lt;br&gt;(4)  (Integer i) -&amp;gt; return “Alan” + i;&lt;br&gt;(5)  (String s) -&amp;gt; {“IronMan”;}&lt;/p&gt;
&lt;p&gt;正解：&lt;br&gt;(1) 正确。如果使用匿名类(接口名统一使用IDemoLambda)表示如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; new IDemoLambda() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     public void test() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;(2)正确。如果使用匿名类(接口名统一使用IDemoLambda)表示如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; new IDemoLambda() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     public String test() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           return &amp;quot;Raoul&amp;quot;;  &amp;#x2F;&amp;#x2F; 如果直接接一个值，表示返回该值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;(3)正确。如果使用匿名类(接口名统一使用IDemoLambda)表示如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; new IDemoLambda() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     public String test() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          return &amp;quot;Mario&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;(4)错误。因为return是流程控制语句，表示返回，不是一个表达式，故不符合lambda语法，正确的表示方法应该是 (Integer i) -&amp;gt;{ return “Alan” + i;}。如果使用匿名类(接口名统一使用IDemoLambda)表示如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; new IDemoLambda() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     public String test(Integer i) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          return &amp;quot;Alan&amp;quot; + i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;(5)错误。因为”IronMan”是一个表达式，并不是一个语句，故不能使用{}修饰，应修改为 (String s) -&amp;gt; “IronMan”。如果使用匿名类(接口名统一使用IDemoLambda)表示如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; new IDemoLambda() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     public String test(String s) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          return &amp;quot;IronMan&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;2、初步接触函数式接口&quot;&gt;&lt;a href=&quot;#2、初步接触函数式接口&quot; class=&quot;headerlink&quot; title=&quot;2、初步接触函数式接口&quot;&gt;&lt;/a&gt;2、初步接触函数式接口&lt;/h2&gt;&lt;p&gt;在java8中，一个接口如果只定义了一个抽象方法，那这个接口就可以称为函数式接口，就可以使用lambda表达式来简化程序代码。Lambda表达式可以直接赋值给变量，也可以直接作为参数传递给函数，示例如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public static void startThread(Runnable a) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (new Thread(a)).start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#x2F;&amp;#x2F; lambda表达式可以直接赋值给变量，也可以直接以参数的形式传递给方法、&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Runnable a &amp;#x3D; () -&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&amp;quot;Hello World,Lambda...&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#x2F;&amp;#x2F; JDK8之前使用匿名类来实现&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Runnable b &amp;#x3D; new Runnable() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        public void run() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&amp;quot;Hello World,Lambda...&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    startThread(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    startThread(() -&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&amp;quot;Hello World,Lambda...&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那能将(int a) -&amp;gt; {System.out.println(“Hello World, Lambda…”);}表达式赋值给Runnable a变量吗？答案是不能，因为该表达式不符合函数式编程接口(Runnable)唯一抽象方法的函数签名列表。&lt;br&gt;Runnable的函数式签名列表为public abstract void run();&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;温馨提示：如果我们有留意JDK8的Runnable接口的定义，你会发现给接口相对JDK8之前的版本多了一个注解：@FunctionalInterface，该注解是一个标识注解，用来标识这个接口是一个函数式接口。如果我们人为在一个不满足函数式定义的接口上增加@FunctionalInterface，则会在编译时提示错误。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="java8" scheme="http://example.com/categories/java8/"/>
    
    
    <category term="java8" scheme="http://example.com/tags/java8/"/>
    
    <category term="Lambda" scheme="http://example.com/tags/Lambda/"/>
    
    <category term="函数式编程" scheme="http://example.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>结合 Sentinel 专栏谈谈我的源码阅读技巧</title>
    <link href="http://example.com/posts/b9d8cad7.html"/>
    <id>http://example.com/posts/b9d8cad7.html</id>
    <published>2020-12-08T15:05:35.000Z</published>
    <updated>2020-12-08T15:05:41.760Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p>本文行文思路：先抛出源码阅读方法，然后结合Sentinel创作过程谈谈具体是如何运用这些技巧，最后解答几个源码阅读的误区。</p></blockquote><p>Sentinel 系列共包含15篇文章，主要以源码分析为手段，图文并茂的方式对 Sentinel 的架构设计理念、核心实现要点进行了一一剖析，并加以实战分析与思考。</p><p><strong>很多朋友都在询我是如何阅读源码的。对此可归纳为如下几个要点，然后结合 Sentienl 源码分析专栏对各个要点进行拆解，对源码阅读方法进行一次“实战”。</strong></p><ul><li>阅读官方文档，从全局了解待学习框架能解决什么样的问题，整体架构设计与思想是什么，主要包含哪些要点。</li><li>从官方提供的 Demo 程序开始，学习基本的使用方法，进一步加深其理解，并伺机寻找入口（突破口）。</li><li>寻找突破口，逐一突破，先主干再旁支，适度分解，各个击破。</li></ul><p>接下来将展示我是如何使用这套方法论来学习 Sentinel 的。</p><p>在准备深入学习 Sentinel 之前，首先认真看了一遍 Sentinel 的官方文档，从而形成了对 Sentinel 的基本认识，我们可以从官方文档了解到 Sentinel 主要涉及的核心内容，正如下图所示：<br><img src="https://img-blog.csdnimg.cn/2020053015083815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">这些内容可以简单的当成一个学习的提纲，可以从里面挑选自己感兴趣的进行重点学习。</p><p>在看完官方文档后，我就踏上创作 Sentinel 系列的征途。</p><blockquote><p>本文不会再详细介绍每一个知识点的细节，有关各个知识点的具体讲解，大家可以点击感兴趣的链接中进行深入研究，本文主要是点到为止，重在介绍笔者是如何学习源码的。</p></blockquote><p>1、<a href="https://blog.csdn.net/prestigeding/article/details/103544443">Alibaba Sentinel 限流与熔断初探</a><br>该文章主要从如下几个点进行展开：</p><ul><li>Sentinel 是什么 ？主要能解决什么问题？</li><li>限流与熔断的使用场景</li><li>Sentinel 源码结构</li><li>在 IntelliJ IDEA 中运行 Sentine Demo</li></ul><p>其实第三点并不是特别必须，不过要得出这些结论也并不难，因为对 Sentinel 有了全局的认识后并根据各个模块的命名很容易能得出该模块的作用。这里第四点非常关键，通常一个优秀的开源框架都会提供完备的演示 Demo，大家可以看到 Sentinel 的演示 demo 非常丰富，在本文中我特意选择了 Dubbo 来做示例，主要是我们公司大量使用 dubbo 来实现公司的微服务，这样会更加贴近实战，更有利于寻找突破口。</p><p>通过跑通 Demo 的主要目的有三个：</p><ul><li>通过运行 Demo，了解框架的基本使用方法。</li><li>搭建一个可 Debug 的环境，为后续看不懂代码的情况下进行调试，根据运行时数据，可加快代码的理解速度，但千万不要一开始就 debug。</li><li>寻找源码阅读的入口。</li></ul><p>2、<a href="https://blog.csdn.net/prestigeding/article/details/103654590">源码分析 Sentinel 之 Dubbo 适配原理</a><br>紧跟第一篇文章，既然使用的是 Dubbo 作为其示例代码，自然而然的思考 Sentinel 是如何做到对 Dubbo 的适配并对业务无侵入性。</p><p>通过该篇文章的学习我们了解到可以通过 Dubbo 的扩展机制实现对 Dubbo 的适配，在 Dubbo Filter 中我们能看到了与 Sentinel 相关的核心 API SphU.entry，从而找到深入学习 Sentinel 的核心入口，也就是后续文章会通过对该方法的研究，从而打开进入 Sentinel 内核世界的大门。</p><blockquote><p>备注：在阅读这篇文章的时候，我觉得 Dubbo 的适配感觉非常简单，但随着我对这个系列的深入学习，发现了该方法没有那么简单，当时很多点都没有理解到位，这个在后续会有重点阐述，这也是不断学习、不断思考带来的好处。</p></blockquote><a id="more"></a><p>3、<a href="https://blog.csdn.net/prestigeding/article/details/103842382">寻找一把进入 Alibaba Sentinel 的钥匙</a><br>本文主要是详细跟踪 SphU.entry 方法的执行流程，从而揭晓其实现的关键点，果不其然，通过跟踪该方法的流程，找到了 Sentinel 的核心运作机制：Slot 处理链。<br><img src="https://img-blog.csdnimg.cn/20200530151308395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>就问大家激不激动，开不开心，从这些 Slot 的名字基本就能得出其含义，后续的研究重点就是逐一解开这些 Slot 的实现原理即可。</p><p>4、<a href="https://blog.csdn.net/prestigeding/article/details/103943070">Sentinel 调用上下文环境实现原理</a><br>按照上述 Slot 的链，开始了 NodeSelectorSlot 的研究，通过学习了解到该 NodeSelectorSlot 主要是构建 Sentinel 的调用链，即调用上下文环境管理,准确的说是构建调用链的入口节点。在 Sentinel 中每进入一个资源都会有对应的节点实时存储该资源的调用信息。</p><p>5、Sentinel 实时数据采集原理<br>这个议题共两篇文章，其相关链接如下：</p><ul><li><a href="https://blog.csdn.net/prestigeding/article/details/104045216">实时采集数据详解</a></li><li><a href="https://blog.csdn.net/prestigeding/article/details/103753595">Sentinel 滑动窗口实现原理</a></li></ul><p>如果按照 Slot 链的执行顺序，下一个执行的 ClusterBuilderSlot，从名字就可以看出与集群限流相关的，但秉承着先简后难的学习策略，在当前先跳过该类的学习，先重点突破单机版限流，后续再回过头来学习集群限流相关的知识。</p><p>要实现限流、熔断等功能，首先要解决的问题是如何实时采集服务(资源)调用信息。例如将某一个接口设置的限流阔值 1W/tps，那首先如何判断当前的 TPS 是多少？Alibaba Sentinel 采用滑动窗口来实现实时数据的统计，实现类：StatisticSlot。</p><p>6、Sentinel 限流实现原理<br>在弄懂了 Sentinel 的实时数据采集原理后，限流实现就非常简单了，就是基于采集的调用信息，然后与限流规则进行比较，判断是否需要限流，Sentinel 在触发限流后还提供了多种处理策略，例如快速失败、匀速排队、预热等机制。</p><p>但我在学习限流的时候，我将限流核心逻辑与触发限流后的处理策略进行了分解，在学习限流的时候挑选了最简单处理策略(匀速排队)，将比较难的预热机制分解，再单起一篇文章进行学习，这样的拆解有利于保证学习单篇文章的用时，并提高自己的“产量”，提高自己的成就感。</p><p>这块主要包含如下4篇文章：</p><ul><li><a href="https://blog.csdn.net/prestigeding/article/details/104884255">Sentinel FlowSlot 限流实现原理</a></li><li><a href="https://blog.csdn.net/prestigeding/article/details/105027563"> RateLimiter SmoothBursty 实现原理</a></li><li><a href="https://blog.csdn.net/prestigeding/article/details/105180419">RateLimiter SmoothWarmingUp 实现原理</a></li><li><a href="https://blog.csdn.net/prestigeding/article/details/105341098">Sentinel 匀速排队与预热实现原理与实战建议</a></li></ul><p>这里还要重点阐述一下限流领域最核心的算法：漏桶算法、漏斗算法等，并且 Sentinel 的预热机制主要是参考 Guava 的实现，故这里花了点精力认真学习了 Guava 的 RateLimite 的实现原理。</p><p>7、<a href="https://blog.csdn.net/prestigeding/article/details/105470516">Sentinel DegradeSlot 熔断实现原理</a><br>限流部分学习完后，我就迫不及待的去探究熔断的实现，其实熔断本身并不复杂，和限流一样，无非就是根据当前的实时调用信息与熔断规则进行对比即可，如果满足熔断规则就抛出异常。如果只是熔断自身的实现本质确实简单，但要结合实际，其实有更多的问题需要思考，这个在后面的实战篇又是反复思考，从而发现 Sentinel 在熔断的实现上其实比较粗糙。</p><p>8、<a href="https://blog.csdn.net/prestigeding/article/details/105756877">Sentienl 动态数据源架构设计理念与改造实践</a><br>经过前面的文章，Sentinel 的单机限流与熔断已经基本学习了，这个时候就要开始思考如何使用 Sentinel 了，但 Sentinel 官方提供的后台运维管理系统的熔断、限流规则只能存储在内存，显然不能直接用于生产环境，故需要提出解决方案，本篇文章详细介绍了笔者是如何根据官方资料进行动态数据源配置的方法调研的，完成是按照工作中架构设计方案的标准来思考的，强烈推荐。</p><p>9、<a href="https://blog.csdn.net/prestigeding/article/details/106041456">Sentinel Dubbo 适配器看限流与熔断(实战思考篇)</a><br>支持了动态数据源，就继续进行思考，在微服务领域是如何思考引入熔断机制的，进行一番思考后发现官方提供的 Dubbo 适配器的粒度是服务级别的，无法控制机器级别，例如下图所示：<br><img src="https://img-blog.csdnimg.cn/2020053015244341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>例如当前的 Sentinel Dubbo 适配器目前不支持一个服务其中一台服务提供者变慢，发往这台机器上的请求被熔断，当前的实现版本会调用该服务的所有请求都会被熔断，故官方的 Dubbo 适配器还需要更加完善，有了自己的思考才会对知识理解更多，故通过学习源码，一定不能“尽信书”，要有自己的思考与怀疑能力，这样才能对开源社区做出一定的贡献，共同进步与成长。</p><p>以上就是我学习源码的方法，希望对大家真正有所帮助与感触。</p><p><strong>最后我再来谈一下回答关于源码阅读方面误区的几个问题。</strong></p><p><strong>1、看源码会忘记吗？为什么我们看源码的时候感觉看懂了，但很容易就忘记？</strong></p><p>我们要始终明白看<strong>源码只是手段</strong>，目的是要思考框架的设计原理、并通过源码了解实现细节并指导实践。重在思考。当然实现细节看过后容易忘记，但只要理解了思想，在需要使用时可以看自己写过的文章，一下子就能拾起来。</p><p><strong>2、看源码的时候是不是可以直接使用 Debug 进行调试学习</strong></p><p>我是<strong>强烈不建议</strong>这样做，这样会迷失在细节中无可自拔。正确的姿势是寻找入口，带上自己的思考去梳理，当遇到看不懂源码或是无法理解其思想时，这个时候可以借助 Debug，可以通过运行时可视化的数据，帮助我们更快的了解。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文行文思路：先抛出源码阅读方法，然后结合Sentinel创作过程谈谈具体是如何运用这些技巧，最后解答几个源码阅读的误区。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Sentinel 系列共包含15篇文章，主要以源码分析为手段，图文并茂的方式对 Sentinel 的架构设计理念、核心实现要点进行了一一剖析，并加以实战分析与思考。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;很多朋友都在询我是如何阅读源码的。对此可归纳为如下几个要点，然后结合 Sentienl 源码分析专栏对各个要点进行拆解，对源码阅读方法进行一次“实战”。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阅读官方文档，从全局了解待学习框架能解决什么样的问题，整体架构设计与思想是什么，主要包含哪些要点。&lt;/li&gt;
&lt;li&gt;从官方提供的 Demo 程序开始，学习基本的使用方法，进一步加深其理解，并伺机寻找入口（突破口）。&lt;/li&gt;
&lt;li&gt;寻找突破口，逐一突破，先主干再旁支，适度分解，各个击破。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来将展示我是如何使用这套方法论来学习 Sentinel 的。&lt;/p&gt;
&lt;p&gt;在准备深入学习 Sentinel 之前，首先认真看了一遍 Sentinel 的官方文档，从而形成了对 Sentinel 的基本认识，我们可以从官方文档了解到 Sentinel 主要涉及的核心内容，正如下图所示：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020053015083815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;这些内容可以简单的当成一个学习的提纲，可以从里面挑选自己感兴趣的进行重点学习。&lt;/p&gt;
&lt;p&gt;在看完官方文档后，我就踏上创作 Sentinel 系列的征途。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文不会再详细介绍每一个知识点的细节，有关各个知识点的具体讲解，大家可以点击感兴趣的链接中进行深入研究，本文主要是点到为止，重在介绍笔者是如何学习源码的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、&lt;a href=&quot;https://blog.csdn.net/prestigeding/article/details/103544443&quot;&gt;Alibaba Sentinel 限流与熔断初探&lt;/a&gt;&lt;br&gt;该文章主要从如下几个点进行展开：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sentinel 是什么 ？主要能解决什么问题？&lt;/li&gt;
&lt;li&gt;限流与熔断的使用场景&lt;/li&gt;
&lt;li&gt;Sentinel 源码结构&lt;/li&gt;
&lt;li&gt;在 IntelliJ IDEA 中运行 Sentine Demo&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实第三点并不是特别必须，不过要得出这些结论也并不难，因为对 Sentinel 有了全局的认识后并根据各个模块的命名很容易能得出该模块的作用。这里第四点非常关键，通常一个优秀的开源框架都会提供完备的演示 Demo，大家可以看到 Sentinel 的演示 demo 非常丰富，在本文中我特意选择了 Dubbo 来做示例，主要是我们公司大量使用 dubbo 来实现公司的微服务，这样会更加贴近实战，更有利于寻找突破口。&lt;/p&gt;
&lt;p&gt;通过跑通 Demo 的主要目的有三个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过运行 Demo，了解框架的基本使用方法。&lt;/li&gt;
&lt;li&gt;搭建一个可 Debug 的环境，为后续看不懂代码的情况下进行调试，根据运行时数据，可加快代码的理解速度，但千万不要一开始就 debug。&lt;/li&gt;
&lt;li&gt;寻找源码阅读的入口。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、&lt;a href=&quot;https://blog.csdn.net/prestigeding/article/details/103654590&quot;&gt;源码分析 Sentinel 之 Dubbo 适配原理&lt;/a&gt;&lt;br&gt;紧跟第一篇文章，既然使用的是 Dubbo 作为其示例代码，自然而然的思考 Sentinel 是如何做到对 Dubbo 的适配并对业务无侵入性。&lt;/p&gt;
&lt;p&gt;通过该篇文章的学习我们了解到可以通过 Dubbo 的扩展机制实现对 Dubbo 的适配，在 Dubbo Filter 中我们能看到了与 Sentinel 相关的核心 API SphU.entry，从而找到深入学习 Sentinel 的核心入口，也就是后续文章会通过对该方法的研究，从而打开进入 Sentinel 内核世界的大门。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：在阅读这篇文章的时候，我觉得 Dubbo 的适配感觉非常简单，但随着我对这个系列的深入学习，发现了该方法没有那么简单，当时很多点都没有理解到位，这个在后续会有重点阐述，这也是不断学习、不断思考带来的好处。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="sentinel" scheme="http://example.com/categories/sentinel/"/>
    
    
    <category term="sentinel" scheme="http://example.com/tags/sentinel/"/>
    
  </entry>
  
  <entry>
    <title>Sentinel 系统自适应限流原理剖析与实战指导</title>
    <link href="http://example.com/posts/a815ae71.html"/>
    <id>http://example.com/posts/a815ae71.html</id>
    <published>2020-12-08T15:03:35.000Z</published>
    <updated>2020-12-08T15:04:27.121Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>看到标题中的几个关键字<strong>系统自适应</strong>限流是不是觉得高大上，这个自适应又是如何实现的呢？</p><h2 id="1、Sentinel-系统自适应概述"><a href="#1、Sentinel-系统自适应概述" class="headerlink" title="1、Sentinel 系统自适应概述"></a>1、Sentinel 系统自适应概述</h2><p>从官方了解到 Sentienl 系统自适应限流是一个全局的概念，对应用入口流量统一进行统一控制，结合应用的机器负载、CPU 使用率，总体平均响应时间、入口 QPS 和并发线程数等几个维度的监控指标从而决定是否调用进行限流操作。为了有一个直观的感受，我们可以从官方的运维平台看看其系统自适应限流的操作界面：<br><img src="https://img-blog.csdnimg.cn/2020052413411896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>RT、线程数、入口QPS这三个指标是可以通过采集调用信息进行统计计算的，那系统LOAD、CPU使用率是如何获取的呢？大家可以带着这个问题进入本文的学习中来。</p><p>在详细分析系统自适应实现原理之前我们先来思考一下 Sentinel 引入该机制的目的。</p><p>官方文档针对这个问题有过仔细阐述，我们先来看看官方文档对其阐述。</p><p>引入系统自适应限流的主要的目的有如下两个：</p><ul><li>保证系统不被拖垮</li><li>在系统稳定的前提下保证系统的吞吐量。</li></ul><p>目前我们接触的限流的防护思路都是设定一个指标（阔值），例如系统的负载 load 超过某个阔值后就阻止或减少流量的继续进入，当系统负载降低到某一水平后则恢复流量的进入。通常都是被动的，其实际效果取决与阔值设置是否合理，但往往设置合理不是一件容易的事情。</p><p>那 Sentinel 提供的系统自适应是可以将设定的规则作为一个保护因子，而允许通过的流量由处理请求的能力来决定，即根据请求的响应时间、当前系统正在处理的请求速率来决定。</p><p>那 Sentinel 是如何实现的呢？接下来用源码的手段来揭晓其实现原理。</p><h2 id="2、系统自适应限流原理"><a href="#2、系统自适应限流原理" class="headerlink" title="2、系统自适应限流原理"></a>2、系统自适应限流原理</h2><p>Sentinel 执行系统限流的核心入口类为 SystemSlot，该类实现简单，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200524134158678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="SystemRuleManager#checkSystem"><br>从这里可以看出实现的关键在于SystemRuleManager，这里是直接调用 checkSystem 进行是否触发其限流，那我们接下来重点跟踪一下该方法的实现。</p><h4 id="2-1-自适应限流检测流程"><a href="#2-1-自适应限流检测流程" class="headerlink" title="2.1 自适应限流检测流程"></a>2.1 自适应限流检测流程</h4><p>系统自适应限流检测具体由 SystemRuleManager 的 checkSystem 方法实现，接下来详细剖析其实现细节。<br><img src="https://img-blog.csdnimg.cn/2020052413421556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step1：验证相关资源，主要包含三层验证：</p><ul><li>如果资源名称为空，则直接跳过，这个是容错机制。</li><li>如果系统自适应开关为打开，直接放行，该开关初始化时为 false，在加载到一条系统自适应配置规则时该状态会设置为 true，具体在 loadSystemConf 中。</li><li>如果资源的类型不是入口流量(EntryType.IN),则直接放行。<br><img src="https://img-blog.csdnimg.cn/20200524134428924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step2：从QPS为维度验证是否需要被限流，其实现关键点如下：</li><li>当前的qps，如果 ENTRY_NODE 为空则返回0，否则返回该统计节点的成功 qps，那 ENTRY_NODE 统计节点是“何许人也”，原来是 Sentinel 特定定义了一个资源，其名称为__total_inbound_traffic__，用来采集所有入口调用的信息，当资源进入类型为 ENTRY_TYPE_IN 时，会自动采集信息，其具体统计信息在 StatisticSlot 的 entry 方法中被调用，其截图如下：<br><img src="https://img-blog.csdnimg.cn/20200524134513299.png#pic_center" alt="在这里插入图片描述"></li><li>如果当前调用的 QPS 大于设定的QPS，即触发限流，那这个 qps 又是在什么时候被设置的呢？也是在加载系统限流规则时被设置，如果一个应用同一个限流点（LOAD、QPS)设置了多条规则，最小值生效。<br><img src="https://img-blog.csdnimg.cn/20200524134545735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step3：关于线程数、响应时间限流模式与QPS类似，就不再重复介绍。<br><img src="https://img-blog.csdnimg.cn/20200524134621142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step4：如果当前系统的负载超过了设定的阔值的处理逻辑，这里就是自适应的核心所在，并不是超过负载就限流，而是需要根据当前系统的请求处理能力进行综合判断，具体逻辑在 checkBbr 方法中实现。关于如何获得系统负载与 checkBbr 方法稍后会详细介绍。<br><img src="https://img-blog.csdnimg.cn/20200524134709868.png#pic_center" alt="在这里插入图片描述"><br>Step5：如果当前CPU的负载超过了设置的阔值，触发限流，那在JAVA中是如何获取CPU的使用率的呢？稍后详细介绍。</li></ul><a id="more"></a><h4 id="2-2-根据系统负载自适应算法详解"><a href="#2-2-根据系统负载自适应算法详解" class="headerlink" title="2.2 根据系统负载自适应算法详解"></a>2.2 根据系统负载自适应算法详解</h4><p>正如上面的第4步骤，根据系统 Load 的会采用 TCP BBR 算法来评估是否限流，具体实现代码如下：<br>SystemRuleManager#checkSystem<br><img src="https://img-blog.csdnimg.cn/2020052413473576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在 Sentinel 中估算系统的容量是以 1s 为度量长度，用该秒内通过的最大 qps 与 最小响应时间的乘积来表示，具体的计算细节：</p><ul><li>maxSuccessQps 的计算取当前采样窗口的最大值乘以1s内滑动窗口的个数，这里其实并不是十分准确。</li><li>minRt 最小响应时间取自当前采样窗口中的最小响应时间。<br>故得出了上述计算公式，除以1000是因为 minRt 的时间单位是毫秒，统一为秒。从这里可以看出根据系统负载做限流，最终的判断依据是线程数量。</li></ul><h4 id="2-3-JAVA如何获得操作系统负载情况"><a href="#2-3-JAVA如何获得操作系统负载情况" class="headerlink" title="2.3 JAVA如何获得操作系统负载情况"></a>2.3 JAVA如何获得操作系统负载情况</h4><p>在 Sentinel 中获取操作系统负载情况的类是：SystemStatusListener，每秒采集一次。<br>SystemStatusListener#run<br><img src="https://img-blog.csdnimg.cn/20200524134821496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>原来可以通过JDK中的 com.sun.management.OperatingSystemMXBean 获取操作系统相关的信息。<br>温馨提示：上述只对 Linux/Unix 操作系统有效，对 windows 无效。</p><h2 id="3、实践思考"><a href="#3、实践思考" class="headerlink" title="3、实践思考"></a>3、实践思考</h2><p>经过上面的分析，Sentinel 中的系统自适应其实指的是按照应用所在机器的操作系统负载，再结合应用本身的请求处理能力进行的自适应，操作系统的负载情况可以通过 top 命令输出，其示例如下：<br><img src="https://img-blog.csdnimg.cn/20200524134839941.png#pic_center" alt="在这里插入图片描述"><br>尽管 Sentienl 的系统规则配置类型分为 LOAD、CPU、RT、线程数、入口QPS等维度进行限流，但自适应主要是针对 LOAD 这种情况的。<br>Sentinel 系统级别的限流规则并不是针对某一个资源，而是针对应用所有定义EntryType.IN的资源，在使用时尤其需要注意，特别是如果一个机器上部署了多个应用，可能会造成应用本身负载不高，但所在的机器由于其他应用程序导致资源负载偏高，从而触发限流。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;看到标题中的几个关键字&lt;strong&gt;系统自适应&lt;/strong&gt;限流是不是觉得高大上，这个自适应又是如何实现的呢？&lt;/p&gt;
&lt;h2 id=&quot;1、Sentinel-系统自适应概述&quot;&gt;&lt;a href=&quot;#1、Sentinel-系统自适应概述&quot; class=&quot;headerlink&quot; title=&quot;1、Sentinel 系统自适应概述&quot;&gt;&lt;/a&gt;1、Sentinel 系统自适应概述&lt;/h2&gt;&lt;p&gt;从官方了解到 Sentienl 系统自适应限流是一个全局的概念，对应用入口流量统一进行统一控制，结合应用的机器负载、CPU 使用率，总体平均响应时间、入口 QPS 和并发线程数等几个维度的监控指标从而决定是否调用进行限流操作。为了有一个直观的感受，我们可以从官方的运维平台看看其系统自适应限流的操作界面：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020052413411896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;RT、线程数、入口QPS这三个指标是可以通过采集调用信息进行统计计算的，那系统LOAD、CPU使用率是如何获取的呢？大家可以带着这个问题进入本文的学习中来。&lt;/p&gt;
&lt;p&gt;在详细分析系统自适应实现原理之前我们先来思考一下 Sentinel 引入该机制的目的。&lt;/p&gt;
&lt;p&gt;官方文档针对这个问题有过仔细阐述，我们先来看看官方文档对其阐述。&lt;/p&gt;
&lt;p&gt;引入系统自适应限流的主要的目的有如下两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证系统不被拖垮&lt;/li&gt;
&lt;li&gt;在系统稳定的前提下保证系统的吞吐量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前我们接触的限流的防护思路都是设定一个指标（阔值），例如系统的负载 load 超过某个阔值后就阻止或减少流量的继续进入，当系统负载降低到某一水平后则恢复流量的进入。通常都是被动的，其实际效果取决与阔值设置是否合理，但往往设置合理不是一件容易的事情。&lt;/p&gt;
&lt;p&gt;那 Sentinel 提供的系统自适应是可以将设定的规则作为一个保护因子，而允许通过的流量由处理请求的能力来决定，即根据请求的响应时间、当前系统正在处理的请求速率来决定。&lt;/p&gt;
&lt;p&gt;那 Sentinel 是如何实现的呢？接下来用源码的手段来揭晓其实现原理。&lt;/p&gt;
&lt;h2 id=&quot;2、系统自适应限流原理&quot;&gt;&lt;a href=&quot;#2、系统自适应限流原理&quot; class=&quot;headerlink&quot; title=&quot;2、系统自适应限流原理&quot;&gt;&lt;/a&gt;2、系统自适应限流原理&lt;/h2&gt;&lt;p&gt;Sentinel 执行系统限流的核心入口类为 SystemSlot，该类实现简单，如下图所示：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200524134158678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;SystemRuleManager#checkSystem&quot;&gt;&lt;br&gt;从这里可以看出实现的关键在于SystemRuleManager，这里是直接调用 checkSystem 进行是否触发其限流，那我们接下来重点跟踪一下该方法的实现。&lt;/p&gt;
&lt;h4 id=&quot;2-1-自适应限流检测流程&quot;&gt;&lt;a href=&quot;#2-1-自适应限流检测流程&quot; class=&quot;headerlink&quot; title=&quot;2.1 自适应限流检测流程&quot;&gt;&lt;/a&gt;2.1 自适应限流检测流程&lt;/h4&gt;&lt;p&gt;系统自适应限流检测具体由 SystemRuleManager 的 checkSystem 方法实现，接下来详细剖析其实现细节。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020052413421556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;Step1：验证相关资源，主要包含三层验证：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果资源名称为空，则直接跳过，这个是容错机制。&lt;/li&gt;
&lt;li&gt;如果系统自适应开关为打开，直接放行，该开关初始化时为 false，在加载到一条系统自适应配置规则时该状态会设置为 true，具体在 loadSystemConf 中。&lt;/li&gt;
&lt;li&gt;如果资源的类型不是入口流量(EntryType.IN),则直接放行。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200524134428924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;Step2：从QPS为维度验证是否需要被限流，其实现关键点如下：&lt;/li&gt;
&lt;li&gt;当前的qps，如果 ENTRY_NODE 为空则返回0，否则返回该统计节点的成功 qps，那 ENTRY_NODE 统计节点是“何许人也”，原来是 Sentinel 特定定义了一个资源，其名称为__total_inbound_traffic__，用来采集所有入口调用的信息，当资源进入类型为 ENTRY_TYPE_IN 时，会自动采集信息，其具体统计信息在 StatisticSlot 的 entry 方法中被调用，其截图如下：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200524134513299.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/li&gt;
&lt;li&gt;如果当前调用的 QPS 大于设定的QPS，即触发限流，那这个 qps 又是在什么时候被设置的呢？也是在加载系统限流规则时被设置，如果一个应用同一个限流点（LOAD、QPS)设置了多条规则，最小值生效。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200524134545735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;Step3：关于线程数、响应时间限流模式与QPS类似，就不再重复介绍。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200524134621142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;Step4：如果当前系统的负载超过了设定的阔值的处理逻辑，这里就是自适应的核心所在，并不是超过负载就限流，而是需要根据当前系统的请求处理能力进行综合判断，具体逻辑在 checkBbr 方法中实现。关于如何获得系统负载与 checkBbr 方法稍后会详细介绍。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200524134709868.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;Step5：如果当前CPU的负载超过了设置的阔值，触发限流，那在JAVA中是如何获取CPU的使用率的呢？稍后详细介绍。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="sentinel" scheme="http://example.com/categories/sentinel/"/>
    
    
    <category term="sentinel" scheme="http://example.com/tags/sentinel/"/>
    
  </entry>
  
  <entry>
    <title>Sentinel Dubbo 适配器看限流与熔断(实战思考篇)</title>
    <link href="http://example.com/posts/fd3813a.html"/>
    <id>http://example.com/posts/fd3813a.html</id>
    <published>2020-12-08T15:01:35.000Z</published>
    <updated>2020-12-08T15:03:04.020Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文是源码分析 Sentinel 系列的第十三篇，已经非常详细的介绍了 Sentinel 的架构体系、滑动窗口、调用链上下文、限流、熔断的实现原理，相信各位读者朋友们对Sentinel有一个较为体系化的认知了，这个时候是该开始如何在生产环境进行运用了。</p><blockquote><p>本文将以 Dubbo 服务调用为案例剖析场景，尝试对官方提供的 Dubbo 适配器做一个研究学习并对此做出自己的评价，抛出我的观点，期待与大家共同探讨，交流。</p></blockquote><p>一个 Dubbo RPC 的简易调用过程如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200510202405377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>消费者会维护一个服务提供者列表，然后再发一起一个服务调用的时候会首先根据负载均衡算法从中选择一个服务提供者，然后发起 RPC 调用，在请求真实发送之前会依次通过客户端设置的过滤器链(Filter)，然后经过网络传输到到达服务提供者，并执行完服务提供者端的 Filter，最后进入到业务逻辑执行并返回结果。</p><p>Sentinel 与 Dubbo 的整合就是利用了 Dubbo 的 Filter 机制，为 Dubbo 提供对应的 过滤器，无缝实现限流、熔断等功能，做到业务无感知，即业务代码无需使用 Sentinel 相关的 API。</p><p>接下来请大家带着在 Dubbo 中如何使用限流、熔断方面来看官方给出的解决方案。</p><blockquote><p>思考题：在看接下来的内容之前，建议大家稍作停顿，思考一下，在服务调用模型中，限流、熔断通常在哪个端做比较合适。</p></blockquote><h2 id="1、从消费端来看限流与熔断"><a href="#1、从消费端来看限流与熔断" class="headerlink" title="1、从消费端来看限流与熔断"></a>1、从消费端来看限流与熔断</h2><p><img src="https://img-blog.csdnimg.cn/20200510202451273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">从消费端的视角，虽然提供了服务端的负载均衡，但从客户端不管是向192.168.1.3还是向192.168.1.4发送RPC调用，都会经过同一个 Sentinel Dubbo Filter。这个看似简单明了，但这是我们接下来思考的最基本最核心的点。</p><p>我们先来看看官方提供的 Dubbo 适配器的核心实现：<br>SentinelDubboConsumerFilter#invoke<br><img src="https://img-blog.csdnimg.cn/20200510202524603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>消费端这边使用到了两个资源名称，一个是接口级别，例如 com.demo.service.UserService，另外一是方法级别，例如 com.demo.servcie.UserServce#findUser(Ljava.lang.String)。<br>定义了两个资源后，Sentinel 会使用滑动窗口机制，为上述两个资源收集实时的调用信息，为后续的限流、熔断提供数据依据。</p><a id="more"></a><p>限流规则是依附于具体某一个项目的，例如如下图所示：<br><img src="https://img-blog.csdnimg.cn/2020051020261021.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">限流、熔断都是根据资源级别，如果需要对消费端的调用进行限流的话，就需要为这两个资源配置对应的限流规则，如果不配置则默认通过，表示不限流。</p><h4 id="1-1-服务调用端-消费方-是否需要配置限流规则"><a href="#1-1-服务调用端-消费方-是否需要配置限流规则" class="headerlink" title="1.1 服务调用端(消费方)是否需要配置限流规则"></a>1.1 服务调用端(消费方)是否需要配置限流规则</h4><p>在 dubbo 的服务调用场景中，在消费端设置限流的规则的话，这个调用链是针对整个集群所有服务提供者的，例如当前集群中包含3个服务提供者，每个服务提供者用于1000tps的服务能力，那消费端的限流，应该配置的限流TPS应该为3000tps，如果设置为1000tps，则无法完整的利用服务端的能力，基于这样的情况，通常消费端无需配置限流规则。</p><p>那是不是说消费端就没必要配置限流规则呢？其实也不是，有如下这个场景，例如调用第三方外部的计费类服务接口，对方通常为特定的账户等级设置对应的TPS上限，如果超过该调用频率就会抛出错误，这种情况还是需要设置限流规则，确保消费端以不超过要求进行调用，避免业务异常。</p><h4 id="1-2-服务调用端-消费方-是否需要配置熔断"><a href="#1-2-服务调用端-消费方-是否需要配置熔断" class="headerlink" title="1.2 服务调用端(消费方)是否需要配置熔断"></a>1.2 服务调用端(消费方)是否需要配置熔断</h4><p>引入熔断的目的是避免服务端单节点响应慢而导致这个服务不稳定，例如示例中有3个服务提供者，如果192.168.1.3的服务提供者由于触发了BUG导致响应时间大大增加，导致发往该服务提供者的请求大概率超时，在这样的情况下希望在接下来某段时间内消费方发往这这个服务提供者的请求快速熔断降级，返回错误，由客户端重试其他服务提供者。其实现效果如下：<br><img src="https://img-blog.csdnimg.cn/20200510202651125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>当前的 Sentinel 默认是否能满足上述的需求呢？</p><p>我们以 Sentinel 基于异常比例熔断策略来进行阐述，如果资源的调用异常比例超过一定值是会触发降级熔断，抛出 DegradeException 异常。</p><p>由于总共只有三个服务提供者，其中发往192.168.1.3的请求大概率会由于超时失败，则异常比例会超过设置的熔断降级规则，会触发降级，造成的效果是整个服务调用都会发送熔断降级，即调用192.168.1.4,5两个请求都不会被熔断，造成整个服务调用不可用，与期望不一致。即还是会出现一个节点的不稳定而导致整个服务不稳定的情况。</p><p>其造成的根本原因是因为其资源的定义并没有包含服务提供者的信息，改进的初步方案：</p><ol><li>在过滤器中再定义一个资源，加上服务提供的IP与端口号，例如 SphU.entry(“com.d.s.UserService@ip:port”)，对单个服务提供者进行单独收集调用信息，并且需要提供一可配置的项，用来标记该类型的资源在做熔断判断可使用某一个资源的配置，例如配置为 com.d.s.UserService，表示用这个配置规则来判断熔断。</li><li>在熔断规则判断的时候，该资源使用被引用资源的熔断规则进行判断。</li></ol><p>最后来解答一下，熔断规则通常只需要配置在调用方即可。</p><h2 id="2、从服务来看限流与熔断"><a href="#2、从服务来看限流与熔断" class="headerlink" title="2、从服务来看限流与熔断"></a>2、从服务来看限流与熔断</h2><p>由于服务端看限流与熔断就比较简单，因为服务端与客户端存在一个非常大的区别是客户端存在负载均衡机制，一个消费端对于同一资源来说，会调用多个服务提供者，而服务提供者对于一个资源来就是其自身，故限流规则，熔断规则都是针对个体，其复杂度降低。</p><p>为了知识体系的完备性，我们来看一下 Sentinel Dubbo 在服务端的适配器的实现。</p><p>SentinelDubboProviderFilter#invoke<br><img src="https://img-blog.csdnimg.cn/20200510202746713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这里有二个关键点：</p><ol><li>使用了 ContextUtil 的 entry 方法，定义本次调用的上下文环境名称为：resourceName，默认为接口名与方法名、参数列表，例如 com.d.s.UserServce#findUser(Ljava.lang.String),源头为消费端的应用名称。</li><li>定义两个资源，这里与消费端相同，就不做重复解读。</li></ol><p>关于这个 ContextUtil 的 entry 方法非常关键，因为 Sentinel 中数据节点的统计是以 ContextName 为维度的。</p><p>例如想对一个应用所有的操作 redis 操作统一设置为一个资源名，redisOpsResource，即想控制该应用整体的 redis 操作 tps，其场景如下：<br><img src="https://img-blog.csdnimg.cn/20200510202841580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>例如初衷设计为 opsReisTotal 的整个 tps 为 500，例如从UserService#findser链路的访问 redis tps 为 400，而从 Order#createOrder 链路访问 redis tps 为 400，此时 redis 的整体 tps 已经达到了 800 tps，但你会发现并不会触发限流，因为对资源 RredisOpResource 的调用信息统计是以 context name 为维度的，不同的 context name 互不影响，从而无法做到全局控制。</p><h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p>本文结合 Sentinel 官方对于 Dubbo 提供的适配器并加以理解，提出了如下观点，欢迎大家留言探讨，相互交流，共同进步。</p><ol><li>限流规则根据不同的使用场景可以在客户端、服务端配置。</li><li>熔断规则通常在服务调用方配置即可。</li><li>Sentinel 目前的熔断还实现的比较简单，无法解决集群中因为某一个节点的访问慢而触发熔断，并使服务稳定的能力。</li><li>Sentienl 的实时统计是以调用上下文(Context Name)，即 ContextUtil.entry 方法定义的上下文为维度的，这点非常关键，不然容易踩坑。</li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是源码分析 Sentinel 系列的第十三篇，已经非常详细的介绍了 Sentinel 的架构体系、滑动窗口、调用链上下文、限流、熔断的实现原理，相信各位读者朋友们对Sentinel有一个较为体系化的认知了，这个时候是该开始如何在生产环境进行运用了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文将以 Dubbo 服务调用为案例剖析场景，尝试对官方提供的 Dubbo 适配器做一个研究学习并对此做出自己的评价，抛出我的观点，期待与大家共同探讨，交流。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个 Dubbo RPC 的简易调用过程如下图所示：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200510202405377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;消费者会维护一个服务提供者列表，然后再发一起一个服务调用的时候会首先根据负载均衡算法从中选择一个服务提供者，然后发起 RPC 调用，在请求真实发送之前会依次通过客户端设置的过滤器链(Filter)，然后经过网络传输到到达服务提供者，并执行完服务提供者端的 Filter，最后进入到业务逻辑执行并返回结果。&lt;/p&gt;
&lt;p&gt;Sentinel 与 Dubbo 的整合就是利用了 Dubbo 的 Filter 机制，为 Dubbo 提供对应的 过滤器，无缝实现限流、熔断等功能，做到业务无感知，即业务代码无需使用 Sentinel 相关的 API。&lt;/p&gt;
&lt;p&gt;接下来请大家带着在 Dubbo 中如何使用限流、熔断方面来看官方给出的解决方案。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;思考题：在看接下来的内容之前，建议大家稍作停顿，思考一下，在服务调用模型中，限流、熔断通常在哪个端做比较合适。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1、从消费端来看限流与熔断&quot;&gt;&lt;a href=&quot;#1、从消费端来看限流与熔断&quot; class=&quot;headerlink&quot; title=&quot;1、从消费端来看限流与熔断&quot;&gt;&lt;/a&gt;1、从消费端来看限流与熔断&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200510202451273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;从消费端的视角，虽然提供了服务端的负载均衡，但从客户端不管是向192.168.1.3还是向192.168.1.4发送RPC调用，都会经过同一个 Sentinel Dubbo Filter。这个看似简单明了，但这是我们接下来思考的最基本最核心的点。&lt;/p&gt;
&lt;p&gt;我们先来看看官方提供的 Dubbo 适配器的核心实现：&lt;br&gt;SentinelDubboConsumerFilter#invoke&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200510202524603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;消费端这边使用到了两个资源名称，一个是接口级别，例如 com.demo.service.UserService，另外一是方法级别，例如 com.demo.servcie.UserServce#findUser(Ljava.lang.String)。&lt;br&gt;定义了两个资源后，Sentinel 会使用滑动窗口机制，为上述两个资源收集实时的调用信息，为后续的限流、熔断提供数据依据。&lt;/p&gt;</summary>
    
    
    
    <category term="sentinel" scheme="http://example.com/categories/sentinel/"/>
    
    
    <category term="sentinel" scheme="http://example.com/tags/sentinel/"/>
    
  </entry>
  
  <entry>
    <title>Sentinel 集群限流设计原理</title>
    <link href="http://example.com/posts/e01036e8.html"/>
    <id>http://example.com/posts/e01036e8.html</id>
    <published>2020-12-08T15:00:35.000Z</published>
    <updated>2020-12-08T15:00:57.578Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="1、集群限流使用场景"><a href="#1、集群限流使用场景" class="headerlink" title="1、集群限流使用场景"></a>1、集群限流使用场景</h2><p>首先一个服务有三个服务提供者，但这三台集群的硬件配置不一样，如图所示：<br><img src="https://img-blog.csdnimg.cn/20200503232733111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>为了充分利用硬件的资源，诸如 Dubbo 都提供了基于权重的负载均衡机制，例如可以将8C16G的机器设置的权重是4C8G的两倍，这样充分利用硬件资源，假如现在需要引入 Sentinel 的限流机制，例如为一个 Dubbo 服务设置限流规则，这样由于三台集群分担的流量不均匀，会导致无法重复利用高配机器的资源。</p><p>假设经过压测，机器配置为C48G最高能承受的TPS为 1500，而机器配置为8C16G能承受的TPS为2800，那如果采取单机限流，其阔值只能设置为1500，因为如果超过1500，会将4C8G的机器压垮。</p><p>解决这种办法的方式就是针对整个集群进行限流，即为整个集群设置一个阔值，例如设置限流TPS为6000。</p><h2 id="2、集群限流与单机限流的异同思考"><a href="#2、集群限流与单机限流的异同思考" class="headerlink" title="2、集群限流与单机限流的异同思考"></a>2、集群限流与单机限流的异同思考</h2><p>限流的一个基本作用就是按照限流规则生成访问许可(Token)，然后根据当前实时的调用信息进行判断是否可以获得许可而决定是否放行。</p><p>集群与单机限流在实时调用信息收集方面应该差别不大，都可以基于滑动窗口进行统计信息的收集。</p><p>集群与单机限流的最主要区别在与许可的生成，单机模式的许可直接在本地生成，但集群限流必须有一个统一的 Token 发放机制，以此来协调当前集群内多机调用，从而基于当前“调用总数”进行限流。</p><a id="more"></a><ul><li><h2 id="3、探究集群限流实现原理"><a href="#3、探究集群限流实现原理" class="headerlink" title="3、探究集群限流实现原理"></a>3、探究集群限流实现原理</h2><p>在探究集群限流实现原理之前先来回顾一下单机限流的执行流程图。<br><img src="https://img-blog.csdnimg.cn/20200503232832535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>结合流程我们可以看出集群限流的几个关键点 ClusterBuilderSlot、FlowSlot。</p><h4 id="3-1-ClusterBuilderSlot-详解"><a href="#3-1-ClusterBuilderSlot-详解" class="headerlink" title="3.1 ClusterBuilderSlot 详解"></a>3.1 ClusterBuilderSlot 详解</h4><p>在对一个资源进行流控规则判断时，首先将进入到 NodeSelectorSlot，然后就会进入到 ClusterBuilderSlot，为了与单机限流模式，介绍 ClusterBuilderSlot 时与 NodeSelectorSlot 进行一个对比。</p><p>NodeSelectorSlot 的核心实现截图如下所示：<br><img src="https://img-blog.csdnimg.cn/20200503232919521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><blockquote><p>温馨提示：从该系列之前的文章也能得知，一个 资源对应的一个 NodeSelectorSlot  实例，即多线程访问一个资源时，都会调用同一个 NodeSelectorSlot 实例。</p></blockquote><p>NodeSelectorSlot 的关键点如下：</p><ul><li>Map&lt;String, DefaultNode&gt; map<br>在 NodeSelectorSlot 中是以 context Id 为维度进行缓存的，例如官方给出的 Dubbo 适配方法，contexId 为 dubbo 服务的全路径名。即 Dubbo的入口节点对应的缓存 Key 为 context<br>id。</li><li>fireEntry 的 node 参数<br>由于 NodeSelectorSlot 是第一个过滤器，故第一次调用 fireEntry 方法时的 node 参数就是上面创建的 Node，即与 context 相关链的 Node，即所谓的入口节点即 Entrance Node。</li></ul><p>接下来重点关注一下 ClusterBuilderSlot 的关键点：<br><img src="https://img-blog.csdnimg.cn/20200503233012141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>ClusterBuilderSlot 的关键点如下：</p><ul><li>Map&lt;ResourceWrapper, ClusterNode&gt; clusterNodeMap<br>持有的集群节点缓存表，其键为 Entrance Node 所对应的资源ID，即 Context 中关联的节点信息。</li><li>Node originNode<br>所谓的 orginNode，即在调用 ContextUtil 中 enter(String name, String origin) 方法中的第二个参数，表示这条调用链的源头，在 Dubbo 中默认为 应用的 application。</li></ul><p>经过上面两个Slot，整个调用链就基本创建好了，接下来我们来看一下 FlowSlot 关于集群限流的相关处理逻辑。</p><h4 id="3-2-集群限流模式实现原理"><a href="#3-2-集群限流模式实现原理" class="headerlink" title="3.2 集群限流模式实现原理"></a>3.2 集群限流模式实现原理</h4><p><img src="https://img-blog.csdnimg.cn/20200503233045696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>FlowSlow FlowSlot 的核心处理逻辑主要是调用 FlowRuleChecker 的 canPassCheck 方法，正如上面看到的一样，根据配置规则，如果是集群模式，则调用的是其 passClusterCheck 方法，接下来我们将重点探讨该方法。<br><img src="https://img-blog.csdnimg.cn/20200503233111258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="FlowRuleChecker#passClusterCheck"><br>代码@1：获取一个 TokenService 服务类。这里实现关键点：</p><ul><li>如果当前节点的角色为 CLIENT，返回的 TokenService 为 DefaultClusterTokenClient。</li><li>如果当前节点的角色为 SERVER，返回的 TokenService 为 ClusterTokenServer，这里使用了SPI极致，可以通过查看 META-INF/services 目录下的 com.alibaba.csp.sentinel.cluster.TokenService 文件，默认服务端返回 DefaultTokenService。</li></ul><p>代码@2：如果无法获取到集群限流Token服务，如果该限流规则配置了可以退化为单机限流模式，则退化为单机限流。</p><p>代码@3：获取集群限流的流程ID，该 flowId 全局唯一。</p><p>代码@4：通过 TokenService 去申请 token，这里是与单机限流模式最大的差别。</p><p>接下来将分别从 DefaultClusterTokenClient、DefaultTokenService 分别探究集群限流相关的实现原理与细节，更好的指导我们如何使用集群限流功能。</p><h5 id="3-2-1-DefaultClusterTokenClient-详解"><a href="#3-2-1-DefaultClusterTokenClient-详解" class="headerlink" title="3.2.1 DefaultClusterTokenClient 详解"></a>3.2.1 DefaultClusterTokenClient 详解</h5><p>从我们的经验也得知，TokenClient 的主要职责就是发送请求到 TokenService 端，主要是网络相关的细节将不在此篇文章中给出，如果有兴趣，大家可以关注我的 Netty 专栏。</p><p>首先 Sentinel 提供了 SPI 机制，故允许用户自定义 TokenClient 的实现类，官方与 SPI 默认配置的文件如下：<br><img src="https://img-blog.csdnimg.cn/2020050323322512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>关于 TokenClient 主要关注其初始化代码，因为我们需要关注一个非常重要的点：<br>DefaultClusterTokenClient#initNewConnection<br><img src="https://img-blog.csdnimg.cn/20200503233259244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在客户端启动的时候会创建与 TokenServer 之间的链接，即这边需要配置服务端的 IP 与端口号，那如何配置呢？其实配置方式完全由自己去实现对应的解析器，下面根据官方的 Demo 示例如下：<br><img src="https://img-blog.csdnimg.cn/20200503233319545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这里需要说明的其配置项由 ClusterGroupEntity 来定义，其字段的定义如下：</p><ul><li>clientSet<br>客户端 Set 集合。</li><li>ip<br>Token 服务端的 IP。</li><li>machinedId<br>Token 服务端的机器ID。</li><li>port<br>Token 服务端的机器端口。</li></ul><p>其配置示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;&quot;clientSet&quot;:[&quot;112.12.88.66@8729&quot;,&quot;112.12.88.67@8727&quot;],&quot;ip&quot;:&quot;112.12.88.68&quot;,&quot;machineId&quot;:&quot;112.12.88.68@8728&quot;,&quot;port&quot;:11111&#125;]</span><br></pre></td></tr></table></figure><p>Client 端接下来就是向服务端发送请求，与网络相关的不在本文的讨论范围内，接下来将重点探讨服务端是如何发放许可的。</p><h5 id="3-2-2-DefaultTokenService-详解"><a href="#3-2-2-DefaultTokenService-详解" class="headerlink" title="3.2.2 DefaultTokenService 详解"></a>3.2.2 DefaultTokenService 详解</h5><p>Token Server 端收到客户的请求，其处理入口为 FlowRequestProcessor，其处理方法为：processRequest，最终会调用 DefaultTokenService 的 requestToken 方法。<br>DefaultTokenService#requestToken<br><img src="https://img-blog.csdnimg.cn/20200503233418165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>代码@1：根据 ruleId 获取指定的限流规则。</p><p>代码@2：然后调用 ClusterFlowChecker 的 acquierClusterToken 方法，申请许可。</p><p>许可的发放流程主要由 ClusterFlowChecker 的 acquierClusterToken 方法实现。<br><img src="https://img-blog.csdnimg.cn/20200503233520315.png#pic_center" alt="在这里插入图片描述"><br>Step1：首先判断是否允许本次许可申请，这是因为 TokenServe 支持嵌入式，即支持在应用节点中嵌入一个 TokenServer，为了保证许可申请的请求不对正常业务造成比较大的影响，故对申请许可这个动作进行了限流。</p><p>一旦触发了限流，将向客户端返回 TOO_MANY_REQUEST 状态码，Sentinel 支持按 namespace 进行限流，具体由 GlobalRequestLimiter 实现，该类的内部同样基于滑动窗口进行收集，原理与 FlowSlot 相似，故这里不加以展开，默认的限流TPS为3W，有关于 Sentinel 相关的配置，将在后续文章专门梳理。<br><img src="https://img-blog.csdnimg.cn/20200503233607726.png#pic_center" alt="在这里插入图片描述"><br>Step2：根据流程ID获取指标采集器。<br><img src="https://img-blog.csdnimg.cn/20200503233630847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step3：计算 latestQps、globalThreashold、 nextRemaining 三个阔值，三个的含义分别如下：</p><ul><li>latestQps<br>获取当前正常访问的QPS。</li><li>globalThreashold<br>根据限流配置规则得出其总许可数量，其主要根据阔值的方式其有所不同，其配置阔值有两种方式：<br>1）FLOW_THRESHOLD_GLOBAL<br>总数，即集群中的许可等于限流规则中配置的 count 值。<br>2）FLOW_THRESHOLD_AVG_LOCAL<br>单机分摊模式，此时限流规则中配置的值只是单机的 count 值，集群中的许可数等于 count * 集群中客户端的个数。<br>注意：这里还可以通过 exceedCount 设置来运行超过其最大阔值，默认为1表示不允许超过。</li><li>nextRemainging<br>表示处理完本次请求后剩余的许可数量。<br><img src="https://img-blog.csdnimg.cn/20200503233707407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">Step4：如果剩余的许可数大于0，则本次申请成功，将当前的调用计入指标采集器中，然后返回给客户即可。</li></ul><p>接下来所有流程步骤都是基于没有剩余许可数的处理逻辑。<br><img src="https://img-blog.csdnimg.cn/20200503233730680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step5：当前许可数不足的情况，并且该请求为高优先级的处理逻辑：</p><ul><li>获取当前等待的TPS（即1s为维度，当前等待的请求数量）</li><li>如果当前等待的TPS低于可借用未来窗口的许可阔值时，可通过，但设置其等待时间，可以通过 maxOccupyRatio 来设置借用的最大比值。<br><img src="https://img-blog.csdnimg.cn/20200503233758997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">Step6：如果当前许可不足，并且该请求为普通优先级的处理逻辑，增加阻塞相关指标的统计数，并返回 BLOCKED。</li></ul><p>TokenServer 返回申请许可之后，那 Token Client 如何处理呢？其处理代码在 FlowRuleChecker#applyTokenResult<br><img src="https://img-blog.csdnimg.cn/20200503233827875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>我们可以发现，如果服务端返回OK，则顺利通过，返回BLOCKED，则直接返回 false，会抛出 FlowException，如果是 token 限流，如果规则运行退化为单机限流模式，则进行单机限流。</p><p>集群限流的基本实现原理就介绍到这里了。</p><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>集群限流的基本原理接介绍到这里了，与单机限流模式最大的区别就是集群限流模式的需要引入 TokenService，提供许可的发放服务，该服务可以嵌入应用节点，也可以独立于应用之外。这边借用官方文档上的两张图来简单介绍一下嵌入模式与独立模式的架构：<br><img src="https://img-blog.csdnimg.cn/20200503233858200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200503233858165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>集群模式使用注意，如果使用的是集群模式限流，则如下两个配置则失效：<br><img src="https://img-blog.csdnimg.cn/20200503233920874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>最后抛出一个思考题：集群模式应该算是高大上，但我们项目中真的需要吗？集群限流模式有哪些缺点、哪些优点，欢迎大家留言探讨。</strong></p></li></ul></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1、集群限流使用场景&quot;&gt;&lt;a href=&quot;#1、集群限流使用场景&quot; class=&quot;headerlink&quot; title=&quot;1、集群限流使用场景&quot;&gt;&lt;/a&gt;1、集群限流使用场景&lt;/h2&gt;&lt;p&gt;首先一个服务有三个服务提供者，但这三台集群的硬件配置不一样，如图所示：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200503232733111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;为了充分利用硬件的资源，诸如 Dubbo 都提供了基于权重的负载均衡机制，例如可以将8C16G的机器设置的权重是4C8G的两倍，这样充分利用硬件资源，假如现在需要引入 Sentinel 的限流机制，例如为一个 Dubbo 服务设置限流规则，这样由于三台集群分担的流量不均匀，会导致无法重复利用高配机器的资源。&lt;/p&gt;
&lt;p&gt;假设经过压测，机器配置为C48G最高能承受的TPS为 1500，而机器配置为8C16G能承受的TPS为2800，那如果采取单机限流，其阔值只能设置为1500，因为如果超过1500，会将4C8G的机器压垮。&lt;/p&gt;
&lt;p&gt;解决这种办法的方式就是针对整个集群进行限流，即为整个集群设置一个阔值，例如设置限流TPS为6000。&lt;/p&gt;
&lt;h2 id=&quot;2、集群限流与单机限流的异同思考&quot;&gt;&lt;a href=&quot;#2、集群限流与单机限流的异同思考&quot; class=&quot;headerlink&quot; title=&quot;2、集群限流与单机限流的异同思考&quot;&gt;&lt;/a&gt;2、集群限流与单机限流的异同思考&lt;/h2&gt;&lt;p&gt;限流的一个基本作用就是按照限流规则生成访问许可(Token)，然后根据当前实时的调用信息进行判断是否可以获得许可而决定是否放行。&lt;/p&gt;
&lt;p&gt;集群与单机限流在实时调用信息收集方面应该差别不大，都可以基于滑动窗口进行统计信息的收集。&lt;/p&gt;
&lt;p&gt;集群与单机限流的最主要区别在与许可的生成，单机模式的许可直接在本地生成，但集群限流必须有一个统一的 Token 发放机制，以此来协调当前集群内多机调用，从而基于当前“调用总数”进行限流。&lt;/p&gt;</summary>
    
    
    
    <category term="sentinel" scheme="http://example.com/categories/sentinel/"/>
    
    
    <category term="sentinel" scheme="http://example.com/tags/sentinel/"/>
    
  </entry>
  
  <entry>
    <title>Sentienl 动态数据源架构设计理念与改造实践</title>
    <link href="http://example.com/posts/2a5ec050.html"/>
    <id>http://example.com/posts/2a5ec050.html</id>
    <published>2020-12-08T14:59:35.000Z</published>
    <updated>2020-12-08T14:59:23.667Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>在介绍集群限流之前需要首先掌握动态数据源的配置方式，本文将根据 Sentinel 官方提供的代码提出整体架构思路，并最终给出实践指导。</p><blockquote><p>温馨提示：本文主要分为动态数据源架构设计理念、从官方示例寻找改造思路、基于SpringBoot改造方案三个部分来详细剖析 Sentienl 动态数据源的改造方案，循序渐进，不仅解决问题本身，更是反映了作者研究一个问题的思路与方法。</p></blockquote><h2 id="1、架构设计理念"><a href="#1、架构设计理念" class="headerlink" title="1、架构设计理念"></a>1、架构设计理念</h2><p>在 Sentinel 中主要有如下几个角色：管理后台、限流熔断规则数据源、应用程序。</p><p>1）管理后台</p><p>管理后台主要用于可视化配置限流规则、熔断规则，其操作界面截图如下：<br><img src="https://img-blog.csdnimg.cn/20200425210307130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>2）限流熔断规则数据源</p><p>用于存储限流熔断规则的数据容器，在 Sentinel 中对应动态数据源这个概念，动态数据源包含两层含义：</p><ul><li>数据容器<br>数据容器指的就是存储熔断、限流等规则配置的数据库，例如关系型数据库、Zookeeper等等，在实际生产过程中需要选用支持持久化功能的数据库，否则程序一重启，配置规则就会丢失，显然是不能接受的。</li><li>动态<br>动态二字主要强调的是配置规则的更改能动态及时生效，引入 Sentinel 限流 SDK 的应用程序在不需要重启的情况下动态感知配置规则发生变化并立即生效。Sentinel 目前对 apollo、consul、etcd、nacos、redis、spring-clould-config、zookeeper 等进行了适配支持。</li></ul><p>3）应用程序</p><p>希望通过 Sentinel 提供的限流、熔断功能对应用程序加以保护，需要引用 Sentinel 相关的 SDK，根据采集的调用信息判断当前是否符合限流规则。</p><p>后台管理系统、动态数据源、应用程序的关系如图所示：<br><img src="https://img-blog.csdnimg.cn/20200425210401161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="2、从官方示例寻找改造思路"><a href="#2、从官方示例寻找改造思路" class="headerlink" title="2、从官方示例寻找改造思路"></a>2、从官方示例寻找改造思路</h2><p>从官方的文档中可以明确获悉 sentinel-dashboard 即官方自带的后台管理系统只支持将限流、熔断等限流配置规则存储在内存中，一旦后台管理系统重启，配置的熔断规则将全部丢失，所以在生产实践过程中需要对 sentinel-dashboard 进行一定的改造，引入动态数据源，例如 Zookeeper，对限流等配置进行持久化存储。</p><p>有了上面的架构设计理念为我们的改造提供了方向，那如何具体改造呢？首先我们来看一下官方提供的 Demo 程序。官方提供的示例代码如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200425210450996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>接下来我们将以 zookeeper 动态数据源来介绍基于 zookeeper 如何构建 Sentinel 动态数据源。</p><a id="more"></a><h4 id="2-1-限流熔断等规则存储"><a href="#2-1-限流熔断等规则存储" class="headerlink" title="2.1 限流熔断等规则存储"></a>2.1 限流熔断等规则存储</h4><p>首先查阅一下 ZookeeperConfigSender，该类主要的作用是将配置写入到 zookeeper 中，其关键代码截图如下：<br><img src="https://img-blog.csdnimg.cn/20200425210528331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这个类的测试目的很简单，先将限流规则持久化到 Zookeeper 中，充当的角色与 sentinel-dashboard 的角色一致，故这个类为我们改造后台管理系统带来很大的启发，即可以通过 zookeeper 存储 sentinel 限流规则，从 demo 示例可以看出限流规则在 zookeeper 中的目录结构，路径为 /{groupId} / {dataid} ，该节点的 value 值存储 json 字符串，存储所有的限流规则。</p><p><strong>实践指导,通常基于 zookeeper 的开发，主要是规划好目录结构，关于 Sentinel，我对给出一个初步的目录规划。</strong></p><p>在 zookeeper 中创建一个根节点，例如 /sentienl 用来表示限流相关的根目录。</p><ul><li>groupId 通常为一个独立的应用名称，例如应用的 appId，例如示例中的 provider-demo。</li><li>dataId 通常为配置类型，例如限流规则、熔断规则、热点规则等类别，例如限流规则使用 /flowRule ，熔断规则使用 /degradeRule，其 value 值使用 json 存储，将该应用下的所有限流规则用一个 json 对象表示，其存储格式类似于 [{},{}]。</li></ul><h4 id="2-2-客户端动态感知配置"><a href="#2-2-客户端动态感知配置" class="headerlink" title="2.2 客户端动态感知配置"></a>2.2 客户端动态感知配置</h4><p>实现存储规则的配置存储后接下来是需要客户端能动态感知规则的变化，从而是配置规则实时生效。</p><p>我们依然先来看一下官方示例，其核心代码如图所示：<br><img src="https://img-blog.csdnimg.cn/2020042521083764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">这里尽管引入 groupId 与 dataId 的概念是方便与 nacos 进行切换，但就算不切换，基于 zookeeper 的编程，这种目录规划是非常有必要的。上面的示例代码有两个关键点：</p><ul><li>创建 ZookeeperDataSource，每一个 ZookeeperDataSource 负责监听一个节点。</li><li>需要调用 FlowRuleManager 的 register2Property 方法将数据源关联的数据注册到 FlowRuleManager 中，方便 Sentinel 内核根据数据源中存储的限流熔断等规则进行工作。</li></ul><p>客户端在启动的时候会调用 FlowRuleManager 相关方法加载限流相关的配置，那如果配置规则发生变化后，客户端如何动态感知呢？其关键就在于 ZookeeperDataSource 的实现中，其实现关键点如下：<br><img src="https://img-blog.csdnimg.cn/2020042521094273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">即在构建 ZookeeperDataSource 时会监听 /groupId/dataId 节点，即存放限流配置的节点，一旦数据发生变化，就会通知到客户端，从而调用 loadConfig 重新更新 Sentienl 客户端的限流配置，从而实现配置实时生效。</p><h2 id="3、Sentinel-引入Zookeeper-动态数据源实现方案"><a href="#3、Sentinel-引入Zookeeper-动态数据源实现方案" class="headerlink" title="3、Sentinel 引入Zookeeper 动态数据源实现方案"></a>3、Sentinel 引入Zookeeper 动态数据源实现方案</h2><p>从官方的示例中我们不难发现，引入 Zookeeper 数据源主要有两个步骤：将数据存储在Zookeeper中以及在客户端监听ZK从而实时生效两个步骤。</p><p>sentinel 官方提供了默认的后台管理系统实现：sentinel-dashboard，但其缺点非常明显：基于内存存储，无法用于实际生产过程。大家可能会向后台管理系统将配置信息存储在内存中，那接入的客户端如何从 sentinel-dashboard 的内存中获取配置信息呢，这是因为 sentinel-dashboard 里提供了简单的机器发现，并且内置了 sentinel 客户端之间、sentinel 客户端与 sentinel-dashboard 之间的通讯协议，具体由 sentinel-transport 模块实现，目前提供了基于 http 与 netty 的实现方式，故能将 sentinel-dashboard 内存中的配置信息推送到客户端，从而使客户端根据配置进行限流与熔断。</p><p>接下来回答本文的重点部分，基于 sentinel-dashboard 如何引入 zookeeper 等动态数据源呢？</p><h4 id="3-1-将配置规则存储在Zookeeper中"><a href="#3-1-将配置规则存储在Zookeeper中" class="headerlink" title="3.1 将配置规则存储在Zookeeper中"></a>3.1 将配置规则存储在Zookeeper中</h4><p>首先我们可以顺着 sentinel-dashboard 的提供的控制器，寻找其后台入口，改造目标也很明确，就是将数据持久化到 zookeeper中，例如增加流控规则的后台处理入口为：<br><img src="https://img-blog.csdnimg.cn/20200425211030452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">Sentinel 动态数据源架构设计理念与改造实践<br>只需要从这里开始改造，将其配置持久化到数据库中和 zookeeper中即可。</p><p>将数据存储在 zookeeper 中，其关键是设计好各个项目如何有组织有条理的在 zookeeper 中进行组织。我给出如下设计方案：<br><img src="https://img-blog.csdnimg.cn/20200425211059470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">这样相关管理人员可以直接在 sentinel-dashboard 中配置限流规则，即按照应用为维度进行存储，每一个应用再按照维度，例如限流、熔断、热点、集群等维度进行配置，每一分类节点的值存储的是所有的配置，使用 [{},{}] 这种JSON格式进行存储。</p><h4 id="3-2-Sentinel-客户端规则加载封装"><a href="#3-2-Sentinel-客户端规则加载封装" class="headerlink" title="3.2 Sentinel 客户端规则加载封装"></a>3.2 Sentinel 客户端规则加载封装</h4><p>目前大部分项目都是基于 SpringBoot，故本文给出基于 SpringBoot 进行的客户端加载实现思路。</p><p>Sentinel 动态数据源架构设计理念与改造实践<br>客户端改造伪代码<br><img src="https://img-blog.csdnimg.cn/202004252111428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">其主要关键点如下：</p><ul><li>基于 Spring ApplicationReadyEvent 事件，实现限流规则的加载。</li><li>创建 ZookeeperDataSource 创建动态数据源。<br>并调用 Sentinel 提供的相关 API 完成限流规则的加载。</li></ul></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在介绍集群限流之前需要首先掌握动态数据源的配置方式，本文将根据 Sentinel 官方提供的代码提出整体架构思路，并最终给出实践指导。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;温馨提示：本文主要分为动态数据源架构设计理念、从官方示例寻找改造思路、基于SpringBoot改造方案三个部分来详细剖析 Sentienl 动态数据源的改造方案，循序渐进，不仅解决问题本身，更是反映了作者研究一个问题的思路与方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1、架构设计理念&quot;&gt;&lt;a href=&quot;#1、架构设计理念&quot; class=&quot;headerlink&quot; title=&quot;1、架构设计理念&quot;&gt;&lt;/a&gt;1、架构设计理念&lt;/h2&gt;&lt;p&gt;在 Sentinel 中主要有如下几个角色：管理后台、限流熔断规则数据源、应用程序。&lt;/p&gt;
&lt;p&gt;1）管理后台&lt;/p&gt;
&lt;p&gt;管理后台主要用于可视化配置限流规则、熔断规则，其操作界面截图如下：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200425210307130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;2）限流熔断规则数据源&lt;/p&gt;
&lt;p&gt;用于存储限流熔断规则的数据容器，在 Sentinel 中对应动态数据源这个概念，动态数据源包含两层含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据容器&lt;br&gt;数据容器指的就是存储熔断、限流等规则配置的数据库，例如关系型数据库、Zookeeper等等，在实际生产过程中需要选用支持持久化功能的数据库，否则程序一重启，配置规则就会丢失，显然是不能接受的。&lt;/li&gt;
&lt;li&gt;动态&lt;br&gt;动态二字主要强调的是配置规则的更改能动态及时生效，引入 Sentinel 限流 SDK 的应用程序在不需要重启的情况下动态感知配置规则发生变化并立即生效。Sentinel 目前对 apollo、consul、etcd、nacos、redis、spring-clould-config、zookeeper 等进行了适配支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3）应用程序&lt;/p&gt;
&lt;p&gt;希望通过 Sentinel 提供的限流、熔断功能对应用程序加以保护，需要引用 Sentinel 相关的 SDK，根据采集的调用信息判断当前是否符合限流规则。&lt;/p&gt;
&lt;p&gt;后台管理系统、动态数据源、应用程序的关系如图所示：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200425210401161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2、从官方示例寻找改造思路&quot;&gt;&lt;a href=&quot;#2、从官方示例寻找改造思路&quot; class=&quot;headerlink&quot; title=&quot;2、从官方示例寻找改造思路&quot;&gt;&lt;/a&gt;2、从官方示例寻找改造思路&lt;/h2&gt;&lt;p&gt;从官方的文档中可以明确获悉 sentinel-dashboard 即官方自带的后台管理系统只支持将限流、熔断等限流配置规则存储在内存中，一旦后台管理系统重启，配置的熔断规则将全部丢失，所以在生产实践过程中需要对 sentinel-dashboard 进行一定的改造，引入动态数据源，例如 Zookeeper，对限流等配置进行持久化存储。&lt;/p&gt;
&lt;p&gt;有了上面的架构设计理念为我们的改造提供了方向，那如何具体改造呢？首先我们来看一下官方提供的 Demo 程序。官方提供的示例代码如下图所示：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200425210450996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;接下来我们将以 zookeeper 动态数据源来介绍基于 zookeeper 如何构建 Sentinel 动态数据源。&lt;/p&gt;</summary>
    
    
    
    <category term="sentinel" scheme="http://example.com/categories/sentinel/"/>
    
    
    <category term="sentinel" scheme="http://example.com/tags/sentinel/"/>
    
  </entry>
  
</feed>
