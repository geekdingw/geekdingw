<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>中间件兴趣圈</title>
  
  <subtitle>关注微信公众号「中间件兴趣圈」，第一时间获取最新干货！</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-12-12T01:14:04.544Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>中间件兴趣圈</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>全链路压测必备基础组件之线程上下文管理之“三剑客”</title>
    <link href="http://example.com/posts/497923c7.html"/>
    <id>http://example.com/posts/497923c7.html</id>
    <published>2020-12-11T15:19:01.000Z</published>
    <updated>2020-12-12T01:14:04.544Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>说起本地线程变量，我相信大家首先会想到的是JDK默认提供的ThreadLocal，用来存储在整个调用链中都需要访问的数据，并且是线程安全的。由于本文的写作背景是笔者需要在公司落地全链路压测平台，一个基本并核心的功能需求是压测标记需要在整个调用链中进行传递，线程上下文环境成为解决这个问题最合适的技术。</p><blockquote><p>温馨提示：<br>本从从ThreadLocal原理入手分析，并抛出其缺点，再逐一引出InheritableThreadLocal、TransmittableThreadLocal。文章篇幅稍长，但由于循序渐进，层层递进，故精华部分在后面。</p></blockquote><h2 id="1、ThreadLocal详解"><a href="#1、ThreadLocal详解" class="headerlink" title="1、ThreadLocal详解"></a>1、ThreadLocal详解</h2><p>ThreadLocal对外提供;的API如下：</p><ul><li>public T get(）<br>从线程上下文环境中获取设置的值。</li><li>public void set(T value)<br>将值存储到线程上下文环境中，供后续使用。</li><li>public void remove()<br>清除线程本地上下文环境。</li></ul><p>上述API使用简单，关键是要理解ThreadLocal的内部存储结果。</p><h3 id="1-1-ThreadLocal存储结构"><a href="#1-1-ThreadLocal存储结构" class="headerlink" title="1.1 ThreadLocal存储结构"></a>1.1 ThreadLocal存储结构</h3><p><img src="https://img-blog.csdnimg.cn/20190720224949903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上图的几个关键点如下：</p><ul><li>数据存储位置<br>当线程调用threadLocal对象的set(Object value)方法时，数据并不是存储在ThreadLocal对象中，而是存储在Thread对象中，这也是ThreadLocal的由来，具体存储在线程对象的threadLocals属性中，其类型为ThreadLocal.ThreadLocalMap。</li><li>ThreadLocal.ThreadLocalMap，Map结构，即键值对，键为threadLocal对象，值为需要存储到线程上下文的值(threadLocal#set)方法的参数。</li></ul><a id="more"></a><h3 id="1-2-源码分析ThreadLocal"><a href="#1-2-源码分析ThreadLocal" class="headerlink" title="1.2 源码分析ThreadLocal"></a>1.2 源码分析ThreadLocal</h3><h4 id="1-2-1-源码分析get"><a href="#1-2-1-源码分析get" class="headerlink" title="1.2.1 源码分析get"></a>1.2.1 源码分析get</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();  <span class="comment">// @1</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);  <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;                                <span class="comment">// @3</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();  <span class="comment">// @4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：获取当前线程。</p><p>代码@2：获取线程的threadLocals属性，在上图中已展示其存储结构。</p><p>代码@3：如果线程对象的threadLocals属性不为空，则从该Map结构中，用threadLocal对象为键去查找值，如果能找到，则返回其value值，否则执行代码@4。</p><p>代码@4：如果线程对象的threadLocals属性为空，或未从threadLocals中找到对应的键值对，则调用该方法执行初始化。</p><p>ThreadLocal#setInitialValue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();    <span class="comment">// @1</span></span><br><span class="line">    Thread t = Thread.currentThread();    <span class="comment">// @2</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);    <span class="comment">// @3</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)                                     <span class="comment">//@4</span></span><br><span class="line">       map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       createMap(t, value);                        <span class="comment">// @5</span></span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：调用initialValue()获取默认初始化值，该方法默认返回null，子类可以重写，实现线程本地变量的初始化。</p><p>代码@2：获取当前线程。</p><p>代码@3：获取该线程对象的threadLocals属性。</p><p>代码@4：如果不为空，则将threadLocal:value存入线程对象的threadLocals属性中。</p><p>代码@5：否则初始化线程对象的threadLocals,然后将threadLocal:value键值对存入线程对象的threadLocals属性中。</p><h4 id="1-2-2-源码分析set"><a href="#1-2-2-源码分析set" class="headerlink" title="1.2.2 源码分析set"></a>1.2.2 源码分析set</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在掌握了get方法实现细节，set方法、remove其实现的逻辑基本一样，就是对线程对象的threadLocals属性进行操作(Map结构)。</p><h3 id="1-3-ThreadLocal局限性"><a href="#1-3-ThreadLocal局限性" class="headerlink" title="1.3 ThreadLocal局限性"></a>1.3 ThreadLocal局限性</h3><p>经过上面的剖析，对ThreadLocal的内部存储与set、get、remove等实现细节都已理解，但ThreadLocal无法在父子线程之间传递，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; requestIdThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer reqId = <span class="keyword">new</span> Integer(<span class="number">5</span>);</span><br><span class="line">        Service a = <span class="keyword">new</span> Service();</span><br><span class="line">        a.setRequestId(reqId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequestId</span><span class="params">(Integer requestId)</span> </span>&#123;</span><br><span class="line">        requestIdThreadLocal.set(requestId);</span><br><span class="line">        doBussiness();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBussiness</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;首先打印requestId:&quot;</span> + requestIdThreadLocal.get());</span><br><span class="line">        (<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程启动&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;在子线程中访问requestId:&quot;</span> + requestIdThreadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><img src="https://img-blog.csdnimg.cn/20190720225215561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从结果上来看，在子线程中无法访问在父线程中设置的本地线程变量，那我们该如何来解决该问题呢？</p><p>为了解决该问题，JDK引入了另外一个线程本地变量实现类InheritableThreadLocal，接下来将重点介绍InheritableThreadLocal的实现原理。</p><h2 id="2、InheritableThreadLocal"><a href="#2、InheritableThreadLocal" class="headerlink" title="2、InheritableThreadLocal"></a>2、InheritableThreadLocal</h2><p>由于ThreadLocal在父子线程交互中子线程无法访问到存储在父线程中的值，无法满足某些场景的需求，例如链路跟踪，例如如下场景：<br><img src="https://img-blog.csdnimg.cn/20190720225255699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为了解决上述问题，JDK引入了InheritableThreadLocal，即子线程可以访问父线程中的线程本地变量，更严谨的说法是子线程可以访问在创建子线程时父线程当时的本地线程变量，因为其实现原理就是在创建子线程将父线程当前存在的本地线程变量拷贝到子线程的本地线程变量中。</p><h3 id="2-1-类图"><a href="#2-1-类图" class="headerlink" title="2.1 类图"></a>2.1 类图</h3><p><img src="https://img-blog.csdnimg.cn/20190720225324764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从类的继承层次来看，InheritableThreadLocal只是在ThreadLocal的get、set、remove流程中，重写了getMap、createMap方法，整体流程与ThreadLocal保持一致，故我们初步来看一下InheritableThreadLocal是如何重写上述这两个方法的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码得知，ThreadLocal操作的是Thread对象的threadLocals属性，而InheritableThreadLocal操作的是Thread对象的inheritableThreadLocals属性。</p><blockquote><p>温馨提示：createMap被执行的条件是调用InheritableThreadLocal#get、set时如果线程的inheritableThreadLocals属性为空时才会被调用。</p></blockquote><p>那问题来了，InheritableThreadLocal是如何继承自父对象的线程本地变量的呢？</p><h3 id="2-2-线程上下文环境如何从父线程传递到子线程"><a href="#2-2-线程上下文环境如何从父线程传递到子线程" class="headerlink" title="2.2 线程上下文环境如何从父线程传递到子线程"></a>2.2 线程上下文环境如何从父线程传递到子线程</h3><p>这部分的代码入口为：Thread#init方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread parent = currentThread();                <span class="comment">// @1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)    <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line"><span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line"><span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set thread ID */</span></span><br><span class="line">tid = nextThreadID();</span><br></pre></td></tr></table></figure><p>子线程是通过在父线程中通过调用new Thread()方法来创建子线程，Thread#init方法就是在Thread的构造方法中被调用。</p><p>代码@1：获取当前线程对象，即待创建的线程的父线程。</p><p>代码@2：如果父线程的inheritableThreadLocals不为空并且inheritThreadLocals为true(该值默认为true)，则使用父线程的inherit本地变量的值来创建子线程的inheritableThreadLocals结构，即将父线程中的本地变量复制到子线程中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    Entry[] parentTable = parentMap.table;</span><br><span class="line">    <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">    setThreshold(len);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = parentTable[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object value = key.childValue(e.value);</span><br><span class="line">                Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                </span><br><span class="line">table[h] = c;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码就不一一分析，类似于Map的复制，只不过其在Hash冲突时，不是使用链表结构，而是直接在数组中找下一个为null的槽位。</p><blockquote><p>温馨提示：子线程默认拷贝父线程的方式是浅拷贝，如果需要使用深拷贝，需要使用自定义ThreadLocal，继承InheritableThreadLocal并重写childValue方法。</p></blockquote><h3 id="2-3-验证InheritableThreadLocal的特性"><a href="#2-3-验证InheritableThreadLocal的特性" class="headerlink" title="2.3 验证InheritableThreadLocal的特性"></a>2.3 验证InheritableThreadLocal的特性</h3><p>验证代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InheritableThreadLocal&lt;Integer&gt; requestIdThreadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer reqId = <span class="keyword">new</span> Integer(<span class="number">5</span>);</span><br><span class="line">        Service a = <span class="keyword">new</span> Service();</span><br><span class="line">        a.setRequestId(reqId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequestId</span><span class="params">(Integer requestId)</span> </span>&#123;</span><br><span class="line">        requestIdThreadLocal.set(requestId);</span><br><span class="line">        doBussiness();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBussiness</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;首先打印requestId:&quot;</span> + requestIdThreadLocal.get());</span><br><span class="line">        (<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程启动&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;在子线程中访问requestId:&quot;</span> + requestIdThreadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：<br><img src="https://img-blog.csdnimg.cn/20190720225632413.png" alt="在这里插入图片描述"><br>符合预期，在子线程中如愿访问到了在主线程中设置的本地环境变量。</p><h3 id="2-4-InheritableThreadLocal局限性"><a href="#2-4-InheritableThreadLocal局限性" class="headerlink" title="2.4 InheritableThreadLocal局限性"></a>2.4 InheritableThreadLocal局限性</h3><p>InheritableThreadLocal支持子线程访问在父线程的核心思想是在创建线程的时候将父线程中的本地变量值复制到子线程，即复制的时机为创建子线程时。但我们提到并发、多线程就理不开线程池的使用，因为线程池能够复用线程，减少线程的频繁创建与销毁，如果使用InheritableThreadLocal，那么线程池中的线程拷贝的数据来自于第一个提交任务的外部线程，即后面的外部线程向线程池中提交任务时，子线程访问的本地变量都来源于第一个外部线程，造成线程本地变量混乱，验证代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟tomcat线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService tomcatExecutors = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务线程池，默认Control中异步任务执行线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService businessExecutors = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程上下文环境，模拟在Control这一层，设置环境变量，然后在这里提交一个异步任务，模拟在子线程中，是否可以访问到刚设置的环境变量值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InheritableThreadLocal&lt;Integer&gt; requestIdThreadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ ) &#123;  <span class="comment">// 模式10个请求，每个请求执行ControlThread的逻辑，其具体实现就是，先输出父线程的名称，</span></span><br><span class="line">                                                  <span class="comment">//  然后设置本地环境变量，并将父线程名称传入到子线程中，在子线程中尝试获取在父线程中的设置的环境变量</span></span><br><span class="line">            tomcatExecutors.submit(<span class="keyword">new</span> ControlThread(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//简单粗暴的关闭线程池</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        businessExecutors.shutdown();</span><br><span class="line">        tomcatExecutors.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟Control任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ControlThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ControlThread</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                requestIdThreadLocal.set(i);</span><br><span class="line">                <span class="comment">//使用线程池异步处理任务</span></span><br><span class="line">                businessExecutors.submit(<span class="keyword">new</span> BusinessTask(Thread.currentThread().getName()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务任务，主要是模拟在Control控制层，提交任务到线程池执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String parentThreadName;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BusinessTask</span><span class="params">(String parentThreadName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.parentThreadName = parentThreadName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//如果与上面的能对应上来，则说明正确，否则失败</span></span><br><span class="line">            System.out.println(<span class="string">&quot;parentThreadName:&quot;</span> + parentThreadName + <span class="string">&quot;:&quot;</span> + requestIdThreadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行效果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1:0</span><br><span class="line">pool-1-thread-2:1</span><br><span class="line">pool-1-thread-3:2</span><br><span class="line">pool-1-thread-4:3</span><br><span class="line">pool-1-thread-5:4</span><br><span class="line">pool-1-thread-6:5</span><br><span class="line">pool-1-thread-7:6</span><br><span class="line">pool-1-thread-8:7</span><br><span class="line">pool-1-thread-9:8</span><br><span class="line">pool-1-thread-10:9</span><br><span class="line">parentThreadName:pool-1-thread-7:6</span><br><span class="line">parentThreadName:pool-1-thread-4:6</span><br><span class="line">parentThreadName:pool-1-thread-3:6</span><br><span class="line">parentThreadName:pool-1-thread-2:6</span><br><span class="line">parentThreadName:pool-1-thread-1:6</span><br><span class="line">parentThreadName:pool-1-thread-9:6</span><br><span class="line">parentThreadName:pool-1-thread-10:6</span><br><span class="line">parentThreadName:pool-1-thread-8:7</span><br><span class="line">parentThreadName:pool-1-thread-6:5</span><br><span class="line">parentThreadName:pool-1-thread-5:4</span><br></pre></td></tr></table></figure><p>从这里可以出thread-7、thread-4、thread-3、thread-2、thread-1、thread-9、thread-10获取的都是6，在子线程中出现出现了线程本地变量混乱的现象，在全链路跟踪与压测出现这种情况是致命的。</p><p>问题：大家通过上面的学习，应该能解释这个现象？此处可以稍微停下来思考一番。</p><p>怎么解决这个问题呢？</p><p>TransmittableThreadLocal ”闪亮登场“。</p><h2 id="3、TransmittableThreadLocal"><a href="#3、TransmittableThreadLocal" class="headerlink" title="3、TransmittableThreadLocal"></a>3、TransmittableThreadLocal</h2><h3 id="3-1-TransmittableThreadLocal“何许人也”"><a href="#3-1-TransmittableThreadLocal“何许人也”" class="headerlink" title="3.1 TransmittableThreadLocal“何许人也”"></a>3.1 TransmittableThreadLocal“何许人也”</h3><p>TransmittableThreadLocal何许人也，它可是阿里巴巴开源的专门解决InheritableThreadLocal的局限性，实现线程本地变量在线程池的执行过程中，能正常的访问父线程设置的线程变量。实践是检验整理的唯一标准，我们还是以上面的示例来进行验证，看看TransmittableThreadLocal是否支持上述场景：</p><p>首先需要在pom.xml文件中引入如下maven依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>transmittable-thread-local<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟tomcat线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService tomcatExecutors = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务线程池，默认Control中异步任务执行线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService businessExecutors = TtlExecutors.getTtlExecutorService(Executors.newFixedThreadPool(<span class="number">4</span>)); <span class="comment">// 使用ttl线程池，该框架的使用，请查阅官方文档。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程上下文环境，模拟在Control这一层，设置环境变量，然后在这里提交一个异步任务，模拟在子线程中，是否可以访问到刚设置的环境变量值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> TransmittableThreadLocal&lt;Integer&gt; requestIdThreadLocal = <span class="keyword">new</span> TransmittableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private static InheritableThreadLocal&lt;Integer&gt; requestIdThreadLocal = new InheritableThreadLocal&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ ) &#123;</span><br><span class="line">            tomcatExecutors.submit(<span class="keyword">new</span> ControlThread(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//简单粗暴的关闭线程池</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        businessExecutors.shutdown();</span><br><span class="line">        tomcatExecutors.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟Control任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ControlThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ControlThread</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            requestIdThreadLocal.set(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用线程池异步处理任务</span></span><br><span class="line"></span><br><span class="line">            businessExecutors.submit(<span class="keyword">new</span> BusinessTask(Thread.currentThread().getName()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务任务，主要是模拟在Control控制层，提交任务到线程池执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String parentThreadName;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BusinessTask</span><span class="params">(String parentThreadName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.parentThreadName = parentThreadName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//如果与上面的能对应上来，则说明正确，否则失败</span></span><br><span class="line">            System.out.println(<span class="string">&quot;parentThreadName:&quot;</span> + parentThreadName + <span class="string">&quot;:&quot;</span> + requestIdThreadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> pool-1-thread-10:9</span><br><span class="line"> pool-1-thread-8:7</span><br><span class="line"> pool-1-thread-7:6</span><br><span class="line"> pool-1-thread-9:8</span><br><span class="line"> pool-1-thread-6:5</span><br><span class="line"> pool-1-thread-5:4</span><br><span class="line"> pool-1-thread-4:3</span><br><span class="line"> pool-1-thread-3:2</span><br><span class="line"> pool-1-thread-2:1</span><br><span class="line">pool-1-thread-1:0</span><br><span class="line">parentThreadName:pool-1-thread-5:4</span><br><span class="line">parentThreadName:pool-1-thread-9:4</span><br><span class="line">parentThreadName:pool-1-thread-3:4</span><br><span class="line">parentThreadName:pool-1-thread-2:4</span><br><span class="line">parentThreadName:pool-1-thread-7:4</span><br><span class="line">parentThreadName:pool-1-thread-8:4</span><br><span class="line">parentThreadName:pool-1-thread-1:4</span><br><span class="line">parentThreadName:pool-1-thread-6:5</span><br><span class="line">parentThreadName:pool-1-thread-10:9</span><br><span class="line">parentThreadName:pool-1-thread-4:3</span><br></pre></td></tr></table></figure><p>执行结果符合预期。那TransmittableThreadLocal是如何实现的呢？</p><h3 id="3-2-TransmittableThreadLocal实现原理"><a href="#3-2-TransmittableThreadLocal实现原理" class="headerlink" title="3.2 TransmittableThreadLocal实现原理"></a>3.2 TransmittableThreadLocal实现原理</h3><blockquote><p>从InheritableThreadLocal不支持线程池的根本原因是InheritableThreadLocal是在父线程创建子线程时复制的，由于线程池的复用机制，“子线程”只会复制一次。要支持线程池中能访问提交任务线程的本地变量，其实只需要在父线程在向线程池提交任务时复制父线程的上下环境，那在子线程中就能够如愿访问到父线程中的本地遍历，实现本地环境变量在线程调用之中的透传，实现链路跟踪，这也就是TransmittableThreadLocal最本质的实现原理。</p></blockquote><h4 id="3-2-1-TransmittableThreadLocal类图"><a href="#3-2-1-TransmittableThreadLocal类图" class="headerlink" title="3.2.1 TransmittableThreadLocal类图"></a>3.2.1 TransmittableThreadLocal类图</h4><p><img src="https://img-blog.csdnimg.cn/20190720230155275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>TransmittableThreadLocal继承自InheritableThreadLocal，接下来将从set方法为入口，开始探究TransmittableThreadLocal实现原理。</p><h4 id="3-2-2-set方法详解"><a href="#3-2-2-set方法详解" class="headerlink" title="3.2.2 set方法详解"></a>3.2.2 set方法详解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.set(value);                              <span class="comment">// @1</span></span><br><span class="line">    <span class="comment">// may set null to remove value</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == value)                               <span class="comment">// @2</span></span><br><span class="line">        removeValue();</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">addValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先调用父类的set方法，将value存入线程本地遍历，即Thread对象的inheritableThreadLocals中。</p><p>代码@2：如果value为空，则调用removeValue()否则调用addValue。</p><p>那接下来重点看看这两个方法有什么名堂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!holder.get().containsKey(<span class="keyword">this</span>)) &#123;    <span class="comment">// @1</span></span><br><span class="line">        holder.get().put(<span class="keyword">this</span>, <span class="keyword">null</span>); <span class="comment">// WeakHashMap supports null value.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    holder.get().remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：当前线程在调用threadLocal方法的set方法(即向线程本地遍历存储数据时)，如果需要设置的值不为null，则调用addValue方法，将当前ThreadLocal存储到TransmittableThreadLocal的全局静态变量holder。holder的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> InheritableThreadLocal&lt;Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt; holder =</span><br><span class="line">            <span class="keyword">new</span> InheritableThreadLocal&lt;Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; initialValue() &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; childValue(Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; parentValue) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;(parentValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>从中可以看出，使用了线程本地变量，内部存放的结构为Map&lt;TransmittableThreadLocal<?>, ?>，即该对象缓存了线程执行过程中所有的TransmittableThreadLocal对象，并且其关联的值不为空。但这样做有什么用呢？</p><p>为了解开这个难题，可能需要大家对ttl这个框架的使用有一定的理解，本文由于篇幅的原因，将不会详细介绍，如有大家有兴趣，可以查阅其官网了解其使用：<a href="https://github.com/alibaba/transmittable-thread-local">https://github.com/alibaba/transmittable-thread-local</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = TtlExecutors.getTtlExecutorService(Executors.newFixedThreadPool(<span class="number">4</span>));</span><br><span class="line">TransmittableThreadLocal&lt;String&gt; parent = <span class="keyword">new</span> TransmittableThreadLocal&lt;String&gt;();</span><br><span class="line">parent.set(<span class="string">&quot;value-set-in-parent&quot;</span>);</span><br><span class="line">Runnable task = <span class="keyword">new</span> Task(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">Callable call = <span class="keyword">new</span> Call(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">executorService.submit(task);</span><br><span class="line">executorService.submit(call);</span><br><span class="line"></span><br><span class="line">我们从submit为突破口，来尝试解开holder属性用途。</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExecutorTtlWrapper</span> <span class="keyword">implements</span> <span class="title">Executor</span>, <span class="title">TtlEnhanced</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"></span><br><span class="line">    ExecutorTtlWrapper(<span class="meta">@Nonnull</span> Executor executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="meta">@Nonnull</span> Runnable command)</span> </span>&#123;</span><br><span class="line">        executor.execute(TtlRunnable.get(command));  <span class="comment">// @1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nonnull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">unwrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在向线程池提交任务时，会使用TtlRunnable对提交任务进行包装。接下来将重点探讨TtlRunnable。</p><h4 id="3-2-2-TtlRunnable详解"><a href="#3-2-2-TtlRunnable详解" class="headerlink" title="3.2.2 TtlRunnable详解"></a>3.2.2 TtlRunnable详解</h4><h5 id="3-2-2-1-类图"><a href="#3-2-2-1-类图" class="headerlink" title="3.2.2.1 类图"></a>3.2.2.1 类图</h5><p><img src="https://img-blog.csdnimg.cn/20190720230352201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下面一一来介绍其核心属性：</p><ul><li>AtomicReference&lt; Object&gt; capturedRef<br>“捕获”的引用，根据下文的解读，该引用指向的数据结构包含了父线程在执行过程中，通过使用TransmittableThreadLocal存储的本地线程变量，但这里的触发时机是向线程池提交任务时捕获。</li><li>Runnable runnable<br>提交到线程池中待执行的业务逻辑。</li><li>boolean releaseTtlValueReferenceAfterRun<br>默认为false。</li></ul><p>接下来重点看一下其构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">TtlRunnable</span><span class="params">(<span class="meta">@Nonnull</span> Runnable runnable, <span class="keyword">boolean</span> releaseTtlValueReferenceAfterRun)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.capturedRef = <span class="keyword">new</span> AtomicReference&lt;Object&gt;(capture());   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">this</span>.runnable = runnable;</span><br><span class="line">    <span class="keyword">this</span>.releaseTtlValueReferenceAfterRun = releaseTtlValueReferenceAfterRun;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法没什么特别，重点看一下子线程是如何“捕获”父线程中已设置的本地线程变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TransmittableThreadLocal$Transmitter#capture</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; captured = <span class="keyword">new</span> HashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;();  <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">for</span> (TransmittableThreadLocal&lt;?&gt; threadLocal : holder.get().keySet()) &#123;     <span class="comment">// @2</span></span><br><span class="line">        captured.put(threadLocal, threadLocal.copyValue());                              <span class="comment">// @3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> captured;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：先创建Map容器，用来存储父线程的本地线程变量，键为在父线程执行过程中使用到的TransmittableThreadLocal线程。</p><p>代码@2：holder.get()，获取父线程中使用中的ThreadLocal，因为我们从3.2.2节中发现，在当前线程在调用TransmittableThreadLocal的set方法，并且其值不为空的时候，会将TransmittableThreadLocal对象存储存储在当前线程的本地变量中。故这里使用holder.get()方法能获取父线程中已使用的ThreadLocal，并其值不为null。</p><p>代码@3：遍历父线程已使用的线程本地，将其值存入到captured中，注意默认是浅拷贝，如果向实现深度拷贝，请重写TransmittableThreadLocal的copyValue方法。</p><blockquote><p>温馨提示：从这里看出TransmittableThreadLocal的静态属性holder的用处吧，请重点理解holder的属性类型为：InheritableThreadLocal&lt;Map&lt;TransmittableThreadLocal<?>, ?>&gt;。</p></blockquote><p>在向线程池提交任务时，就会先捕获父线程(提交任务到线程池的线程)中的本地环境变量，接下来重点来看一下其run方法。</p><h5 id="3-2-2-2-run方法"><a href="#3-2-2-2-run方法" class="headerlink" title="3.2.2.2 run方法"></a>3.2.2.2 run方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object captured = capturedRef.get();             </span><br><span class="line">    <span class="keyword">if</span> (captured == <span class="keyword">null</span> || releaseTtlValueReferenceAfterRun &amp;&amp; !capturedRef.compareAndSet(captured, <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;TTL value reference is released after run!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object backup = replay(captured);                <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        runnable.run();                                           <span class="comment">// @2</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        restore(backup);                                        <span class="comment">// @3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：”重放”父线程的本地环境变量，即使用从父线程中捕获过来的上下文环境，在子线程中重新执行一遍，并返回原先存在与子线程中的上下文环境变量。</p><p>代码@2：执行业务逻辑。</p><p>代码@3：恢复线程池中当前执行任务的线程的上下文环境，即代码@1，会直接继承父线程中的上下文环境，但会将原先存在该线程的线程上下文环境进行备份，在任务执行完后通过执行restore方法进行恢复。</p><p>不得不佩服这里设计的巧妙。笔者有理由相信能看到这里的诸位读者一定是有实力有求知的欲望的人，那我们在来看一下replay、restore方法的实现。</p><h5 id="3-2-2-3-replay"><a href="#3-2-2-3-replay" class="headerlink" title="3.2.2.3 replay"></a>3.2.2.3 replay</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">replay</span><span class="params">(<span class="meta">@Nonnull</span> Object captured)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; capturedMap = (Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;) captured;      <span class="comment">// @1</span></span><br><span class="line">    Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; backup = <span class="keyword">new</span> HashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;();              </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;? extends Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt; iterator = holder.get().entrySet().iterator();               <span class="comment">// @2</span></span><br><span class="line">                 iterator.hasNext(); ) &#123;</span><br><span class="line">        Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; next = iterator.next();</span><br><span class="line">        TransmittableThreadLocal&lt;?&gt; threadLocal = next.getKey();</span><br><span class="line"></span><br><span class="line">        backup.put(threadLocal, threadLocal.get());                                                                                                                       <span class="comment">// @3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear the TTL values that is not in captured</span></span><br><span class="line">        <span class="comment">// avoid the extra TTL values after replay when run task</span></span><br><span class="line">        <span class="keyword">if</span> (!capturedMap.containsKey(threadLocal)) &#123;                                                                                                                    <span class="comment">// @4</span></span><br><span class="line">            iterator.remove();</span><br><span class="line">            threadLocal.superRemove();</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">// set values to captured TTL</span></span><br><span class="line">      setTtlValuesTo(capturedMap);                                                                                                                                              <span class="comment">// @5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// call beforeExecute callback</span></span><br><span class="line">    doExecuteCallback(<span class="keyword">true</span>);                                                                                                                                                     <span class="comment">// @6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> backup;                                                                                                                                                                       <span class="comment">// @7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先解释一下两个局部变量的含义：</p><ul><li>capturedMap<br>子线程从父线程捕获的线程本地遍历。</li><li>backup<br>线程池中处理本次任务的线程中原先存在的本地线程变量。</li></ul><p>代码@2：holder.get()，这里是子线程中原先存在的本地线程变量(即线程池中分配来执行本次任务的线程)，然后遍历它，将其存储在backUp(@3)。</p><p>代码@4：从这里开始，开始将根据父线程的本地变量来重放当前线程，如果父线程中不包含的threadlocal对象，将从本地线程变量中移除。</p><p>代码@5：遍历父线程中的本地线程变量，在子线程中重新执行一次threadlocal.set方法。</p><p>代码@6：执行beforeExecute()狗子函数。</p><p>代码@7：返回线程池原线程的本地线程变量，供本次调用后恢复上下文环境。</p><h5 id="3-2-2-4-restore"><a href="#3-2-2-4-restore" class="headerlink" title="3.2.2.4 restore"></a>3.2.2.4 restore</h5><p>恢复线程中子线程原先的本地线程变量，即恢复线程，本次执行并不会污染线程池中线程原先的上下文环境，精妙。我们来看看其代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restore</span><span class="params">(<span class="meta">@Nonnull</span> Object backup)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; backupMap = (Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;) backup;      <span class="comment">// @1</span></span><br><span class="line">    <span class="comment">// call afterExecute callback</span></span><br><span class="line">    doExecuteCallback(<span class="keyword">false</span>);                                                                                                                                                   <span class="comment">// @2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;? extends Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt; iterator = holder.get().entrySet().iterator();           <span class="comment">// @3</span></span><br><span class="line">                 iterator.hasNext(); ) &#123;</span><br><span class="line">        Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; next = iterator.next();</span><br><span class="line">        TransmittableThreadLocal&lt;?&gt; threadLocal = next.getKey();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear the TTL values that is not in bac1kup</span></span><br><span class="line">        <span class="comment">// avoid the extra TTL values after restore</span></span><br><span class="line">        <span class="keyword">if</span> (!backupMap.containsKey(threadLocal)) &#123;                                                                                                                     <span class="comment">// @4</span></span><br><span class="line">            iterator.remove();</span><br><span class="line">            threadLocal.superRemove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restore TTL values</span></span><br><span class="line">    setTtlValuesTo(backupMap);                                                                                                                                                  <span class="comment">// @5</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>代码@1：获取备份好的线程本地上下文。</p><p>代码@2：执行afterExecute()钩子函数。</p><p>代码@3：遍历本地线程变量，将不属于backUpMap中存在的线程本地上下文移除(@4)。</p><p>代码@5：遍历备份的本地线程本地，在本地线程中重新执行threadlocal#set方法，实现线程本地变量的还原。</p><p>本文介绍到这里了，详细介绍了ThreadLocal、InheritableThreadLocal、TransmittableThreadLocal的实现原理，并从ThreadLocal、InheritableThreadLocal的局限性，最终引出TransmittableThreadLocal，为全链路压测中压测标记的透传打下坚实的基础。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;说起本地线程变量，我相信大家首先会想到的是JDK默认提供的ThreadLocal，用来存储在整个调用链中都需要访问的数据，并且是线程安全的。由于本文的写作背景是笔者需要在公司落地全链路压测平台，一个基本并核心的功能需求是压测标记需要在整个调用链中进行传递，线程上下文环境成为解决这个问题最合适的技术。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;温馨提示：&lt;br&gt;本从从ThreadLocal原理入手分析，并抛出其缺点，再逐一引出InheritableThreadLocal、TransmittableThreadLocal。文章篇幅稍长，但由于循序渐进，层层递进，故精华部分在后面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1、ThreadLocal详解&quot;&gt;&lt;a href=&quot;#1、ThreadLocal详解&quot; class=&quot;headerlink&quot; title=&quot;1、ThreadLocal详解&quot;&gt;&lt;/a&gt;1、ThreadLocal详解&lt;/h2&gt;&lt;p&gt;ThreadLocal对外提供;的API如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;public T get(）&lt;br&gt;从线程上下文环境中获取设置的值。&lt;/li&gt;
&lt;li&gt;public void set(T value)&lt;br&gt;将值存储到线程上下文环境中，供后续使用。&lt;/li&gt;
&lt;li&gt;public void remove()&lt;br&gt;清除线程本地上下文环境。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述API使用简单，关键是要理解ThreadLocal的内部存储结果。&lt;/p&gt;
&lt;h3 id=&quot;1-1-ThreadLocal存储结构&quot;&gt;&lt;a href=&quot;#1-1-ThreadLocal存储结构&quot; class=&quot;headerlink&quot; title=&quot;1.1 ThreadLocal存储结构&quot;&gt;&lt;/a&gt;1.1 ThreadLocal存储结构&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190720224949903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;上图的几个关键点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据存储位置&lt;br&gt;当线程调用threadLocal对象的set(Object value)方法时，数据并不是存储在ThreadLocal对象中，而是存储在Thread对象中，这也是ThreadLocal的由来，具体存储在线程对象的threadLocals属性中，其类型为ThreadLocal.ThreadLocalMap。&lt;/li&gt;
&lt;li&gt;ThreadLocal.ThreadLocalMap，Map结构，即键值对，键为threadLocal对象，值为需要存储到线程上下文的值(threadLocal#set)方法的参数。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="kafka" scheme="http://example.com/categories/kafka/"/>
    
    
    <category term="全链路" scheme="http://example.com/tags/%E5%85%A8%E9%93%BE%E8%B7%AF/"/>
    
    <category term="ThreadLocal" scheme="http://example.com/tags/ThreadLocal/"/>
    
    <category term="InheritableThreadLocal" scheme="http://example.com/tags/InheritableThreadLocal/"/>
    
    <category term="ttl" scheme="http://example.com/tags/ttl/"/>
    
  </entry>
  
  <entry>
    <title>源码分析Kafka 消息拉取流程</title>
    <link href="http://example.com/posts/497923c7.html"/>
    <id>http://example.com/posts/497923c7.html</id>
    <published>2020-12-11T15:19:01.000Z</published>
    <updated>2020-12-11T15:22:06.432Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="１、KafkaConsumer-poll-详解"><a href="#１、KafkaConsumer-poll-详解" class="headerlink" title="１、KafkaConsumer poll 详解"></a>１、KafkaConsumer poll 详解</h2><p>消息拉起主要入口为：KafkaConsumer#poll方法，其声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">final</span> Duration timeout)</span> </span>&#123;  <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">return</span> poll(time.timer(timeout), <span class="keyword">true</span>);                                     <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码＠１：参数为超时时间，使用 java 的 Duration 来定义。<br>代码＠２：调用内部的 poll 方法。</p><p>KafkaConsumer#poll</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">final</span> Timer timer, <span class="keyword">final</span> <span class="keyword">boolean</span> includeMetadataInTimeout)</span> </span>&#123;  <span class="comment">// @1</span></span><br><span class="line">    acquireAndEnsureOpen();                                                                                                               <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.subscriptions.hasNoSubscriptionOrUserAssignment()) &#123;                                                  <span class="comment">// @3</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Consumer is not subscribed to any topics or assigned any partitions&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// poll for new data until the timeout expires</span></span><br><span class="line">        <span class="keyword">do</span> &#123;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　<span class="comment">// @4</span></span><br><span class="line">            client.maybeTriggerWakeup();                                                                                               <span class="comment">//@5</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (includeMetadataInTimeout) &#123;                       　　　　　　　　　　　　　　　　　　　 <span class="comment">// @6 　　　　　　　　　　　　　　　　　　　　                                                          </span></span><br><span class="line">                <span class="keyword">if</span> (!updateAssignmentMetadataIfNeeded(timer)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ConsumerRecords.empty();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!updateAssignmentMetadataIfNeeded(time.timer(Long.MAX_VALUE))) &#123;        </span><br><span class="line">                    log.warn(<span class="string">&quot;Still waiting for metadata&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = pollForFetches(timer);   <span class="comment">// @7</span></span><br><span class="line">            <span class="keyword">if</span> (!records.isEmpty()) &#123;                                                                                                           </span><br><span class="line">                <span class="keyword">if</span> (fetcher.sendFetches() &gt; <span class="number">0</span> || client.hasPendingRequests()) &#123;                                           <span class="comment">// @8</span></span><br><span class="line">                    client.pollNoWakeup();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.interceptors.onConsume(<span class="keyword">new</span> ConsumerRecords&lt;&gt;(records));                         <span class="comment">// @９</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (timer.notExpired());                                                                                                         </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ConsumerRecords.empty();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码＠１：首先先对其参数含义进行讲解。</p><ul><li>boolean includeMetadataInTimeout<br>拉取消息的超时时间是否包含更新元数据的时间，默认为true，即包含。</li></ul><p>代码＠２：检查是否可以拉取消息，其主要判断依据如下：</p><ul><li>KafkaConsumer 是否有其他线程再执行，如果有，则抛出异常，因为 - KafkaConsumer 是线程不安全的，同一时间只能一个线程执行。</li><li>KafkaConsumer 没有被关闭。</li></ul><p>代码＠３：如果当前消费者未订阅任何主题或者没有指定队列，则抛出错误，结束本次消息拉取。</p><p>代码＠４：使用 do while 结构循环拉取消息，直到超时或拉取到消息。</p><p>代码＠５：避免在禁止禁用wakeup时，有请求想唤醒时则抛出异常，例如在下面的@8时，会禁用wakeup。</p><p>代码＠６：更新相关元数据，为真正向 broker 发送消息拉取请求做好准备，该方法将在下面详细介绍，现在先简单介绍其核心实现点：</p><ul><li>如有必要，先向 broker 端拉取最新的订阅信息(包含消费组内的在线的消费客户端)。</li><li>执行已完成(异步提交)的 offset 提交请求的回调函数。</li><li>维护与 broker 端的心跳请求，确保不会被“踢出”消费组。</li><li>更新元信息。</li><li>如果是自动提交消费偏移量，则自动提交偏移量。</li><li>更新各个分区下次待拉取的偏移量。</li></ul><p>这里会有一个更新元数据是否占用消息拉取的超时时间，默认为 true。</p><p>代码＠７：调用 pollForFetches 向broker拉取消息，该方法将在下文详细介绍。</p><p>代码＠８：如果拉取到的消息集合不为空，再返回该批消息之前，如果还有挤压的拉取请求，可以继续发送拉取请求，但此时会禁用warkup，主要的目的是用户在处理消息时，KafkaConsumer 还可以继续向broker 拉取消息。</p><p>代码＠９：执行消费拦截器。</p><p>接下来对上文提到的代码＠６、＠７进行详细介绍。</p><a id="more"></a><h4 id="1-1-KafkaConsumer-updateAssignmentMetadataIfNeeded-详解"><a href="#1-1-KafkaConsumer-updateAssignmentMetadataIfNeeded-详解" class="headerlink" title="1.1 KafkaConsumer updateAssignmentMetadataIfNeeded 详解"></a>1.1 KafkaConsumer updateAssignmentMetadataIfNeeded 详解</h4><p>KafkaConsumer＃updateAssignmentMetadataIfNeeded</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateAssignmentMetadataIfNeeded</span><span class="params">(<span class="keyword">final</span> Timer timer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (coordinator != <span class="keyword">null</span> &amp;&amp; !coordinator.poll(timer)) &#123;                            <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> updateFetchPositions(timer);                                                  <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要理解这个方法实现的用途，我们就必须依次对 coordinator.poll 方法与 updateFetchPositions 方法。</p><h5 id="1-1-1-ConsumerCoordinator-poll"><a href="#1-1-1-ConsumerCoordinator-poll" class="headerlink" title="1.1.1 ConsumerCoordinator#poll"></a>1.1.1 ConsumerCoordinator#poll</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">poll</span><span class="params">(Timer timer)</span> </span>&#123;</span><br><span class="line">    invokeCompletedOffsetCommitCallbacks();  <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">if</span> (subscriptions.partitionsAutoAssigned()) &#123;  <span class="comment">// @2</span></span><br><span class="line">        pollHeartbeat(timer.currentTimeMs());       <span class="comment">// @21</span></span><br><span class="line">        <span class="keyword">if</span> (coordinatorUnknown() &amp;&amp; !ensureCoordinatorReady(timer)) &#123;   <span class="comment">//@22</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rejoinNeededOrPending()) &#123;                                                       <span class="comment">// @23</span></span><br><span class="line">            <span class="keyword">if</span> (subscriptions.hasPatternSubscription()) &#123;                              <span class="comment">// @231</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.metadata.timeToAllowUpdate(time.milliseconds()) == <span class="number">0</span>) &#123;  </span><br><span class="line">                    <span class="keyword">this</span>.metadata.requestUpdate();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!client.ensureFreshMetadata(timer)) &#123;                                  </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!ensureActiveGroup(timer)) &#123;                                                <span class="comment">// @232</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                                            <span class="comment">// @3</span></span><br><span class="line">        <span class="keyword">if</span> (metadata.updateRequested() &amp;&amp; !client.hasReadyNodes(timer.currentTimeMs())) &#123;</span><br><span class="line">            client.awaitMetadataUpdate(timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    maybeAutoCommitOffsetsAsync(timer.currentTimeMs());   <span class="comment">// @4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码＠1：执行已完成的 offset (消费进度)提交请求的回调函数。</p><p>代码@2：队列负载算法为自动分配（即 Kafka 根据消费者个数与分区书动态负载分区）的相关的处理逻辑。其实现关键点如下：</p><ul><li>代码@21：更新发送心跳相关的时间，例如heartbeatTimer、sessionTimer、pollTimer 分别代表发送最新发送心跳的时间、会话最新活跃时间、最新拉取消息。</li><li>代码@22：如果不存在协调器或协调器已断开连接，则返回 false，结束本次拉取。如果协调器就绪，则继续往下走。</li><li>代码@23：判断是否需要触发重平衡，即消费组内的所有消费者重新分配topic中的分区信息，例如元数据发送变化，判断是否需要重新重平衡的关键点如下：<ul><li>如果队列负载是通过用户指定的，则返回 false，表示无需重平衡。</li><li>如果队列是自动负载，topic 队列元数据发生了变化，则需要重平衡。</li><li>如果队列是自动负载，订阅关系发生了变化，则需要重平衡。<br>如果需要重重平衡，则同步更新元数据，此过程会阻塞。详细的重平衡将单独重点介绍，这里暂时不深入展开。</li></ul></li></ul><p>代码@3：用户手动为消费组指定负载的队列的相关处理逻辑，其实现关键如下：</p><ul><li>如果需要更新元数据，并且还没有分区准备好，则同步阻塞等待元数据更新完毕。</li></ul><p>代码@4：如果开启了自动提交消费进度，并且已到下一次提交时间，则提交。Kafka 消费者可以通过设置属性 enable.auto.commit 来开启自动提交，该参数默认为 true，则默认会每隔 5s 提交一次消费进度，提交间隔可以通过参数 auto.commit.interval.ms 设置。</p><p>接下来继续探讨 updateAssignmentMetadataIfNeeded (更新元数据)的第二个步骤，更新拉取位移。</p><h5 id="1-1-2-updateFetchPositions-详解"><a href="#1-1-2-updateFetchPositions-详解" class="headerlink" title="1.1.2 updateFetchPositions 详解"></a>1.1.2 updateFetchPositions 详解</h5><p>KafkaConsumer#updateFetchPositions</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateFetchPositions</span><span class="params">(<span class="keyword">final</span> Timer timer)</span> </span>&#123;</span><br><span class="line">    cachedSubscriptionHashAllFetchPositions = subscriptions.hasAllFetchPositions();  </span><br><span class="line">    <span class="keyword">if</span> (cachedSubscriptionHashAllFetchPositions) &#123;           <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (coordinator != <span class="keyword">null</span> &amp;&amp; !coordinator.refreshCommittedOffsetsIfNeeded(timer))   <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    subscriptions.resetMissingPositions();                         <span class="comment">// @3</span></span><br><span class="line">    fetcher.resetOffsetsIfNeeded();                                    <span class="comment">// @4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果订阅关系中的所有分区都有有效的位移，则返回 true。</p><p>代码@2：如果存在任意一个分区没有有效的位移信息，则需要向 broker 发送请求，从broker 获取该消费组，该分区的消费进度。相关的实现细节将在后续文章【Kafka 消费进度】专题文章中详细介绍。</p><p>代码@3：如果经过第二步，订阅关系中还某些分区还是没有获取到有效的偏移量，则使用偏移量重置策略进行重置，如果未配置，则抛出异常。</p><p>代码@4：发送一个异步请求去重置那些正等待重置位置的分区。有关 Kafka 消费消费进度、重平衡等知识将会在后续文章中深入探讨，本文只需了解 poll 消息的核心处理流程。</p><p>从 KafkaConsumer#poll 中流程可以看到，通过 updateAssignmentMetadataIfNeeded 对元数据、重平衡，更新拉取偏移量等工作处理完成后，下一步就是需要向 broker 拉取消息了，其实现入口为：KafkaConsumer 的 pollForFetches 方法。</p><h4 id="1-2-消息拉取"><a href="#1-2-消息拉取" class="headerlink" title="1.2 消息拉取"></a>1.2 消息拉取</h4><p>KafkaConsumer#pollForFetches</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; pollForFetches(Timer timer) &#123;</span><br><span class="line">        <span class="keyword">long</span> pollTimeout = coordinator == <span class="keyword">null</span> ? timer.remainingMs() :</span><br><span class="line">                Math.min(coordinator.timeToNextPoll(timer.currentTimeMs()), timer.remainingMs());   <span class="comment">// @1</span></span><br><span class="line">        <span class="comment">// if data is available already, return it immediately</span></span><br><span class="line">        <span class="keyword">final</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = fetcher.fetchedRecords();    <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> records;</span><br><span class="line">        &#125;</span><br><span class="line">        fetcher.sendFetches();                               <span class="comment">// @3</span></span><br><span class="line">        <span class="comment">// We do not want to be stuck blocking in poll if we are missing some positions</span></span><br><span class="line">        <span class="comment">// since the offset lookup may be backing off after a failure</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> the use of cachedSubscriptionHashAllFetchPositions means we MUST call</span></span><br><span class="line">        <span class="comment">// updateAssignmentMetadataIfNeeded before this method.</span></span><br><span class="line">        <span class="keyword">if</span> (!cachedSubscriptionHashAllFetchPositions &amp;&amp; pollTimeout &gt; retryBackoffMs) &#123;   <span class="comment">// @4</span></span><br><span class="line">            pollTimeout = retryBackoffMs;</span><br><span class="line">        &#125;</span><br><span class="line">        Timer pollTimer = time.timer(pollTimeout);</span><br><span class="line">        client.poll(pollTimer, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> !fetcher.hasCompletedFetches();</span><br><span class="line">        &#125;);         <span class="comment">// @5</span></span><br><span class="line">        timer.update(pollTimer.currentTimeMs());   <span class="comment">// @6</span></span><br><span class="line">        <span class="keyword">if</span> (coordinator != <span class="keyword">null</span> &amp;&amp; coordinator.rejoinNeededOrPending()) &#123;  <span class="comment">// @7</span></span><br><span class="line">            <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fetcher.fetchedRecords();   <span class="comment">// @8</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：计算本次拉取的超时时间，其计算逻辑如下：</p><ul><li>如果协调器为空，则返回当前定时器剩余时间即可。</li><li>如果协调器不为空，其逻辑较为复杂，为下面返回的超时间与当前定时器剩余时间相比取最小值。</li><li>如果不开启自动提交位移并且未加入消费组，则超时时间为Long.MAX_VALUE。</li><li>如果不开启自动提交位移并且已加入消费组，则返回距离下一次发送心跳包还剩多少时间。</li><li>如果开启自动提交位移，则返回 距离下一次自动提交位移所需时间 与 距离下一次发送心跳包所需时间 之间的最小值。</li></ul><p>代码@2：如果数据已经拉回到本地，直接返回数据。将在下文详细介绍 Fetcher 的 fetchedRecords 方法。</p><p>代码@3:组装发送请求，并将存储在待发送请求列表中。</p><p>代码@4：如果已缓存的分区信息中存在某些分区缺少偏移量，如果拉取的超时时间大于失败重试需要阻塞的时间，则更新此次拉取的超时时间为失败重试需要的间隔时间，主要的目的是不希望在 poll 过程中被阻塞【后续会详细介绍 Kafka 拉取消息的线程模型，再来回顾一下这里】。</p><p>代码@5：通过调用NetworkClient 的 poll 方法发起消息拉取操作（触发网络读写）。</p><p>代码@6：更新本次拉取的时间。</p><p>代码@7：检查是需要重平衡。</p><p>代码@8：将从 broker 读取到的数据返回（即封装成消息）。</p><p>从上面消息拉取流程来看，有几个比较重要的方法，例如 Fetcher 类相关的方法，NetworkClient 的 poll 方法，那我们接下来来重点探讨。</p><p>我们先用一张流程图总结一下消息拉取的全过程：<br><img src="https://img-blog.csdnimg.cn/20191208193241248.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来我们将重点看一下 KafkaConsumer 的 pollForFetches 详细过程，也就是需要详细探究 Fetcher 类的实现细节。</p><h2 id="2、Fetcher-类详解"><a href="#2、Fetcher-类详解" class="headerlink" title="2、Fetcher 类详解"></a>2、Fetcher 类详解</h2><p>Fetcher 封装消息拉取的方法，可以看成是消息拉取的门面类。</p><h4 id="2-1-类图"><a href="#2-1-类图" class="headerlink" title="2.1 类图"></a>2.1 类图</h4><p><img src="https://img-blog.csdnimg.cn/20191208193319781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们首先一一介绍一下 Fetcher 的核心属性与核心方法。</p><ul><li>ConsumerNetworkClient client<br>消费端网络客户端，Kafka 负责网络通讯实现类。</li><li>int minBytes<br>一次消息拉取需要拉取的最小字节数，如果不组，会阻塞，默认值为1字节，如果增大这个值会增大吞吐，但会增加延迟，可以通参数 fetch.min.bytes 改变其默认值。</li><li>int maxBytes<br>一次消息拉取允许拉取的最大字节数，但这不是绝对的，如果一个分区的第一批记录超过了该值，也会返回。默认为50M,可通过参数 fetch.max.bytes 改变其默认值。同时不能超过 broker的配置参数(message.max.bytes) 和 主题级别的配置(max.message.bytes)。</li><li>int maxWaitMs<br>在 broker 如果符合拉取条件的数据小于 minBytes 时阻塞的时间，默认为 500ms ，可通属性 fetch.max.wait.ms 进行定制。</li><li>int fetchSize<br>每一个分区返回的最大消息字节数，如果分区中的第一批消息大于 fetchSize 也会返回。</li><li>long retryBackoffMs<br>失败重试后需要阻塞的时间，默认为 100 ms，可通过参数 retry.backoff.ms 定制。</li><li>long requestTimeoutMs<br>客户端向 broker 发送请求最大的超时时间，默认为 30s，可以通过 request.timeout.ms 参数定制。</li><li>int maxPollRecords<br>单次拉取返回的最大记录数，默认值 500，可通过参数 max.poll.records 进行定制。</li><li>boolean checkCrcs<br>是否检查消息的 crcs 校验和，默认为 true，可通过参数 check.crcs 进行定制。</li><li>Metadata metadata<br>元数据。</li><li>FetchManagerMetrics sensors<br>消息拉取的统计服务类。</li><li>SubscriptionState subscriptions<br>订阅信息状态。</li><li>ConcurrentLinkedQueue&lt; CompletedFetch&gt; completedFetches<br>已完成的 Fetch 的请求结果，待消费端从中取出数据。</li><li>Deserializer&lt; K&gt; keyDeserializer<br>key 的反序列化器。</li><li>Deserializer&lt; V&gt; valueDeserializer<br>value 的饭序列化器。</li><li>IsolationLevel isolationLevel<br>Kafka的隔离级别（与事务消息相关），后续在研究其事务相关时再进行探讨。</li><li>Map&lt;Integer, FetchSessionHandler&gt; sessionHandlers<br>拉取会话监听器。</li></ul><p>接下来我们将按照消息流程，一起来看一下 Fetcher 的核心方法。</p><h4 id="2-2-Fetcher-核心方法"><a href="#2-2-Fetcher-核心方法" class="headerlink" title="2.2 Fetcher 核心方法"></a>2.2 Fetcher 核心方法</h4><h5 id="2-2-1-Fetcher-fetchedRecords"><a href="#2-2-1-Fetcher-fetchedRecords" class="headerlink" title="2.2.1 Fetcher#fetchedRecords"></a>2.2.1 Fetcher#fetchedRecords</h5><p>Fetcher#fetchedRecords</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; fetchedRecords() &#123;</span><br><span class="line">    Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; fetched = <span class="keyword">new</span> HashMap&lt;&gt;();   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">int</span> recordsRemaining = maxPollRecords;                                                              </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (recordsRemaining &gt; <span class="number">0</span>) &#123;                                                                                  <span class="comment">// @2</span></span><br><span class="line">            <span class="keyword">if</span> (nextInLineRecords == <span class="keyword">null</span> || nextInLineRecords.isFetched) &#123;                           <span class="comment">// @3</span></span><br><span class="line">                CompletedFetch completedFetch = completedFetches.peek();</span><br><span class="line">                <span class="keyword">if</span> (completedFetch == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    nextInLineRecords = parseCompletedFetch(completedFetch);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    FetchResponse.PartitionData partition = completedFetch.partitionData;</span><br><span class="line">                    <span class="keyword">if</span> (fetched.isEmpty() &amp;&amp; (partition.records == <span class="keyword">null</span> || partition.records.sizeInBytes() == <span class="number">0</span>)) &#123;</span><br><span class="line">                        completedFetches.poll();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">                completedFetches.poll();</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;                                                                                                                         <span class="comment">// @4</span></span><br><span class="line">                List&lt;ConsumerRecord&lt;K, V&gt;&gt; records = fetchRecords(nextInLineRecords, recordsRemaining);</span><br><span class="line">                TopicPartition partition = nextInLineRecords.partition;</span><br><span class="line">                <span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">                    List&lt;ConsumerRecord&lt;K, V&gt;&gt; currentRecords = fetched.get(partition);</span><br><span class="line">                    <span class="keyword">if</span> (currentRecords == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        fetched.put(partition, records);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        List&lt;ConsumerRecord&lt;K, V&gt;&gt; newRecords = <span class="keyword">new</span> ArrayList&lt;&gt;(records.size() + currentRecords.size());</span><br><span class="line">                        newRecords.addAll(currentRecords);</span><br><span class="line">                        newRecords.addAll(records);</span><br><span class="line">                        fetched.put(partition, newRecords);</span><br><span class="line">                    &#125;</span><br><span class="line">                    recordsRemaining -= records.size();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fetched.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fetched;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先先解释两个局部变量的含义：</p><ul><li>Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; fetched 按分区存放已拉取的消息，返回给客户端进行处理。</li><li>recordsRemaining：剩余可拉取的消息条数。</li></ul><p>代码@2：循环去取已经完成了 Fetch 请求的消息，该 while 循环有两个跳出条件：</p><ul><li>如果拉取的消息已经达到一次拉取的最大消息条数，则跳出循环。</li><li>缓存中所有拉取结果已处理。</li></ul><p>代码@3、@4 主要完成从缓存中解析数据的两个步骤，初次运行的时候，会进入分支@3，然后从 调用 parseCompletedFetch 解析成 PartitionRecords 对象，然后代码@4的职责就是从解析 PartitionRecords ，将消息封装成 ConsumerRecord，返回给消费端线程处理。</p><p>代码@3的实现要点如下：</p><ul><li>首先从 completedFetches (Fetch请求的返回结果) 列表中获取一个 Fetcher 请求，主要使用的 Queue 的 peek()方法，并不会从该队列中移除该元素。</li><li>然后调用 parseCompletedFetch 对处理结果进行解析返回 PartitionRecords。</li><li>处理成功后，调用 Queue 的方法将已处理过的 Fetcher结果移除。</li></ul><p>从上面可知，上述方法的核心方法是：parseCompletedFetch。</p><p>代码@4的实现要点无非就是调用 fetchRecords 方法，按分区组装成 Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt;，供消费者处理，例如供业务处理。</p><p>接下来将重点探讨上述两个方法的实现细节。</p><h6 id="2-2-1-1-Fetcher-parseCompletedFetch"><a href="#2-2-1-1-Fetcher-parseCompletedFetch" class="headerlink" title="2.2.1.1 Fetcher#parseCompletedFetch"></a>2.2.1.1 Fetcher#parseCompletedFetch</h6><p>在尝试探讨该方法之前，我们首先对其入参进行一个梳理，特别是先认识其主要数据结构。</p><p>1、CompletedFetch 相关类图<br><img src="https://img-blog.csdnimg.cn/2019120819365575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上图可以看出，CompleteFetch 核心属性主要如下：</p><ul><li>TopicPartition partition<br>分区信息，返回结果都是以分区为纬度。</li><li>long fetchedOffset<br>本次拉取的开始偏移量。</li><li>FetchResponse.PartitionData partitionData<br>返回的分区数据。</li><li>FetchResponseMetricAgregator metricAggregator<br>统计指标相关。</li><li>short responseVersion<br>broker 端的版本号。</li></ul><p>分区的数据是使用 PartitionData 来进行封装的。我们也来简单的了解一下其内部数据结果。</p><ul><li>Errors error<br>分区拉取的相应结果，Errors.NONE 表示请求成功。</li><li>long highWatermark<br>broker 端关于该分区的高水位线，即小于该偏移量的消息对于消费端是可见的。</li><li>long lastStableOffset<br>分区中小于该偏移量的消息的事务状态已得到确认，要么是已提交，要么是已回滚，与事务相关，后面会专门探讨。</li><li>List&lt; AbortedTransaction&gt; abortedTransactions<br>已拒绝的事物。</li><li>T records<br>分区数据，是 BaseRecords 的子类。</li></ul><p>2、parseCompletedFetch 详解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PartitionRecords <span class="title">parseCompletedFetch</span><span class="params">(CompletedFetch completedFetch)</span> </span>&#123;</span><br><span class="line">    TopicPartition tp = completedFetch.partition;</span><br><span class="line">    FetchResponse.PartitionData&lt;Records&gt; partition = completedFetch.partitionData;</span><br><span class="line">    <span class="keyword">long</span> fetchOffset = completedFetch.fetchedOffset;</span><br><span class="line">    PartitionRecords partitionRecords = <span class="keyword">null</span>;</span><br><span class="line">    Errors error = partition.error;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!subscriptions.isFetchable(tp)) &#123;       <span class="comment">// @1</span></span><br><span class="line">            log.debug(<span class="string">&quot;Ignoring fetched records for partition &#123;&#125; since it is no longer fetchable&quot;</span>, tp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.NONE) &#123;         <span class="comment">// @2</span></span><br><span class="line">            Long position = subscriptions.position(tp);</span><br><span class="line">            <span class="keyword">if</span> (position == <span class="keyword">null</span> || position != fetchOffset) &#123;    <span class="comment">// @21</span></span><br><span class="line">                log.debug(<span class="string">&quot;Discarding stale fetch response for partition &#123;&#125; since its offset &#123;&#125; does not match &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;the expected offset &#123;&#125;&quot;</span>, tp, fetchOffset, position);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            log.trace(<span class="string">&quot;Preparing to read &#123;&#125; bytes of data for partition &#123;&#125; with offset &#123;&#125;&quot;</span>,</span><br><span class="line">                        partition.records.sizeInBytes(), tp, position);</span><br><span class="line">            Iterator&lt;? extends RecordBatch&gt; batches = partition.records.batches().iterator();   <span class="comment">// @22</span></span><br><span class="line">            partitionRecords = <span class="keyword">new</span> PartitionRecords(tp, completedFetch, batches);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!batches.hasNext() &amp;&amp; partition.records.sizeInBytes() &gt; <span class="number">0</span>) &#123;   <span class="comment">// @23</span></span><br><span class="line">                <span class="keyword">if</span> (completedFetch.responseVersion &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                    Map&lt;TopicPartition, Long&gt; recordTooLargePartitions = Collections.singletonMap(tp, fetchOffset);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RecordTooLargeException(<span class="string">&quot;There are some messages at [Partition=Offset]: &quot;</span> +</span><br><span class="line">                                recordTooLargePartitions + <span class="string">&quot; whose size is larger than the fetch size &quot;</span> + <span class="keyword">this</span>.fetchSize +</span><br><span class="line">                                <span class="string">&quot; and hence cannot be returned. Please considering upgrading your broker to 0.10.1.0 or &quot;</span> +</span><br><span class="line">                                <span class="string">&quot;newer to avoid this issue. Alternately, increase the fetch size on the client (using &quot;</span> +</span><br><span class="line">                                ConsumerConfig.MAX_PARTITION_FETCH_BYTES_CONFIG + <span class="string">&quot;)&quot;</span>,</span><br><span class="line">                                recordTooLargePartitions);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// This should not happen with brokers that support FetchRequest/Response V3 or higher (i.e. KIP-74)</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">&quot;Failed to make progress reading messages at &quot;</span> + tp + <span class="string">&quot;=&quot;</span> +</span><br><span class="line">                            fetchOffset + <span class="string">&quot;. Received a non-empty fetch response from the server, but no &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;complete records were found.&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (partition.highWatermark &gt;= <span class="number">0</span>) &#123;   <span class="comment">// @24</span></span><br><span class="line">                log.trace(<span class="string">&quot;Updating high watermark for partition &#123;&#125; to &#123;&#125;&quot;</span>, tp, partition.highWatermark);</span><br><span class="line">                subscriptions.updateHighWatermark(tp, partition.highWatermark);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (partition.logStartOffset &gt;= <span class="number">0</span>) &#123;    <span class="comment">// @25</span></span><br><span class="line">                log.trace(<span class="string">&quot;Updating log start offset for partition &#123;&#125; to &#123;&#125;&quot;</span>, tp, partition.logStartOffset);</span><br><span class="line">                    subscriptions.updateLogStartOffset(tp, partition.logStartOffset);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (partition.lastStableOffset &gt;= <span class="number">0</span>) &#123; <span class="comment">// @26</span></span><br><span class="line">                log.trace(<span class="string">&quot;Updating last stable offset for partition &#123;&#125; to &#123;&#125;&quot;</span>, tp, partition.lastStableOffset);</span><br><span class="line">                    subscriptions.updateLastStableOffset(tp, partition.lastStableOffset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.NOT_LEADER_FOR_PARTITION ||</span><br><span class="line">                       error == Errors.REPLICA_NOT_AVAILABLE ||</span><br><span class="line">                       error == Errors.KAFKA_STORAGE_ERROR) &#123;                       <span class="comment">// @3</span></span><br><span class="line">                log.debug(<span class="string">&quot;Error in fetch for partition &#123;&#125;: &#123;&#125;&quot;</span>, tp, error.exceptionName());</span><br><span class="line">            <span class="keyword">this</span>.metadata.requestUpdate();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.UNKNOWN_TOPIC_OR_PARTITION) &#123;          <span class="comment">// @4</span></span><br><span class="line">            log.warn(<span class="string">&quot;Received unknown topic or partition error in fetch for partition &#123;&#125;&quot;</span>, tp);</span><br><span class="line">            <span class="keyword">this</span>.metadata.requestUpdate();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.OFFSET_OUT_OF_RANGE) &#123;                        <span class="comment">// @5</span></span><br><span class="line">            <span class="keyword">if</span> (fetchOffset != subscriptions.position(tp)) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;Discarding stale fetch response for partition &#123;&#125; since the fetched offset &#123;&#125; &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;does not match the current offset &#123;&#125;&quot;</span>, tp, fetchOffset, subscriptions.position(tp));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subscriptions.hasDefaultOffsetResetPolicy()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;Fetch offset &#123;&#125; is out of range for partition &#123;&#125;, resetting offset&quot;</span>, fetchOffset, tp);</span><br><span class="line">                    subscriptions.requestOffsetReset(tp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> OffsetOutOfRangeException(Collections.singletonMap(tp, fetchOffset));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.TOPIC_AUTHORIZATION_FAILED) &#123;             <span class="comment">// @6</span></span><br><span class="line">            log.warn(<span class="string">&quot;Not authorized to read from topic &#123;&#125;.&quot;</span>, tp.topic());</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TopicAuthorizationException(Collections.singleton(tp.topic()));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.UNKNOWN_SERVER_ERROR) &#123;                </span><br><span class="line">            log.warn(<span class="string">&quot;Unknown error fetching data for topic-partition &#123;&#125;&quot;</span>, tp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unexpected error code &quot;</span> + error.code() + <span class="string">&quot; while fetching data&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;   <span class="comment">// @7</span></span><br><span class="line">        <span class="keyword">if</span> (partitionRecords == <span class="keyword">null</span>)</span><br><span class="line">            completedFetch.metricAggregator.record(tp, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (error != Errors.NONE)</span><br><span class="line">           <span class="comment">// we move the partition to the end if there was an error. This way, it&#x27;s more likely that partitions for</span></span><br><span class="line">           <span class="comment">// the same topic can remain together (allowing for more efficient serialization).</span></span><br><span class="line">           subscriptions.movePartitionToEnd(tp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> partitionRecords;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码虽然比较长，其实整体还是比较简单，只是需要针对各种异常处理，打印对应的日志，接下来详细介绍该方法的实现关键点。</p><p>代码@1：判断该分区是否可拉取，如果不可拉取，则忽略这批拉取的消息，判断是可拉取的要点如下：</p><ul><li>当前消费者负载的队列包含该分区。</li><li>当前消费者针对该队列并没有被用户设置为暂停（消费端限流）。</li><li>当前消费者针对该队列有有效的拉取偏移量。</li></ul><p>代码@2：该分支是处理正常返回的相关逻辑。其关键点如下：</p><ul><li>如果当前针对该队列的消费位移 与 发起 fetch 请求时的 偏移量不一致，则认为本次拉取非法，直接返回 null ，如代码@21。</li><li>从返回结构中获取本次拉取的数据，使用数据迭代器，其基本数据单位为 RecordBatch，即一个发送批次，如代码@22。</li><li>如果返回结果中没有包含至少一个批次的消息，但是 sizeInBytes 又大于0，则直接抛出错误，根据服务端的版本，其错误信息有所不同，但主要是建议我们如何处理，如果 broker 的版本低于 0.10.1.0，则建议升级 broker 版本，或增大客户端的 fetch size，这种错误是因为一个批次的消息已经超过了本次拉取允许的最大拉取消息大小，如代码@23。</li><li>依次更新消费者本地关于该队列的订阅缓存信息的 highWatermark、logStartOffset、lastStableOffset。</li></ul><p>从代码@3到@8 是多种异常信息的处理。<br>代码@3：如果出现如下3种错误码，则使用 debug 打印错误日志，并且向服务端请求元数据并更新本地缓存。</p><ul><li>NOT_LEADER_FOR_PARTITION<br>请求的节点上不是该分区的 Leader 分区。</li><li>REPLICA_NOT_AVAILABLE<br>该分区副本之间无法复制</li><li>KAFKA_STORAGE_ERROR<br>存储异常。</li></ul><p>Kafka 认为上述错误是可恢复的，而且对消费不会造成太大影响，故只是用 debug 打印日志，然后更新本地缓存即可。</p><p>代码@4：如果出现 UNKNOWN_TOPIC_OR_PARTITION 未知主题与分区时，则使用 warn 级别输出错误日志，并更新元数据。</p><p>代码@5：针对 OFFSET_OUT_OF_RANGE 偏移量超过范围异常的处理逻辑，其实现关键点如下：</p><ul><li>如果此次拉取的开始偏移量与消费者本地缓存的偏移量不一致，则丢弃，说明该消息已过期，打印错误日志。</li><li>如果此次拉取的开始偏移量与消费者本地缓存的偏移量一致，说明此时的偏移量非法，如果有配置重置偏移量策略，则使用重置偏移量，否则抛出        OffsetOutOfRangeException 错误。</li></ul><p>代码@6：如果是 TOPIC_AUTHORIZATION_FAILED 没有权限(ACL)则抛出异常。</p><p>代码@7：如果本次拉取的结果不是NONE(成功)，并且是可恢复的，将该队列的订阅关系移动到消费者缓存列表的末尾。如果成功，则返回拉取到的分区数据，其封装对象为 PartitionRecords。</p><p>接下来我们再来看看 2.1.1 fetchedRecords 中的另外一个核心方法。</p><h6 id="2-2-1-2-fetchRecords"><a href="#2-2-1-2-fetchRecords" class="headerlink" title="2.2.1.2 fetchRecords()"></a>2.2.1.2 fetchRecords()</h6><p>在介绍该方法之前同样先来看一下参数 PartitionRecords 的内部结构。</p><p>1、PartitionRecords 类图<br><img src="https://img-blog.csdnimg.cn/20191208194302768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>主要的核心属性如下：</p><ul><li>TopicPartition partition<br>分区信息。</li><li>CompletedFetch completedFetch<br>Fetch请求完成结果</li><li>Iterator&lt;? extends RecordBatch&gt; batches<br>本次 Fetch 操作获取的结果集。</li><li>Set&lt; Long&gt; abortedProducerIds<br>与事物相关，后续会专门的章节详细介绍。</li><li>PriorityQueue&lt;FetchResponse.AbortedTransaction&gt; abortedTransactions<br>与事物相关，后续会专门的章节详细介绍。</li><li>int recordsRead<br>已读取的记录条数。</li><li>int bytesRead<br>已读取的记录字节数。</li><li>RecordBatch currentBatch<br>当前遍历的批次。</li><li>Record lastRecord<br>该迭代器最后一条消息。</li><li>long nextFetchOffset<br>下次待拉取的偏移量。</li></ul><p>2、fetchRecords 详解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;ConsumerRecord&lt;K, V&gt;&gt; fetchRecords(PartitionRecords partitionRecords, <span class="keyword">int</span> maxRecords) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!subscriptions.isAssigned(partitionRecords.partition)) &#123;   <span class="comment">// @1</span></span><br><span class="line">            <span class="comment">// this can happen when a rebalance happened before fetched records are returned to the consumer&#x27;s poll call</span></span><br><span class="line">        log.debug(<span class="string">&quot;Not returning fetched records for partition &#123;&#125; since it is no longer assigned&quot;</span>,</span><br><span class="line">                    partitionRecords.partition);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!subscriptions.isFetchable(partitionRecords.partition)) &#123; <span class="comment">// @2</span></span><br><span class="line">        <span class="comment">// this can happen when a partition is paused before fetched records are returned to the consumer&#x27;s</span></span><br><span class="line">        <span class="comment">// poll call or if the offset is being reset</span></span><br><span class="line">        log.debug(<span class="string">&quot;Not returning fetched records for assigned partition &#123;&#125; since it is no longer fetchable&quot;</span>,</span><br><span class="line">                    partitionRecords.partition);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> position = subscriptions.position(partitionRecords.partition);       <span class="comment">// @3</span></span><br><span class="line">        <span class="keyword">if</span> (partitionRecords.nextFetchOffset == position) &#123;      <span class="comment">// @4</span></span><br><span class="line">            List&lt;ConsumerRecord&lt;K, V&gt;&gt; partRecords = partitionRecords.fetchRecords(maxRecords);</span><br><span class="line">            <span class="keyword">long</span> nextOffset = partitionRecords.nextFetchOffset;</span><br><span class="line">            log.trace(<span class="string">&quot;Returning fetched records at offset &#123;&#125; for assigned partition &#123;&#125; and update &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;position to &#123;&#125;&quot;</span>, position, partitionRecords.partition, nextOffset);</span><br><span class="line">            subscriptions.position(partitionRecords.partition, nextOffset);</span><br><span class="line"></span><br><span class="line">            Long partitionLag = subscriptions.partitionLag(partitionRecords.partition, isolationLevel);  </span><br><span class="line">            <span class="keyword">if</span> (partitionLag != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">this</span>.sensors.recordPartitionLag(partitionRecords.partition, partitionLag);</span><br><span class="line"></span><br><span class="line">            Long lead = subscriptions.partitionLead(partitionRecords.partition);</span><br><span class="line">            <span class="keyword">if</span> (lead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.sensors.recordPartitionLead(partitionRecords.partition, lead);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> partRecords;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;   <span class="comment">// @5</span></span><br><span class="line">            <span class="comment">// these records aren&#x27;t next in line based on the last consumed position, ignore them</span></span><br><span class="line">            <span class="comment">// they must be from an obsolete request</span></span><br><span class="line">            log.debug(<span class="string">&quot;Ignoring fetched records for &#123;&#125; at offset &#123;&#125; since the current position is &#123;&#125;&quot;</span>,</span><br><span class="line">                        partitionRecords.partition, partitionRecords.nextFetchOffset, position);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    partitionRecords.drain();</span><br><span class="line">    <span class="keyword">return</span> emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：从 PartitionRecords 中提取消息之前，再次判断订阅消息中是否包含当前分区，如果不包含，则使用 debug 打印日志，很有可能是发生了重平衡。</p><p>代码@2：是否允许拉取，如果用户主动暂停消费，则忽略本次拉取的消息。备注：Kafka 消费端如果消费太快，可以进行限流。</p><p>代码@3：从本地消费者缓存中获取该队列已消费的偏移量，在发送拉取消息时，就是从该偏移量开始拉取的。</p><p>代码@4：如果本地缓存已消费偏移量与从服务端拉回的起始偏移量相等的话，则认为是一个有效拉取，否则则认为是一个过期的拉取，该批消息已被消费，见代码@5。如果是一个有效请求，则使用 sensors 收集统计信息，并返回拉取到的消息， 返回结果被封装在 List&lt;ConsumerRecord&lt;K, V&gt;&gt; 。</p><h5 id="2-2-2-sendFetches"><a href="#2-2-2-sendFetches" class="headerlink" title="2.2.2 sendFetches"></a>2.2.2 sendFetches</h5><p>“发送” fetch 请求，注意这里并不会触发网络操作，而是组装拉取请求，将其放入网络缓存区。</p><p>Fetcher#sendFetches</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">sendFetches</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;Node, FetchSessionHandler.FetchRequestData&gt; fetchRequestMap = prepareFetchRequests();  <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Node, FetchSessionHandler.FetchRequestData&gt; entry : fetchRequestMap.entrySet()) &#123;   <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">final</span> Node fetchTarget = entry.getKey();</span><br><span class="line">        <span class="keyword">final</span> FetchSessionHandler.FetchRequestData data = entry.getValue();</span><br><span class="line">        <span class="keyword">final</span> FetchRequest.Builder request = FetchRequest.Builder</span><br><span class="line">            .forConsumer(<span class="keyword">this</span>.maxWaitMs, <span class="keyword">this</span>.minBytes, data.toSend())</span><br><span class="line">            .isolationLevel(isolationLevel)</span><br><span class="line">            .setMaxBytes(<span class="keyword">this</span>.maxBytes)</span><br><span class="line">            .metadata(data.metadata())</span><br><span class="line">            .toForget(data.toForget());   <span class="comment">// @3</span></span><br><span class="line"> </span><br><span class="line">        client.send(fetchTarget, request)    <span class="comment">// @4</span></span><br><span class="line">            .addListener(<span class="keyword">new</span> RequestFutureListener&lt;ClientResponse&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(ClientResponse resp)</span> </span>&#123;  <span class="comment">// @5</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (Fetcher.<span class="keyword">this</span>) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        FetchResponse&lt;Records&gt; response = (FetchResponse&lt;Records&gt;) resp.responseBody();</span><br><span class="line">                        FetchSessionHandler handler = sessionHandler(fetchTarget.id());</span><br><span class="line">                        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            log.error(<span class="string">&quot;Unable to find FetchSessionHandler for node &#123;&#125;. Ignoring fetch response.&quot;</span>,</span><br><span class="line">                                fetchTarget.id());</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (!handler.handleResponse(response)) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        Set&lt;TopicPartition&gt; partitions = <span class="keyword">new</span> HashSet&lt;&gt;(response.responseData().keySet());</span><br><span class="line">                        FetchResponseMetricAggregator metricAggregator = <span class="keyword">new</span> FetchResponseMetricAggregator(sensors, partitions);</span><br><span class="line">                        <span class="keyword">for</span> (Map.Entry&lt;TopicPartition, FetchResponse.PartitionData&lt;Records&gt;&gt; entry : </span><br><span class="line">                                 response.responseData().entrySet()) &#123;</span><br><span class="line">                            TopicPartition partition = entry.getKey();</span><br><span class="line">                            <span class="keyword">long</span> fetchOffset = data.sessionPartitions().get(partition).fetchOffset;</span><br><span class="line">                            FetchResponse.PartitionData&lt;Records&gt; fetchData = entry.getValue();</span><br><span class="line">                            completedFetches.add(<span class="keyword">new</span> CompletedFetch(partition, fetchOffset, fetchData, metricAggregator,</span><br><span class="line">                                resp.requestHeader().apiVersion()));</span><br><span class="line">                            &#125;    <span class="comment">// @6</span></span><br><span class="line"></span><br><span class="line">                            sensors.fetchLatency.record(resp.requestLatencyMs());</span><br><span class="line">                        &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(RuntimeException e)</span> </span>&#123;  <span class="comment">// @7</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (Fetcher.<span class="keyword">this</span>) &#123;</span><br><span class="line">                        FetchSessionHandler handler = sessionHandler(fetchTarget.id());</span><br><span class="line">                        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            handler.handleError(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fetchRequestMap.size();</span><br><span class="line">&#125;</span><br><span class="line">​~~~java</span><br><span class="line">上面的方法比较长，其实现的关键点如下：</span><br><span class="line">代码@<span class="number">1</span>：通过调用 Fetcher 的 prepareFetchRequests 方法按节点组装拉取请求，将在后面详细介绍。</span><br><span class="line"></span><br><span class="line">代码@<span class="number">2</span>：遍历上面的待发请求，进一步组装请求。下面就是分节点发送拉取请求。</span><br><span class="line"></span><br><span class="line">代码@<span class="number">3</span>：构建 FetchRequest 拉取请求对象。</span><br><span class="line"></span><br><span class="line">代码@<span class="number">4</span>：调用 NetworkClient 的 send 方法将其发送到发送缓存区，本文不会详细介绍网络方面的实现，但下文会截图说明拉取请求发送缓存区的一个关键点。</span><br><span class="line"></span><br><span class="line">代码@<span class="number">5</span>：这里会注册事件监听器，当消息从 broker 拉取到本地后触发回调，即消息拉取请求收到返回结果后会将返回结果放入到completedFetches 中（代码@<span class="number">6</span>），这就和上文消息拉取时 Fetcher 的 fetchedRecords 方法形成闭环。</span><br><span class="line">代码@<span class="number">7</span>：消息拉取一次处理。</span><br><span class="line"></span><br><span class="line">接下来详细介绍 prepareFetchRequests 方法。</span><br><span class="line"></span><br><span class="line">###### 2.2.2.1 Fetcher prepareFetchRequests 方法详解</span><br><span class="line">​~~~java</span><br><span class="line"><span class="keyword">private</span> Map&lt;Node, FetchSessionHandler.FetchRequestData&gt; prepareFetchRequests() &#123;</span><br><span class="line">    Map&lt;Node, FetchSessionHandler.Builder&gt; fetchable = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();  </span><br><span class="line">    <span class="keyword">for</span> (TopicPartition partition : fetchablePartitions()) &#123;    <span class="comment">// @1</span></span><br><span class="line">        Node node = metadata.partitionInfoIfCurrent(partition).map(PartitionInfo::leader).orElse(<span class="keyword">null</span>);  <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;    <span class="comment">// @3</span></span><br><span class="line">            metadata.requestUpdate();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (client.isUnavailable(node)) &#123;   <span class="comment">// @4</span></span><br><span class="line">           client.maybeThrowAuthFailure(node);</span><br><span class="line">           log.trace(<span class="string">&quot;Skipping fetch for partition &#123;&#125; because node &#123;&#125; is awaiting reconnect backoff&quot;</span>, partition, node);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (client.hasPendingRequests(node)) &#123;   <span class="comment">// @5</span></span><br><span class="line">            log.trace(<span class="string">&quot;Skipping fetch for partition &#123;&#125; because there is an in-flight request to &#123;&#125;&quot;</span>, partition, node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// if there is a leader and no in-flight requests, issue a new fetch</span></span><br><span class="line">            FetchSessionHandler.Builder builder = fetchable.get(node);    <span class="comment">// @7</span></span><br><span class="line">            <span class="keyword">if</span> (builder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                FetchSessionHandler handler = sessionHandler(node.id());</span><br><span class="line">                <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    handler = <span class="keyword">new</span> FetchSessionHandler(logContext, node.id());</span><br><span class="line">                    sessionHandlers.put(node.id(), handler);</span><br><span class="line">                &#125;</span><br><span class="line">                builder = handler.newBuilder();</span><br><span class="line">                fetchable.put(node, builder);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> position = <span class="keyword">this</span>.subscriptions.position(partition);</span><br><span class="line">            builder.add(partition, <span class="keyword">new</span> FetchRequest.PartitionData(position, FetchRequest.INVALID_LOG_START_OFFSET,</span><br><span class="line">            <span class="keyword">this</span>.fetchSize, Optional.empty()));</span><br><span class="line">            log.debug(<span class="string">&quot;Added &#123;&#125; fetch request for partition &#123;&#125; at offset &#123;&#125; to node &#123;&#125;&quot;</span>, isolationLevel,</span><br><span class="line">                    partition, position, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Node, FetchSessionHandler.FetchRequestData&gt; reqs = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();  </span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Node, FetchSessionHandler.Builder&gt; entry : fetchable.entrySet()) &#123;</span><br><span class="line">        reqs.put(entry.getKey(), entry.getValue().build());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reqs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先通过调用 fetchablePartitions() 获取可发起拉取任务的分区信息，下文简单介绍一下。</p><p>代码@2：如果该分区在客户端本地缓存中获取该分区的 Leader 节点信息。</p><p>代码@3：如果其 Leader 节点信息为空，则发起更新元数据请求，本次拉取任务将不会包含该分区。</p><p>代码@4：如果客户端与该分区的 Leader 连接为完成，如果是因为权限的原因则抛出ACL相关异常，否则打印日志，本次拉取请求不会包含该分区。</p><p>代码@5：判断该节点是否有挂起的拉取请求，即发送缓存区中是待发送的请求,如果有，本次将不会被拉取。</p><p>代码@6：构建拉取请求，分节点组织请求。</p><h6 id="2-2-2-2-NetworkClient-send-方法关键点"><a href="#2-2-2-2-NetworkClient-send-方法关键点" class="headerlink" title="2.2.2.2 NetworkClient send 方法关键点"></a>2.2.2.2 NetworkClient send 方法关键点</h6><p><img src="https://img-blog.csdnimg.cn/2019120819462738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>NetworkClient 的 send 方法只是将其放入 unsent 中。<br><img src="https://img-blog.csdnimg.cn/20191208194637842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>与上文的 client.hasPendingRequests(node) 方法遥相呼应。</p><p>3、总结<br>上面的源码分析有点长，也有点枯燥，我们还是画一张流程图来进行总结。<br><img src="https://img-blog.csdnimg.cn/20191208194720402.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191208194726675.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Kafka 的消息拉取流程还是比较复杂的，后面会基于上述流程，重点进行拆解，例如消费进度提交，负载队列重平衡等等。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;１、KafkaConsumer-poll-详解&quot;&gt;&lt;a href=&quot;#１、KafkaConsumer-poll-详解&quot; class=&quot;headerlink&quot; title=&quot;１、KafkaConsumer poll 详解&quot;&gt;&lt;/a&gt;１、KafkaConsumer poll 详解&lt;/h2&gt;&lt;p&gt;消息拉起主要入口为：KafkaConsumer#poll方法，其声明如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; ConsumerRecords&amp;lt;K, V&amp;gt; &lt;span class=&quot;title&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Duration timeout)&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;span class=&quot;comment&quot;&gt;// @1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; poll(time.timer(timeout), &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);                                     &lt;span class=&quot;comment&quot;&gt;// @2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码＠１：参数为超时时间，使用 java 的 Duration 来定义。&lt;br&gt;代码＠２：调用内部的 poll 方法。&lt;/p&gt;
&lt;p&gt;KafkaConsumer#poll&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; ConsumerRecords&amp;lt;K, V&amp;gt; &lt;span class=&quot;title&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Timer timer, &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; includeMetadataInTimeout)&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;span class=&quot;comment&quot;&gt;// @1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    acquireAndEnsureOpen();                                                                                                               &lt;span class=&quot;comment&quot;&gt;// @2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.subscriptions.hasNoSubscriptionOrUserAssignment()) &amp;#123;                                                  &lt;span class=&quot;comment&quot;&gt;// @3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalStateException(&lt;span class=&quot;string&quot;&gt;&amp;quot;Consumer is not subscribed to any topics or assigned any partitions&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// poll for new data until the timeout expires&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;span class=&quot;comment&quot;&gt;// @4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            client.maybeTriggerWakeup();                                                                                               &lt;span class=&quot;comment&quot;&gt;//@5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (includeMetadataInTimeout) &amp;#123;                       　　　　　　　　　　　　　　　　　　　 &lt;span class=&quot;comment&quot;&gt;// @6 　　　　　　　　　　　　　　　　　　　　                                                          &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!updateAssignmentMetadataIfNeeded(timer)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ConsumerRecords.empty();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (!updateAssignmentMetadataIfNeeded(time.timer(Long.MAX_VALUE))) &amp;#123;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    log.warn(&lt;span class=&quot;string&quot;&gt;&amp;quot;Still waiting for metadata&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Map&amp;lt;TopicPartition, List&amp;lt;ConsumerRecord&amp;lt;K, V&amp;gt;&amp;gt;&amp;gt; records = pollForFetches(timer);   &lt;span class=&quot;comment&quot;&gt;// @7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!records.isEmpty()) &amp;#123;                                                                                                           &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (fetcher.sendFetches() &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; || client.hasPendingRequests()) &amp;#123;                                           &lt;span class=&quot;comment&quot;&gt;// @8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    client.pollNoWakeup();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.interceptors.onConsume(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ConsumerRecords&amp;lt;&amp;gt;(records));                         &lt;span class=&quot;comment&quot;&gt;// @９&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (timer.notExpired());                                                                                                         &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ConsumerRecords.empty();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        release();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码＠１：首先先对其参数含义进行讲解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;boolean includeMetadataInTimeout&lt;br&gt;拉取消息的超时时间是否包含更新元数据的时间，默认为true，即包含。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码＠２：检查是否可以拉取消息，其主要判断依据如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;KafkaConsumer 是否有其他线程再执行，如果有，则抛出异常，因为 - KafkaConsumer 是线程不安全的，同一时间只能一个线程执行。&lt;/li&gt;
&lt;li&gt;KafkaConsumer 没有被关闭。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码＠３：如果当前消费者未订阅任何主题或者没有指定队列，则抛出错误，结束本次消息拉取。&lt;/p&gt;
&lt;p&gt;代码＠４：使用 do while 结构循环拉取消息，直到超时或拉取到消息。&lt;/p&gt;
&lt;p&gt;代码＠５：避免在禁止禁用wakeup时，有请求想唤醒时则抛出异常，例如在下面的@8时，会禁用wakeup。&lt;/p&gt;
&lt;p&gt;代码＠６：更新相关元数据，为真正向 broker 发送消息拉取请求做好准备，该方法将在下面详细介绍，现在先简单介绍其核心实现点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如有必要，先向 broker 端拉取最新的订阅信息(包含消费组内的在线的消费客户端)。&lt;/li&gt;
&lt;li&gt;执行已完成(异步提交)的 offset 提交请求的回调函数。&lt;/li&gt;
&lt;li&gt;维护与 broker 端的心跳请求，确保不会被“踢出”消费组。&lt;/li&gt;
&lt;li&gt;更新元信息。&lt;/li&gt;
&lt;li&gt;如果是自动提交消费偏移量，则自动提交偏移量。&lt;/li&gt;
&lt;li&gt;更新各个分区下次待拉取的偏移量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里会有一个更新元数据是否占用消息拉取的超时时间，默认为 true。&lt;/p&gt;
&lt;p&gt;代码＠７：调用 pollForFetches 向broker拉取消息，该方法将在下文详细介绍。&lt;/p&gt;
&lt;p&gt;代码＠８：如果拉取到的消息集合不为空，再返回该批消息之前，如果还有挤压的拉取请求，可以继续发送拉取请求，但此时会禁用warkup，主要的目的是用户在处理消息时，KafkaConsumer 还可以继续向broker 拉取消息。&lt;/p&gt;
&lt;p&gt;代码＠９：执行消费拦截器。&lt;/p&gt;
&lt;p&gt;接下来对上文提到的代码＠６、＠７进行详细介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="kafka" scheme="http://example.com/categories/kafka/"/>
    
    
    <category term="kafka" scheme="http://example.com/tags/kafka/"/>
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="消息拉取" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>初始 Kafka Consumer 消费者</title>
    <link href="http://example.com/posts/d9d4c345.html"/>
    <id>http://example.com/posts/d9d4c345.html</id>
    <published>2020-12-11T15:18:01.000Z</published>
    <updated>2020-12-11T15:22:06.439Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="1、KafkaConsumer-概述"><a href="#1、KafkaConsumer-概述" class="headerlink" title="1、KafkaConsumer 概述"></a>1、KafkaConsumer 概述</h2><p>根据 KafkaConsumer 类上的注释上来看 KafkaConsumer 具有如下特征：</p><ul><li><p>在 Kafka 中 KafkaConsumer 是线程不安全的。</p></li><li><p>2.2.1 版本的KafkaConsumer 兼容 kafka 0.10.0 和 0.11.0 等低版本。</p></li><li><p>消息偏移量与消费偏移量(消息消费进度)<br>Kafka 为分区中的每一条消息维护一个偏移量，即消息偏移量。这个偏移量充当该分区内记录的唯一标识符。消费偏移量(消息消费进度)存储的是消费组当前的处理进度。消息消费进度的提交在 kafka 中可以定时自动提交也可以手动提交。手动提交可以调用 ommitSync() 或 commitAsync 方法。</p></li><li><p>消费组 与 订阅关系<br>多个消费这可以同属于一个消费组，消费组内的所有消费者共同消费主题下的所有消息。一个消费组可以订阅多个主题。</p></li><li><p>队列负载机制<br>既然同一个消费组内的消费者共同承担主题下所有队列的消费，那他们如何进行分工呢？默认情况下采取平均分配，例如一个消费组有两个消费者c1、c2，一个 topic 的分区数为6，那 c1 会负责3个分区的消费，同样 c2 会负责另外3个分区的分配。</p><p>那如果其中一个消费者宕机或新增一个消费者，那队列能动态调整吗？</p><p>答案是会重新再次平衡，例如如果新增一个消费者 c3，则c1,c2,c3都会负责2个分区的消息消费，分区重平衡会在后续文章中重点介绍。消费者也可以通过 assign 方法手动指定分区，此时会禁用默认的自动分配机制。</p></li><li><p>消费者故障检测机制<br>当通过 subscribe 方法订阅某些主题时，此时该消费者还未真正加入到订阅组，只有当 consumeer#poll 方法被调用后，并且会向 broker 定时发送心跳包，如果 broker 在 session.timeout.ms 时间内未收到心跳包，则 broker 会任务该消费者已宕机，会将其剔除，并触发消费端的分区重平衡。</p><p>消费者也有可能遇到“活体锁”的情况，即它继续发送心跳，但没有任何进展。在这种情况下，为了防止消费者无限期地占用它的分区，可以使用max.poll.interval.ms 设置提供了一个活性检测机制。基本上，如果您调用轮询的频率低于配置的最大间隔，那么客户机将主动离开组，以便另一个消费者可以接管它的分区。当这种情况发生时,您可能会看到一个偏移提交失败(由调用{@link #commitSync()}抛出的{@link CommitFailedException}表示)。</p></li><li><p>kafka 对 poll loop 行为的控制参数<br>Kafka 提供了如下两个参数来控制 poll 的行为：</p><ul><li> max.poll.interval.ms<br>允许 两次调用 poll 方法的最大间隔，即设置每一批任务最大的处理时间。</li><li> max.poll.records<br>每一次 poll 最大拉取的消息条数。</li></ul><p>对于消息处理时间不可预测的情况下上述两个参数可能不够用，那将如何是好呢？</p><p>通常的建议将消息拉取与消息消费分开，一个线程负责 poll 消息，处理这些消息使用另外的线程，这里就需要手动提交消费进度。为了控制消息拉起的过快，您可能会需要用到 Consumer#pause(Collection) 方法，暂时停止向该分区拉起消息。RocketMQ 的推模式就是采用了这种策略。如果大家有兴趣的话，可以从笔者所著的《RocketMQ技术内幕》一书中详细了解。</p></li></ul><a id="more"></a><h2 id="2、KafkaConsume-使用示例"><a href="#2、KafkaConsume-使用示例" class="headerlink" title="2、KafkaConsume 使用示例"></a>2、KafkaConsume 使用示例</h2><h3 id="2-1-自动提交消费进度"><a href="#2-1-自动提交消费进度" class="headerlink" title="2.1 自动提交消费进度"></a>2.1 自动提交消费进度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testConsumer1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    props.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092,localhost:9082,localhost:9072&quot;</span>);</span><br><span class="line">    props.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;C_ODS_ORDERCONSUME_01&quot;</span>);</span><br><span class="line">    props.setProperty(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    props.setProperty(<span class="string">&quot;auto.commit.interval.ms&quot;</span>, <span class="string">&quot;1000&quot;</span>);</span><br><span class="line">    props.setProperty(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    props.setProperty(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">    consumer.subscribe(Arrays.asList(<span class="string">&quot;TOPIC_ORDER&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt;  records = consumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费中&quot;</span>);</span><br><span class="line">            System.out.printf(<span class="string">&quot;offset = %d, key = %s, value = %s%n&quot;</span>, record.offset(), record.key(), record.value());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-手动提交消费进度"><a href="#2-2-手动提交消费进度" class="headerlink" title="2.2 手动提交消费进度"></a>2.2 手动提交消费进度</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testConsumer2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">        consumer.subscribe(Arrays.asList(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>));</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> minBatchSize = <span class="number">200</span>;</span><br><span class="line">        List&lt;ConsumerRecord&lt;String, String&gt;&gt; buffer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                buffer.add(record);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (buffer.size() &gt;= minBatchSize) &#123;</span><br><span class="line">                <span class="comment">// insertIntoDb(buffer);</span></span><br><span class="line">                <span class="comment">// 省略处理逻辑</span></span><br><span class="line">                consumer.commitSync();</span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3、认识-Consumer-接口"><a href="#3、认识-Consumer-接口" class="headerlink" title="3、认识 Consumer 接口"></a>3、认识 Consumer 接口</h2><p>要认识 Kafka 的消费者，个人认为最好的办法就是从它的类图着手，下面给出 Consumer 接口的类图。<br><img src="https://img-blog.csdnimg.cn/20191124101227865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来对起重点方法进行一个初步的介绍，从下篇文章开始将对其进行详细设计。</p><ul><li>Set&lt; TopicPartition&gt; assignment()<br>获取该消费者的队列分配列表。</li><li>Set&lt; String&gt; subscription()<br>获取该消费者的订阅信息。</li><li>void subscribe(Collection&lt; String&gt; topics)<br>订阅主题。</li><li>void subscribe(Collection&lt; String&gt; topics, ConsumerRebalanceListener callback)<br>订阅主题，并指定队列重平衡的监听器。</li><li>void assign(Collection&lt; TopicPartition&gt; partitions)<br>取代 subscription，手动指定消费哪些队列。</li><li>void unsubscribe()<br>取消订阅关系。</li><li>ConsumerRecords&lt;K, V&gt; poll(Duration timeout)<br>拉取消息，是 KafkaConsumer 的核心方法，将在下文详细介绍。</li><li>void commitSync()<br>同步提交消费进度，为本批次的消费提交，将在后续文章中详细介绍。</li><li>void commitSync(Duration timeout)<br>同步提交消费进度，可设置超时时间。</li><li>void commitSync(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets)<br>显示同步提交消费进度， offsets 指明需要提交消费进度的信息。</li><li>void commitSync(final Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, final Duration timeout)<br>显示同步提交消费进度，带超时间。</li><li>void seek(TopicPartition partition, long offset)<br>重置 consumer#poll 方法下一次拉消息的偏移量。</li><li>void seek(TopicPartition partition, OffsetAndMetadata offsetAndMetadata)<br>seek 方法重载方法。</li><li>void seekToBeginning(Collection&lt; TopicPartition&gt; partitions)<br>将 poll 方法下一次的拉取偏移量设置为队列的初始偏移量。</li><li>void seekToEnd(Collection&lt; TopicPartition&gt; partitions)<br>将 poll 方法下一次的拉取偏移量设置为队列的最大偏移量。</li><li>long position(TopicPartition partition)<br>获取将被拉取的偏移量。</li><li>long position(TopicPartition partition, final Duration timeout)<br>同上。</li><li>OffsetAndMetadata committed(TopicPartition partition)<br>获取指定分区已提交的偏移量。</li><li>OffsetAndMetadata committed(TopicPartition partition, final Duration timeout)<br>同上。</li><li>Map&lt;MetricName, ? extends Metric&gt; metrics()<br>统计指标。</li><li>List&lt; PartitionInfo&gt; partitionsFor(String topic)<br>获取主题的路由信息。</li><li>List&lt; PartitionInfo&gt; partitionsFor(String topic, Duration timeout)<br>同上。</li><li>Map&lt;String, List&lt; PartitionInfo&gt;&gt; listTopics()<br>获取所有 topic 的路由信息。</li><li>Map&lt;String, List&lt; PartitionInfo&gt;&gt; listTopics(Duration timeout)<br>同上。</li><li>Set&lt; TopicPartition&gt; paused()<br>获取已挂起的分区信息。</li><li>void pause(Collection&lt; TopicPartition&gt; partitions)<br>挂起分区，下一次 poll 方法将不会返回这些分区的消息。</li><li>void resume(Collection&lt; TopicPartition&gt; partitions)<br>恢复挂起的分区。</li><li>Map&lt;TopicPartition, OffsetAndTimestamp&gt; offsetsForTimes(Map&lt;TopicPartition, Long&gt; timestampsToSearch)<br>根据时间戳查找最近的一条消息的偏移量。</li><li>Map&lt;TopicPartition, OffsetAndTimestamp&gt; offsetsForTimes(Map&lt;TopicPartition, Long&gt; timestampsToSearch, Duration timeout)<br>同上。</li><li>Map&lt;TopicPartition, Long&gt; beginningOffsets(Collection&lt; TopicPartition&gt; partitions)<br>查询指定分区当前最小的偏移量。</li><li>Map&lt;TopicPartition, Long&gt; beginningOffsets(Collection&lt; TopicPartition&gt; partitions, Duration timeout)<br>同上。</li><li>Map&lt;TopicPartition, Long&gt; endOffsets(Collection&lt; TopicPartition&gt; partitions)<br>查询指定分区当前最大的偏移量。</li><li>Map&lt;TopicPartition, Long&gt; endOffsets(Collection&lt; TopicPartition&gt; partitions, Duration timeout)<br>同上。</li><li>void close()<br>关闭消费者。</li><li>void close(Duration timeout)<br>关闭消费者。</li><li>void wakeup()<br>唤醒消费者。</li></ul><h2 id="4、初始-KafkaConsumer"><a href="#4、初始-KafkaConsumer" class="headerlink" title="4、初始 KafkaConsumer"></a>4、初始 KafkaConsumer</h2><p><img src="https://img-blog.csdnimg.cn/20191124122831676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来笔者根据其构造函数，对一一介绍其核心属性的含义，为接下来讲解其核心方法打下基础。</p><ul><li>String groupId<br>消费组ID。同一个消费组内的多个消费者共同消费一个主题下的消息。</li><li>String clientId<br>发出请求时传递给服务器的id字符串。设置该值的目的是方便在服务器端请求日志中包含逻辑应用程序名称，从而能够跟踪ip/端口之外的请求源。该值可以设置为应用名称。</li><li>ConsumerCoordinator coordinator<br>消费协调器，后续会详细介绍。</li><li>Deserializer&lt; K&gt; keyDeserializer<br>key 序列化器。</li><li>Deserializer&lt; V&gt; valueDeserializer<br>值序列化器。</li><li>ConsumerNetworkClient client<br>网络通讯客户端。</li><li>SubscriptionState subscriptions<br>用于管理订阅状态的类，用于跟踪 topics, partitions, offsets 等信息。后续会详细介绍。</li><li>ConsumerMetadata metadata<br>消费者元数据信息，包含路由信息。</li><li>long retryBackoffMs<br>如果向 broker 发送请求失败后，发起重试之前需要等待的间隔时间，通过属性 retry.backoff.ms　指定。</li><li>long requestTimeoutMs<br>一次请求的超时时间。</li><li>int defaultApiTimeoutMs<br>为所有可能阻塞的API设置一个默认的超时时间。</li><li>List&lt; PartitionAssignor&gt; assignors<br>分区分配算法（分区负载算法）。</li></ul><p>Kafka Consumer 消费者就介绍到这里了，从下篇文章开始将开始详细介绍 Kafka 关于消息消费的方方面面。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1、KafkaConsumer-概述&quot;&gt;&lt;a href=&quot;#1、KafkaConsumer-概述&quot; class=&quot;headerlink&quot; title=&quot;1、KafkaConsumer 概述&quot;&gt;&lt;/a&gt;1、KafkaConsumer 概述&lt;/h2&gt;&lt;p&gt;根据 KafkaConsumer 类上的注释上来看 KafkaConsumer 具有如下特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在 Kafka 中 KafkaConsumer 是线程不安全的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2.2.1 版本的KafkaConsumer 兼容 kafka 0.10.0 和 0.11.0 等低版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消息偏移量与消费偏移量(消息消费进度)&lt;br&gt;Kafka 为分区中的每一条消息维护一个偏移量，即消息偏移量。这个偏移量充当该分区内记录的唯一标识符。消费偏移量(消息消费进度)存储的是消费组当前的处理进度。消息消费进度的提交在 kafka 中可以定时自动提交也可以手动提交。手动提交可以调用 ommitSync() 或 commitAsync 方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消费组 与 订阅关系&lt;br&gt;多个消费这可以同属于一个消费组，消费组内的所有消费者共同消费主题下的所有消息。一个消费组可以订阅多个主题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;队列负载机制&lt;br&gt;既然同一个消费组内的消费者共同承担主题下所有队列的消费，那他们如何进行分工呢？默认情况下采取平均分配，例如一个消费组有两个消费者c1、c2，一个 topic 的分区数为6，那 c1 会负责3个分区的消费，同样 c2 会负责另外3个分区的分配。&lt;/p&gt;
&lt;p&gt;那如果其中一个消费者宕机或新增一个消费者，那队列能动态调整吗？&lt;/p&gt;
&lt;p&gt;答案是会重新再次平衡，例如如果新增一个消费者 c3，则c1,c2,c3都会负责2个分区的消息消费，分区重平衡会在后续文章中重点介绍。消费者也可以通过 assign 方法手动指定分区，此时会禁用默认的自动分配机制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消费者故障检测机制&lt;br&gt;当通过 subscribe 方法订阅某些主题时，此时该消费者还未真正加入到订阅组，只有当 consumeer#poll 方法被调用后，并且会向 broker 定时发送心跳包，如果 broker 在 session.timeout.ms 时间内未收到心跳包，则 broker 会任务该消费者已宕机，会将其剔除，并触发消费端的分区重平衡。&lt;/p&gt;
&lt;p&gt;消费者也有可能遇到“活体锁”的情况，即它继续发送心跳，但没有任何进展。在这种情况下，为了防止消费者无限期地占用它的分区，可以使用max.poll.interval.ms 设置提供了一个活性检测机制。基本上，如果您调用轮询的频率低于配置的最大间隔，那么客户机将主动离开组，以便另一个消费者可以接管它的分区。当这种情况发生时,您可能会看到一个偏移提交失败(由调用{@link #commitSync()}抛出的{@link CommitFailedException}表示)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;kafka 对 poll loop 行为的控制参数&lt;br&gt;Kafka 提供了如下两个参数来控制 poll 的行为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; max.poll.interval.ms&lt;br&gt;允许 两次调用 poll 方法的最大间隔，即设置每一批任务最大的处理时间。&lt;/li&gt;
&lt;li&gt; max.poll.records&lt;br&gt;每一次 poll 最大拉取的消息条数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于消息处理时间不可预测的情况下上述两个参数可能不够用，那将如何是好呢？&lt;/p&gt;
&lt;p&gt;通常的建议将消息拉取与消息消费分开，一个线程负责 poll 消息，处理这些消息使用另外的线程，这里就需要手动提交消费进度。为了控制消息拉起的过快，您可能会需要用到 Consumer#pause(Collection) 方法，暂时停止向该分区拉起消息。RocketMQ 的推模式就是采用了这种策略。如果大家有兴趣的话，可以从笔者所著的《RocketMQ技术内幕》一书中详细了解。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="kafka" scheme="http://example.com/categories/kafka/"/>
    
    
    <category term="kafka" scheme="http://example.com/tags/kafka/"/>
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="KafkaConsumer" scheme="http://example.com/tags/KafkaConsumer/"/>
    
  </entry>
  
  <entry>
    <title>KafkaProducer Sender 线程详解（含详细的执行流程图）</title>
    <link href="http://example.com/posts/80780dfa.html"/>
    <id>http://example.com/posts/80780dfa.html</id>
    <published>2020-12-11T15:16:01.000Z</published>
    <updated>2020-12-11T15:22:06.435Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>上文 <a href="https://blog.csdn.net/prestigeding/article/details/102994716">《源码分析 Kafka 消息发送流程》</a> 已经详细介绍了 KafkaProducer send 方法的流程，该方法只是将消息追加到 KafKaProducer 的缓存中，并未真正的向 broker 发送消息，本文将来探讨 Kafka 的 Sender 线程。</p><p>在 KafkaProducer 中会启动一个单独的线程，其名称为 “kafka-producer-network-thread | clientID”，其中 clientID 为生产者的 id 。</p><h2 id="1、Sender-线程详解"><a href="#1、Sender-线程详解" class="headerlink" title="1、Sender 线程详解"></a>1、Sender 线程详解</h2><h4 id="1-1-类图"><a href="#1-1-类图" class="headerlink" title="1.1 类图"></a>1.1 类图</h4><p><img src="https://img-blog.csdnimg.cn/20191117174420482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们先来看一下其各个属性的含义：</p><ul><li>KafkaClient client<br>kafka 网络通信客户端，主要封装与 broker 的网络通信。</li><li>RecordAccumulator accumulator<br>消息记录累积器，消息追加的入口(RecordAccumulator 的 append 方法)。</li><li>Metadata metadata<br>元数据管理器，即 topic 的路由分区信息。</li><li>boolean guaranteeMessageOrder<br>是否需要保证消息的顺序性。</li><li>int maxRequestSize<br>调用 send 方法发送的最大请求大小，包括 key、消息体序列化后的消息总大小不能超过该值。通过参数 max.request.size 来设置。</li><li>short acks<br>用来定义消息“已提交”的条件(标准)，就是 Broker 端向客户端承偌已提交的条件，可选值如下0、-1、1.</li><li>int retries<br>重试次数。</li><li>Time time<br>时间工具类。</li><li>boolean running<br>该线程状态，为 true 表示运行中。</li><li>boolean forceClose<br>是否强制关闭，此时会忽略正在发送中的消息。</li><li>SenderMetrics sensors<br>消息发送相关的统计指标收集器。</li><li>int requestTimeoutMs<br>请求的超时时间。</li><li>long retryBackoffMs<br>请求失败之在重试之前等待的时间。</li><li>ApiVersions apiVersions<br>API版本信息。</li><li>TransactionManager transactionManager<br>事务处理器。</li><li>Map&lt; TopicPartition, List&lt; ProducerBatch&gt;&gt; inFlightBatches<br>正在执行发送相关的消息批次。</li></ul><a id="more"></a><h4 id="1-2-run-方法详解"><a href="#1-2-run-方法详解" class="headerlink" title="1.2 run 方法详解"></a>1.2 run 方法详解</h4><p>Sender#run</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.debug(<span class="string">&quot;Starting Kafka producer I/O thread.&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (running) &#123;   </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runOnce();    <span class="comment">// @1</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Uncaught error in kafka producer I/O thread: &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.debug(<span class="string">&quot;Beginning shutdown of Kafka producer I/O thread, sending remaining records.&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!forceClose &amp;&amp; (<span class="keyword">this</span>.accumulator.hasUndrained() || <span class="keyword">this</span>.client.inFlightRequestCount() &gt; <span class="number">0</span>)) &#123;    <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runOnce();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Uncaught error in kafka producer I/O thread: &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (forceClose) &#123;                                                                                                                                     <span class="comment">// @3</span></span><br><span class="line">        log.debug(<span class="string">&quot;Aborting incomplete batches due to forced shutdown&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.accumulator.abortIncompleteBatches();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.client.close();                                                                                                                               <span class="comment">// @4</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Failed to close network client&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    log.debug(<span class="string">&quot;Shutdown of Kafka producer I/O thread has completed.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：Sender 线程在运行状态下主要的业务处理方法，将消息缓存区中的消息向 broker 发送。<br>代码@2：如果主动关闭 Sender 线程，如果不是强制关闭，则如果缓存区还有消息待发送，再次调用 runOnce 方法将剩余的消息发送完毕后再退出。<br>代码@3：如果强制关闭 Sender 线程，则拒绝未完成提交的消息。<br>代码@4：关闭 Kafka Client 即网络通信对象。</p><p>接下来将分别探讨其上述方法的实现细节。</p><h5 id="1-2-1-runOnce-详解"><a href="#1-2-1-runOnce-详解" class="headerlink" title="1.2.1 runOnce 详解"></a>1.2.1 runOnce 详解</h5><p>Sender#runOnce</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 此处省略与事务消息相关的逻辑</span></span><br><span class="line">    <span class="keyword">long</span> currentTimeMs = time.milliseconds();</span><br><span class="line">    <span class="keyword">long</span> pollTimeout = sendProducerData(currentTimeMs);   <span class="comment">// @1</span></span><br><span class="line">    client.poll(pollTimeout, currentTimeMs);                            <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文不关注事务消息的实现原理，故省略了该部分的代码。<br>代码@1：调用 sendProducerData 方法发送消息。<br>代码@2：调用这个方法的作用？</p><p>接下来分别对上述两个方法进行深入探究。</p><h6 id="1-1-2-1-sendProducerData"><a href="#1-1-2-1-sendProducerData" class="headerlink" title="1.1.2.1 sendProducerData"></a>1.1.2.1 sendProducerData</h6><p>接下来将详细分析其实现步骤。<br>Sender#sendProducerData</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cluster cluster = metadata.fetch();</span><br><span class="line"><span class="comment">// get the list of partitions with data ready to send</span></span><br><span class="line">RecordAccumulator.ReadyCheckResult result = <span class="keyword">this</span>.accumulator.ready(cluster, now);</span><br></pre></td></tr></table></figure><p>Step1：首先根据当前时间，根据缓存队列中的数据判断哪些 topic 的 哪些分区已经达到发送条件。达到可发送的条件将在 2.1.1.1 节详细分析。</p><p>Sender#sendProducerData</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!result.unknownLeaderTopics.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (String topic : result.unknownLeaderTopics)</span><br><span class="line">        <span class="keyword">this</span>.metadata.add(topic);</span><br><span class="line">    </span><br><span class="line">    log.debug(<span class="string">&quot;Requesting metadata update due to unknown leader topics from the batched records: &#123;&#125;&quot;</span>,</span><br><span class="line">                result.unknownLeaderTopics);</span><br><span class="line">    <span class="keyword">this</span>.metadata.requestUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step2：如果在待发送的消息未找到其路由信息，则需要首先去 broker 服务器拉取对应的路由信息(分区的 leader 节点信息)。</p><p>Sender#sendProducerData</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> notReadyTimeout = Long.MAX_VALUE;</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    Node node = iter.next();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.client.ready(node, now)) &#123;</span><br><span class="line">        iter.remove();</span><br><span class="line">        notReadyTimeout = Math.min(notReadyTimeout, <span class="keyword">this</span>.client.pollDelayMs(node, now));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step3：移除在网络层面没有准备好的分区，并且计算在接下来多久的时间间隔内，该分区都将处于未准备状态。<br>1、在网络环节没有准备好的标准如下：</p><ul><li>分区没有未完成的更新元素数据请求(metadata)。</li><li>当前生产者与对端 broker 已建立连接并完成了 TCP 的三次握手。</li><li>如果启用 SSL、ACL 等机制，相关状态都已就绪。</li><li>该分区对应的连接正在处理中的请求数时是否超过设定值，默认为 5，可通过属性 max.in.flight.requests.per.connection 来设置。</li></ul><p>2、client pollDelayMs 预估分区在接下来多久的时间间隔内都将处于未转变好状态(not ready)，其标准如下：</p><ul><li>如果已与对端的 TCP 连接已创建好，并处于已连接状态，此时如果没有触发限流，则返回0，如果有触发限流，则返回限流等待时间。</li><li>如果还位于对端建立 TCP 连接，则返回 Long.MAX_VALUE，因为连接建立好后，会唤醒发送线程的。</li></ul><p>Sender#sendProducerData</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create produce requests</span></span><br><span class="line">Map&lt;Integer, List&lt;ProducerBatch&gt;&gt; batches = <span class="keyword">this</span>.accumulator.drain(cluster, result.readyNodes, <span class="keyword">this</span>.maxRequestSize, now);</span><br></pre></td></tr></table></figure><p>Step4：根据已准备的分区，从缓存区中抽取待发送的消息批次(ProducerBatch)，并且按照 nodeId:List<ProducerBatch> 组织，注意，抽取后的 ProducerBatch 将不能再追加消息了，就算还有剩余空间可用，具体抽取将在下文在详细介绍。</p><p>Sender#sendProducerData</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">addToInflightBatches(batches);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToInflightBatches</span><span class="params">(Map&lt;Integer, List&lt;ProducerBatch&gt;&gt; batches)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (List&lt;ProducerBatch&gt; batchList : batches.values()) &#123;</span><br><span class="line">        addToInflightBatches(batchList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToInflightBatches</span><span class="params">(List&lt;ProducerBatch&gt; batches)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ProducerBatch batch : batches) &#123;</span><br><span class="line">        List&lt;ProducerBatch&gt; inflightBatchList = inFlightBatches.get(batch.topicPartition);</span><br><span class="line">        <span class="keyword">if</span> (inflightBatchList == <span class="keyword">null</span>) &#123;</span><br><span class="line">            inflightBatchList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            inFlightBatches.put(batch.topicPartition, inflightBatchList);</span><br><span class="line">        &#125;</span><br><span class="line">        inflightBatchList.add(batch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step5：将抽取的 ProducerBatch 加入到 inFlightBatches 数据结构，该属性的声明如下：Map&lt;TopicPartition, List&lt; ProducerBatch &gt;&gt; inFlightBatches，即按照 topic-分区 为键，存放已抽取的 ProducerBatch，这个属性的含义就是存储待发送的消息批次。可以根据该数据结构得知在消息发送时以分区为维度反馈 Sender 线程的“积压情况”，max.in.flight.requests.per.connection 就是来控制积压的最大数量，如果积压达到这个数值，针对该队列的消息发送会限流。</p><p>Sender#sendProducerData</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">accumulator.resetNextBatchExpiryTime();</span><br><span class="line">List&lt;ProducerBatch&gt; expiredInflightBatches = getExpiredInflightBatches(now);</span><br><span class="line">List&lt;ProducerBatch&gt; expiredBatches = <span class="keyword">this</span>.accumulator.expiredBatches(now);</span><br><span class="line">expiredBatches.addAll(expiredInflightBatches);</span><br></pre></td></tr></table></figure><p>Step6：从 inflightBatches 与 batches 中查找已过期的消息批次(ProducerBatch)，判断是否过期的标准是系统当前时间与 ProducerBatch 创建时间之差是否超过120s，过期时间可以通过参数 delivery.timeout.ms 设置。</p><p>Sender#sendProducerData</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!expiredBatches.isEmpty())</span><br><span class="line">    log.trace(<span class="string">&quot;Expired &#123;&#125; batches in accumulator&quot;</span>, expiredBatches.size());</span><br><span class="line"><span class="keyword">for</span> (ProducerBatch expiredBatch : expiredBatches) &#123;</span><br><span class="line">    String errorMessage = <span class="string">&quot;Expiring &quot;</span> + expiredBatch.recordCount + <span class="string">&quot; record(s) for &quot;</span> + expiredBatch.topicPartition</span><br><span class="line">                + <span class="string">&quot;:&quot;</span> + (now - expiredBatch.createdMs) + <span class="string">&quot; ms has passed since batch creation&quot;</span>;</span><br><span class="line">    failBatch(expiredBatch, -<span class="number">1</span>, NO_TIMESTAMP, <span class="keyword">new</span> TimeoutException(errorMessage), <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (transactionManager != <span class="keyword">null</span> &amp;&amp; expiredBatch.inRetry()) &#123;</span><br><span class="line">        <span class="comment">// This ensures that no new batches are drained until the current in flight batches are fully resolved.</span></span><br><span class="line">        transactionManager.markSequenceUnresolved(expiredBatch.topicPartition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step7：处理已超时的消息批次，通知该批消息发送失败，即通过设置  KafkaProducer#send 方法返回的凭证中的 FutureRecordMetadata 中的 ProduceRequestResult result，使之调用其 get 方法不会阻塞。</p><p>Sender#sendProducerData</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sensors.updateProduceRequestMetrics(batches);</span><br></pre></td></tr></table></figure><p>Step8：收集统计指标，本文不打算详细分析，但后续会专门对 Kafka 的 Metrics 设计进行一个深入的探讨与学习。</p><p>Sender#sendProducerData</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> pollTimeout = Math.min(result.nextReadyCheckDelayMs, notReadyTimeout);</span><br><span class="line">pollTimeout = Math.min(pollTimeout, <span class="keyword">this</span>.accumulator.nextExpiryTimeMs() - now);</span><br><span class="line">pollTimeout = Math.max(pollTimeout, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!result.readyNodes.isEmpty()) &#123;</span><br><span class="line">    log.trace(<span class="string">&quot;Nodes with data ready to send: &#123;&#125;&quot;</span>, result.readyNodes);</span><br><span class="line">    pollTimeout = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step9：设置下一次的发送延时，待补充详细分析。</p><p>Sender#sendProducerData</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sendProduceRequests(batches, now);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendProduceRequests</span><span class="params">(Map&lt;Integer, List&lt;ProducerBatch&gt;&gt; collated, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, List&lt;ProducerBatch&gt;&gt; entry : collated.entrySet())</span><br><span class="line">        sendProduceRequest(now, entry.getKey(), acks, requestTimeoutMs, entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step10：该步骤按照 brokerId 分别构建发送请求，即每一个 broker 会将多个  ProducerBatch 一起封装成一个请求进行发送，同一时间，每一个 与 broker 连接只会只能发送一个请求，注意，这里只是构建请求，并最终会通过 NetworkClient#send 方法，将该批数据设置到 NetworkClient 的待发送数据中，此时并没有触发真正的网络调用。</p><p>sendProducerData 方法就介绍到这里了，既然这里还没有进行真正的网络请求，那在什么时候触发呢？</p><p>我们继续回到 runOnce 方法。</p><h6 id="1-2-1-2-NetworkClient-的-poll-方法"><a href="#1-2-1-2-NetworkClient-的-poll-方法" class="headerlink" title="1.2.1.2 NetworkClient 的 poll 方法"></a>1.2.1.2 NetworkClient 的 poll 方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> List&lt;ClientResponse&gt; <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    ensureActive();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!abortedSends.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// If there are aborted sends because of unsupported version exceptions or disconnects,</span></span><br><span class="line">        <span class="comment">// handle them immediately without waiting for Selector#poll.</span></span><br><span class="line">        List&lt;ClientResponse&gt; responses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        handleAbortedSends(responses);</span><br><span class="line">        completeResponses(responses);</span><br><span class="line">        <span class="keyword">return</span> responses;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> metadataTimeout = metadataUpdater.maybeUpdate(now);   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.selector.poll(Utils.min(timeout, metadataTimeout, defaultRequestTimeoutMs));    <span class="comment">// @2</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Unexpected error during I/O&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process completed actions</span></span><br><span class="line">    <span class="keyword">long</span> updatedNow = <span class="keyword">this</span>.time.milliseconds();</span><br><span class="line">    List&lt;ClientResponse&gt; responses = <span class="keyword">new</span> ArrayList&lt;&gt;();            <span class="comment">// @3</span></span><br><span class="line">    handleCompletedSends(responses, updatedNow);</span><br><span class="line">    handleCompletedReceives(responses, updatedNow);</span><br><span class="line">    handleDisconnections(responses, updatedNow);</span><br><span class="line">    handleConnections();</span><br><span class="line">    handleInitiateApiVersionRequests(updatedNow);</span><br><span class="line">    handleTimedOutRequests(responses, updatedNow);</span><br><span class="line">    completeResponses(responses);                                               <span class="comment">// @4</span></span><br><span class="line">    <span class="keyword">return</span> responses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文并不会详细深入探讨其网络实现部分，Kafka 的 网络通讯后续我会专门详细的介绍，在这里先点出其关键点。<br>代码@1：尝试更新云数据。<br>代码@2：触发真正的网络通讯，该方法中会通过收到调用 NIO 中的 Selector#select() 方法，对通道的读写就绪事件进行处理，当写事件就绪后，就会将通道中的消息发送到远端的 broker。<br>代码@3：然后会消息发送，消息接收、断开连接、API版本，超时等结果进行收集。<br>代码@4：并依次对结果进行唤醒，此时会将响应结果设置到  KafkaProducer#send 方法返回的凭证中，从而唤醒发送客户端，完成一次完整的消息发送流程。</p><p>Sender 发送线程的流程就介绍到这里了，接下来首先给出一张流程图，然后对上述流程中一些关键的方法再补充深入探讨一下。</p><h5 id="1-2-2-run-方法流程图"><a href="#1-2-2-run-方法流程图" class="headerlink" title="1.2.2 run 方法流程图"></a>1.2.2 run 方法流程图</h5><p><img src="https://img-blog.csdnimg.cn/20191117182748452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>根据上面的源码分析得出上述流程图，图中对重点步骤也详细标注了其关键点。下面我们对上述流程图中 Sender 线程依赖的相关类的核心方法进行解读，以便加深 Sender 线程的理解。</p><p>由于在讲解 Sender 发送流程中，大部分都是调用 RecordAccumulator 方法来实现其特定逻辑，故接下来重点对上述涉及到RecordAccumulator 的方法进行一个详细剖析，加强对 Sender 流程的理解。</p><h2 id="2、RecordAccumulator-核心方法详解"><a href="#2、RecordAccumulator-核心方法详解" class="headerlink" title="2、RecordAccumulator 核心方法详解"></a>2、RecordAccumulator 核心方法详解</h2><h4 id="2-1-RecordAccumulator-的-ready-方法详解"><a href="#2-1-RecordAccumulator-的-ready-方法详解" class="headerlink" title="2.1 RecordAccumulator 的 ready 方法详解"></a>2.1 RecordAccumulator 的 ready 方法详解</h4><p>该方法主要就是根据缓存区中的消息，判断哪些分区已经达到发送条件。</p><p>RecordAccumulator#ready</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ReadyCheckResult <span class="title">ready</span><span class="params">(Cluster cluster, <span class="keyword">long</span> nowMs)</span> </span>&#123;</span><br><span class="line">    Set&lt;Node&gt; readyNodes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">long</span> nextReadyCheckDelayMs = Long.MAX_VALUE;</span><br><span class="line">    Set&lt;String&gt; unknownLeaderTopics = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> exhausted = <span class="keyword">this</span>.free.queued() &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;TopicPartition, Deque&lt;ProducerBatch&gt;&gt; entry : <span class="keyword">this</span>.batches.entrySet()) &#123;   <span class="comment">// @1</span></span><br><span class="line">        TopicPartition part = entry.getKey();</span><br><span class="line">        Deque&lt;ProducerBatch&gt; deque = entry.getValue();</span><br><span class="line"></span><br><span class="line">        Node leader = cluster.leaderFor(part);   <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">synchronized</span> (deque) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; !deque.isEmpty()) &#123;   <span class="comment">// @3</span></span><br><span class="line">                <span class="comment">// This is a partition for which leader is not known, but messages are available to send.</span></span><br><span class="line">                <span class="comment">// Note that entries are currently not removed from batches when deque is empty.</span></span><br><span class="line">                unknownLeaderTopics.add(part.topic());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!readyNodes.contains(leader) &amp;&amp; !isMuted(part, nowMs)) &#123;    <span class="comment">// @4</span></span><br><span class="line">                ProducerBatch batch = deque.peekFirst();</span><br><span class="line">                <span class="keyword">if</span> (batch != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> waitedTimeMs = batch.waitedTimeMs(nowMs);</span><br><span class="line">                    <span class="keyword">boolean</span> backingOff = batch.attempts() &gt; <span class="number">0</span> &amp;&amp; waitedTimeMs &lt; retryBackoffMs;</span><br><span class="line">                    <span class="keyword">long</span> timeToWaitMs = backingOff ? retryBackoffMs : lingerMs;</span><br><span class="line">                    <span class="keyword">boolean</span> full = deque.size() &gt; <span class="number">1</span> || batch.isFull();</span><br><span class="line">                    <span class="keyword">boolean</span> expired = waitedTimeMs &gt;= timeToWaitMs;</span><br><span class="line">                    <span class="keyword">boolean</span> sendable = full || expired || exhausted || closed || flushInProgress();</span><br><span class="line">                    <span class="keyword">if</span> (sendable &amp;&amp; !backingOff) &#123;   <span class="comment">// @5</span></span><br><span class="line">                        readyNodes.add(leader);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">long</span> timeLeftMs = Math.max(timeToWaitMs - waitedTimeMs, <span class="number">0</span>);</span><br><span class="line">                        <span class="comment">// Note that this results in a conservative estimate since an un-sendable partition may have</span></span><br><span class="line">                        <span class="comment">// a leader that will later be found to have sendable data. However, this is good enough</span></span><br><span class="line">                        <span class="comment">// since we&#x27;ll just wake up and then sleep again for the remaining time.</span></span><br><span class="line">                        nextReadyCheckDelayMs = Math.min(timeLeftMs, nextReadyCheckDelayMs);   </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReadyCheckResult(readyNodes, nextReadyCheckDelayMs, unknownLeaderTopics);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：对生产者缓存区 ConcurrentHashMap&lt;TopicPartition, Deque&lt; ProducerBatch&gt;&gt; batches 遍历，从中挑选已准备好的消息批次。<br>代码@2：从生产者元数据缓存中尝试查找分区(TopicPartition) 的 leader 信息，如果不存在，当将该 topic 添加到 unknownLeaderTopics (代码@3)，稍后会发送元数据更新请求去 broker 端查找分区的路由信息。<br>代码@4：如果不在 readyNodes 中就需要判断是否满足条件，isMuted 与顺序消息有关，本文暂时不关注，在后面的顺序消息部分会重点探讨。<br>代码@5：这里就是判断是否准备好的条件，先一个一个来解读局部变量的含义。</p><ul><li>long waitedTimeMs<br>该 ProducerBatch 已等待的时长，等于当前时间戳 与 ProducerBatch 的 lastAttemptMs 之差，在 ProducerBatch 创建时或需要重试时会将当前的时间赋值给lastAttemptMs。</li><li>retryBackoffMs<br>当发生异常时发起重试之前的等待时间，默认为 100ms，可通过属性 retry.backoff.ms 配置。</li><li>batch.attempts()<br>该批次当前已重试的次数。</li><li>backingOff<br>后台发送是否关闭，即如果需要重试并且等待时间小于 retryBackoffMs ，则 backingOff = true，也意味着该批次未准备好。</li><li>timeToWaitMs<br>send 线程发送消息需要的等待时间，如果 backingOff  为 true，表示该批次是在重试，并且等待时间小于系统设置的需要等待时间，这种情况下 timeToWaitMs = retryBackoffMs 。否则需要等待的时间为 lingerMs。</li><li>boolean full<br>该批次是否已满，如果两个条件中的任意一个满足即为 true。<ul><li>Deque&lt; ProducerBatch&gt; 该队列的个数大于1，表示肯定有一个 ProducerBatch 已写满。 </li><li>ProducerBatch 已写满。</li></ul></li><li>boolean expired<br>是否过期，等于已经等待的时间是否大于需要等待的时间，如果把发送看成定时发送的话，expired 为 true 表示定时器已到达触发点，即需要执行。</li><li>boolean exhausted<br>当前生产者缓存已不够，创建新的 ProducerBatch 时阻塞在申请缓存空间的线程大于0，此时应立即将缓存区中的消息立即发送到服务器。</li><li>boolean sendable<br>是否可发送。其满足下面的任意一个条件即可：<ul><li>   该批次已写满。(full = true)。</li><li>   已等待系统规定的时长。（expired = true）</li><li>   发送者内部缓存区已耗尽并且有新的线程需要申请(exhausted = true)。</li><li>   该发送者的 close 方法被调用(close = true)。</li><li>   该发送者的 flush 方法被调用。</li></ul></li></ul><h4 id="2-2-RecordAccumulator-的-drain方法详解"><a href="#2-2-RecordAccumulator-的-drain方法详解" class="headerlink" title="2.2 RecordAccumulator 的 drain方法详解"></a>2.2 RecordAccumulator 的 drain方法详解</h4><p>RecordAccumulator#drain</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;Integer, List&lt;ProducerBatch&gt;&gt; drain(Cluster cluster, Set&lt;Node&gt; nodes, <span class="keyword">int</span> maxSize, <span class="keyword">long</span> now) &#123; <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">if</span> (nodes.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, List&lt;ProducerBatch&gt;&gt; batches = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Node node : nodes) &#123;                                                                                                                              </span><br><span class="line">        List&lt;ProducerBatch&gt; ready = drainBatchesForOneNode(cluster, node, maxSize, now);                      <span class="comment">// @2</span></span><br><span class="line">        batches.put(node.id(), ready);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> batches;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：我们首先来介绍该方法的参数：</p><ul><li>Cluster cluster<br>集群信息。</li><li>Set&lt; Node&gt; nodes<br>已准备好的节点集合。</li><li>int maxSize<br>一次请求最大的字节数。</li><li>long now<br>当前时间。</li></ul><p>代码@2：遍历所有节点，调用 drainBatchesForOneNode 方法抽取数据，组装成 Map&lt;Integer /** brokerId */, List&lt; ProducerBatch&gt;&gt; batches。</p><p>接下来重点来看一下 drainBatchesForOneNode。<br>RecordAccumulator#drainBatchesForOneNode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;ProducerBatch&gt; <span class="title">drainBatchesForOneNode</span><span class="params">(Cluster cluster, Node node, <span class="keyword">int</span> maxSize, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    List&lt;PartitionInfo&gt; parts = cluster.partitionsForNode(node.id());   <span class="comment">// @1</span></span><br><span class="line">    List&lt;ProducerBatch&gt; ready = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> start = drainIndex = drainIndex % parts.size();                        <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">do</span> &#123;                                                                                                <span class="comment">// @3 </span></span><br><span class="line">        PartitionInfo part = parts.get(drainIndex);</span><br><span class="line">        TopicPartition tp = <span class="keyword">new</span> TopicPartition(part.topic(), part.partition()); </span><br><span class="line">        <span class="keyword">this</span>.drainIndex = (<span class="keyword">this</span>.drainIndex + <span class="number">1</span>) % parts.size();                     </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (isMuted(tp, now))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        Deque&lt;ProducerBatch&gt; deque = getDeque(tp);                              <span class="comment">// @4</span></span><br><span class="line">        <span class="keyword">if</span> (deque == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (deque) &#123;</span><br><span class="line">            <span class="comment">// invariant: !isMuted(tp,now) &amp;&amp; deque != null</span></span><br><span class="line">            ProducerBatch first = deque.peekFirst();                                         <span class="comment">// @5</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// first != null</span></span><br><span class="line">            <span class="keyword">boolean</span> backoff = first.attempts() &gt; <span class="number">0</span> &amp;&amp; first.waitedTimeMs(now) &lt; retryBackoffMs;   <span class="comment">// @6</span></span><br><span class="line">            <span class="comment">// Only drain the batch if it is not during backoff period.</span></span><br><span class="line">            <span class="keyword">if</span> (backoff)                                                                                     </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (size + first.estimatedSizeInBytes() &gt; maxSize &amp;&amp; !ready.isEmpty()) &#123;     <span class="comment">// @7</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (shouldStopDrainBatchesForPartition(first, tp))                                  </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这里省略与事务消息相关的代码，后续会重点学习。</span></span><br><span class="line">                batch.close();                                                                                            <span class="comment">// @8</span></span><br><span class="line">                size += batch.records().sizeInBytes();</span><br><span class="line">                ready.add(batch);                                                                            </span><br><span class="line"></span><br><span class="line">                batch.drained(now);                                                                             </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (start != drainIndex);</span><br><span class="line">    <span class="keyword">return</span> ready;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：根据 brokerId 获取该 broker 上的所有主分区。<br>代码@2：初始化 start。这里首先来阐述一下 start 与 drainIndex 。</p><ul><li>start 当前开始遍历的分区序号。</li><li>drainIndex 上次抽取的队列索引后，这里主要是为了每个队列都是从零号分区开始抽取。</li></ul><p>代码@3：循环从缓存区抽取对应分区中累积的数据。<br>代码@4：根据 topic + 分区号从生产者发送缓存区中获取已累积的双端Queue。<br>代码@5：从双端队列的头部获取一个元素。（消息追加时是追加到队列尾部）。<br>代码@6：如果当前批次是重试，并且还未到阻塞时间，则跳过该分区。<br>代码@7：如果当前已抽取的消息总大小 加上新的消息已超过 maxRequestSize，则结束抽取。<br>代码@8：将当前批次加入到已准备集合中，并关闭该批次，即不在允许向该批次中追加消息。</p><p>关于消息发送就介绍到这里，NetworkClient 的 poll 方法内部会调用 Selector 执行就绪事件的选择，并将抽取的消息通过网络发送到 Broker 服务器，关于网络后面的具体实现，将在后续文章中单独介绍。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;上文 &lt;a href=&quot;https://blog.csdn.net/prestigeding/article/details/102994716&quot;&gt;《源码分析 Kafka 消息发送流程》&lt;/a&gt; 已经详细介绍了 KafkaProducer send 方法的流程，该方法只是将消息追加到 KafKaProducer 的缓存中，并未真正的向 broker 发送消息，本文将来探讨 Kafka 的 Sender 线程。&lt;/p&gt;
&lt;p&gt;在 KafkaProducer 中会启动一个单独的线程，其名称为 “kafka-producer-network-thread | clientID”，其中 clientID 为生产者的 id 。&lt;/p&gt;
&lt;h2 id=&quot;1、Sender-线程详解&quot;&gt;&lt;a href=&quot;#1、Sender-线程详解&quot; class=&quot;headerlink&quot; title=&quot;1、Sender 线程详解&quot;&gt;&lt;/a&gt;1、Sender 线程详解&lt;/h2&gt;&lt;h4 id=&quot;1-1-类图&quot;&gt;&lt;a href=&quot;#1-1-类图&quot; class=&quot;headerlink&quot; title=&quot;1.1 类图&quot;&gt;&lt;/a&gt;1.1 类图&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191117174420482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;我们先来看一下其各个属性的含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;KafkaClient client&lt;br&gt;kafka 网络通信客户端，主要封装与 broker 的网络通信。&lt;/li&gt;
&lt;li&gt;RecordAccumulator accumulator&lt;br&gt;消息记录累积器，消息追加的入口(RecordAccumulator 的 append 方法)。&lt;/li&gt;
&lt;li&gt;Metadata metadata&lt;br&gt;元数据管理器，即 topic 的路由分区信息。&lt;/li&gt;
&lt;li&gt;boolean guaranteeMessageOrder&lt;br&gt;是否需要保证消息的顺序性。&lt;/li&gt;
&lt;li&gt;int maxRequestSize&lt;br&gt;调用 send 方法发送的最大请求大小，包括 key、消息体序列化后的消息总大小不能超过该值。通过参数 max.request.size 来设置。&lt;/li&gt;
&lt;li&gt;short acks&lt;br&gt;用来定义消息“已提交”的条件(标准)，就是 Broker 端向客户端承偌已提交的条件，可选值如下0、-1、1.&lt;/li&gt;
&lt;li&gt;int retries&lt;br&gt;重试次数。&lt;/li&gt;
&lt;li&gt;Time time&lt;br&gt;时间工具类。&lt;/li&gt;
&lt;li&gt;boolean running&lt;br&gt;该线程状态，为 true 表示运行中。&lt;/li&gt;
&lt;li&gt;boolean forceClose&lt;br&gt;是否强制关闭，此时会忽略正在发送中的消息。&lt;/li&gt;
&lt;li&gt;SenderMetrics sensors&lt;br&gt;消息发送相关的统计指标收集器。&lt;/li&gt;
&lt;li&gt;int requestTimeoutMs&lt;br&gt;请求的超时时间。&lt;/li&gt;
&lt;li&gt;long retryBackoffMs&lt;br&gt;请求失败之在重试之前等待的时间。&lt;/li&gt;
&lt;li&gt;ApiVersions apiVersions&lt;br&gt;API版本信息。&lt;/li&gt;
&lt;li&gt;TransactionManager transactionManager&lt;br&gt;事务处理器。&lt;/li&gt;
&lt;li&gt;Map&amp;lt; TopicPartition, List&amp;lt; ProducerBatch&amp;gt;&amp;gt; inFlightBatches&lt;br&gt;正在执行发送相关的消息批次。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="kafka" scheme="http://example.com/categories/kafka/"/>
    
    
    <category term="kafka" scheme="http://example.com/tags/kafka/"/>
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="Sender" scheme="http://example.com/tags/Sender/"/>
    
  </entry>
  
  <entry>
    <title>初识 Kafka Producer 生产者</title>
    <link href="http://example.com/posts/b579d244.html"/>
    <id>http://example.com/posts/b579d244.html</id>
    <published>2020-12-11T14:56:01.000Z</published>
    <updated>2020-12-11T15:22:06.438Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="1、KafkaProducer-概述"><a href="#1、KafkaProducer-概述" class="headerlink" title="1、KafkaProducer 概述"></a>1、KafkaProducer 概述</h2><p>根据 KafkaProducer 类上的注释上来看 KafkaProducer 具有如下特征：</p><ul><li>KafkaProducer 是线程安全的，可以被多个线程交叉使用。</li><li>KafkaProducer 内部包含一个缓存池，存放待发送消息，即 ProducerRecord 队列，与此同时会开启一个IO线程将 ProducerRecord 对象发送到 Kafka 集群。</li><li>KafkaProducer 的消息发送 API send 方法是异步，只负责将待发送消息 ProducerRecord 发送到缓存区中，立即返回，并返回一个结果凭证 Future。</li><li>acks<br>KafkaProducer 提供了一个核心参数 acks 用来定义消息“已提交”的条件(标准)，就是 Broker 端向客户端承偌已提交的条件，可选值如下：<ul><li>0<br>表示生产者不关系该条消息在 broker 端的处理结果，只要调用 KafkaProducer 的 send 方法返回后即认为成功，显然这种方式是最不安全的，因为 Broker 端可能压根都没有收到该条消息或存储失败。</li><li>all 或 -1<br>表示消息不仅需要 Leader 节点已存储该消息，并且要求其副本（准确的来说是 ISR 中的节点）全部存储才认为已提交，才向客户端返回提交成功。这是最严格的持久化保障，当然性能也最低。</li><li>1<br>表示消息只需要写入 Leader 节点后就可以向客户端返回提交成功。</li></ul></li></ul><a id="more"></a><ul><li>retries<br>kafka 在生产端提供的另外一个核心属性，用来控制消息在发送失败后的重试次数，设置为 0 表示不重试，重试就有可能造成消息在发送端的重复。</li><li>batch.size<br>  kafka 消息发送者为每一个分区维护一个未发送消息积压缓存区，其内存大小由batch.size指定，默认为 16K。<br>  但如果缓存区中不足100条，但发送线程此时空闲，是需要等到缓存区中积满100条才能发送还是可以立即发送呢？默认是立即发送，即 batch.size 的作用其实是客户端一次发送到broker的最大消息数量。</li><li>linger.ms<br>  ​    为了提高 kafka 消息发送的高吞吐量，即控制在缓存区中未积满 batch.size  时来控制 消息发送线程的行为，是立即发送还是等待一定时间，如果linger.ms 设置为 0表示立即发送，如果设置为大于0，则消息发送线程会等待这个值后才会向broker发送。该参数者会增加响应时间，但有利于增加吞吐量。有点类似于 TCP 领域的 Nagle 算法。</li><li>buffer.memory<br>用于控制消息发送者缓存的总内存大小，如果超过该值，往缓存区中添加消息会被阻塞，具体会在下文的消息发送流程中详细介绍，阻塞的最大时间可通过参数 max.block.ms 设置，阻塞超过该值会抛出超时异常。</li><li>key.serializer<br>指定 key 的序列化处理器。</li><li>value.serializer<br>指定 消息体的序列化处理器。</li><li>enable.idempotence<br>从 kafka0.11版本开始，支持消息传递幂等，可以做到消息只会被传递一次，通过 enable.idempotence 为 true 来开启。如果该值设置为 true，其 retries 将设置为 Integer.MAX_VALUE，acks 将被设置为 all。为了确保消息发送幂等性，必须避免应用程序端的任何重试，并且如果消息发送API如果返回错误，应用端应该记录最后成功发送的消息，避免消息的重复发送。</li></ul><p>从Kafka 0.11开始，kafka 也支持事务消息。</p><h2 id="2、KafkaProducer-类图"><a href="#2、KafkaProducer-类图" class="headerlink" title="2、KafkaProducer 类图"></a>2、KafkaProducer 类图</h2><p><img src="https://img-blog.csdnimg.cn/20191103130908591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在 Kafka  中，生产者通过接口 Producer 定义，通过该接口的方法，我们基本可以得知 KafkaProducer 将具备如下基本能力：</p><ul><li>void initTransactions()<br>初始化事务，如果需要使用事务方法，该方法必须首先被调用。</li><li>void beginTransaction()<br>开启事务。</li><li>void sendOffsetsToTransaction(Map&lt; TopicPartition, OffsetAndMetadata&gt; offsets,String consumerGroupId)<br>向消费组提交当前事务中的消息偏移量，将在介绍 Kafka 事务相关文章中详细介绍。</li><li>void commitTransaction()<br>提交事务。</li><li>void abortTransaction()<br>回滚事务。</li><li>Future&lt; RecordMetadata&gt; send(ProducerRecord&lt;K, V&gt; record)<br>消息发送，该方法默认为异步发送，如果要实现同步发送的效果，对返回结果调用  get 方法即可，该方法将在下篇文章中详细介绍。</li><li>Future&lt; RecordMetadata&gt; send(ProducerRecord&lt;K, V&gt; record, Callback callback)<br> ​    消息发送，支持回调。</li><li>void flush()<br>忽略 linger.ms 的值，直接唤醒发送线程，将缓冲区中的消息全部发送到 broker。</li><li>List&lt; PartitionInfo&gt; partitionsFor(String topic)<br>获取 topic 的路由信息（分区信息）。</li><li>Map&lt; MetricName, ? extends Metric&gt; metrics()<br>获取由生产者收集的统计信息。</li><li>void close()<br>关闭发送者。</li><li>void close(Duration timeout)<br>定时关闭消息发送者。</li></ul><p>上面的方法我们会根据需要在后续文章中进行详细的介绍。接下来我们看一下 KafkaProducer 的核心属性的含义。</p><ul><li>String clientId<br>客户端ID。在创建 KafkaProducer 时可通过 client.id 定义 clientId，如果未指定，则默认 producer- seq，seq 在进程内递增，强烈建议客户端显示指定 clientId。</li><li>Metrics metrics<br>度量的相关存储容器，例如消息体大小、发送耗时等与监控相关的指标。</li><li>Partitioner partitioner<br>分区负载均衡算法，通过参数 partitioner.class 指定。</li><li>int maxRequestSize<br>调用 send 方法发送的最大请求大小，包括 key、消息体序列化后的消息总大小不能超过该值。通过参数 max.request.size 来设置。</li><li>long totalMemorySize<br>生产者缓存所占内存的总大小，通过参数 buffer.memory 设置。</li><li>Metadata metadata<br>元数据信息，例如 topic 的路由信息，由 KafkaProducer 自动更新。</li><li>RecordAccumulator accumulator<br>消息记录累积器，将在消息发送部分详细介绍。</li><li>Sender sender<br>用于封装消息发送的逻辑，即向 broker 发送消息的处理逻辑。</li><li>Thread ioThread<br>用于消息发送的后台线程，一个独立的线程，内部使用 Sender 来向 broker 发送消息。</li><li>CompressionType compressionType<br>压缩类型，默认不启用压缩，可通过参数 compression.type 配置。可选值：none、gzip、snappy、lz4、zstd。</li><li>Sensor errors<br>错误信息收集器，当成一个 metrics，用来做监控的。</li><li>Time time<br>用于获取系统时间或线程睡眠等。</li><li>Serializer&lt; K&gt; keySerializer<br>用于对消息的 key 进行序列化。</li><li>Serializer&lt; V&gt; valueSerializer<br>对消息体进行序列化。</li><li>ProducerConfig producerConfig<br>生产者的配置信息。</li><li>long maxBlockTimeMs<br>最大阻塞时间，当生产者使用的缓存已经达到规定值后，此时消息发送会阻塞，通过参数 max.block.ms 来设置最多等待多久。</li><li>ProducerInterceptors&lt;K, V&gt; interceptors<br>生产者端的拦截器，在消息发送之前进行一些定制化处理。</li><li>ApiVersions apiVersions<br>维护 api 版本的相关元信息，该类只能在 kafka 内部使用。</li><li>TransactionManager transactionManager<br>kafka 消息事务管理器。</li><li>TransactionalRequestResult initTransactionsResult<br>kafka 生产者事务上下文环境初始结果。</li></ul><p>经过上面的梳理，详细读者朋友对 KafkaProducer 消息生产者有了一个大概的认识，下一篇会重点介绍消息发送流程。接下来我们以一个简单的示例结束本文的学习。</p><h2 id="3、KafkaProducer-简单示例"><a href="#3、KafkaProducer-简单示例" class="headerlink" title="3、KafkaProducer 简单示例"></a>3、KafkaProducer 简单示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> persistent.prestige.demo.kafka;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Producer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.RecordMetadata;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaProducerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092,localhost:9082,localhost:9072,&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                Future&lt;RecordMetadata&gt;  future = producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">&quot;TOPIC_ORDER&quot;</span>, Integer.toString(i), Integer.toString(i)));</span><br><span class="line">                RecordMetadata recordMetadata = future.get();</span><br><span class="line">                System.out.printf(<span class="string">&quot;offset:&quot;</span> + recordMetadata.offset());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            producer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文就介绍到这里，其主要的目的是了解Kafka 的 Producer，引出后续需要学习的内容，下一篇将重点讲述 Kafka 消息的发送流程，敬请关注。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1、KafkaProducer-概述&quot;&gt;&lt;a href=&quot;#1、KafkaProducer-概述&quot; class=&quot;headerlink&quot; title=&quot;1、KafkaProducer 概述&quot;&gt;&lt;/a&gt;1、KafkaProducer 概述&lt;/h2&gt;&lt;p&gt;根据 KafkaProducer 类上的注释上来看 KafkaProducer 具有如下特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;KafkaProducer 是线程安全的，可以被多个线程交叉使用。&lt;/li&gt;
&lt;li&gt;KafkaProducer 内部包含一个缓存池，存放待发送消息，即 ProducerRecord 队列，与此同时会开启一个IO线程将 ProducerRecord 对象发送到 Kafka 集群。&lt;/li&gt;
&lt;li&gt;KafkaProducer 的消息发送 API send 方法是异步，只负责将待发送消息 ProducerRecord 发送到缓存区中，立即返回，并返回一个结果凭证 Future。&lt;/li&gt;
&lt;li&gt;acks&lt;br&gt;KafkaProducer 提供了一个核心参数 acks 用来定义消息“已提交”的条件(标准)，就是 Broker 端向客户端承偌已提交的条件，可选值如下：&lt;ul&gt;
&lt;li&gt;0&lt;br&gt;表示生产者不关系该条消息在 broker 端的处理结果，只要调用 KafkaProducer 的 send 方法返回后即认为成功，显然这种方式是最不安全的，因为 Broker 端可能压根都没有收到该条消息或存储失败。&lt;/li&gt;
&lt;li&gt;all 或 -1&lt;br&gt;表示消息不仅需要 Leader 节点已存储该消息，并且要求其副本（准确的来说是 ISR 中的节点）全部存储才认为已提交，才向客户端返回提交成功。这是最严格的持久化保障，当然性能也最低。&lt;/li&gt;
&lt;li&gt;1&lt;br&gt;表示消息只需要写入 Leader 节点后就可以向客户端返回提交成功。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="kafka" scheme="http://example.com/categories/kafka/"/>
    
    
    <category term="kafka" scheme="http://example.com/tags/kafka/"/>
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="KafkaProducer" scheme="http://example.com/tags/KafkaProducer/"/>
    
  </entry>
  
  <entry>
    <title>源码分析 Kafka 消息发送流程(文末附流程图)</title>
    <link href="http://example.com/posts/f81e58bb.html"/>
    <id>http://example.com/posts/f81e58bb.html</id>
    <published>2020-12-11T14:56:01.000Z</published>
    <updated>2020-12-11T15:22:06.440Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p>温馨提示：本文基于 Kafka 2.2.1 版本。本文主要是以源码的手段一步一步探究消息发送流程，如果对源码不感兴趣，可以直接跳到文末查看消息发送流程图与消息发送本地缓存存储结构。</p></blockquote><p>从上文 <a href="https://blog.csdn.net/prestigeding/article/details/102881472">初识 Kafka Producer 生产者</a>，可以通过 KafkaProducer 的 send 方法发送消息，send 方法的声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record)</span></span></span><br><span class="line"><span class="function">Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span></span></span><br></pre></td></tr></table></figure><p>从上面的 API 可以得知，用户在使用 KafkaProducer 发送消息时，首先需要将待发送的消息封装成 ProducerRecord，返回的是一个 Future 对象，典型的 Future 设计模式。在发送时也可以指定一个 Callable 接口用来执行消息发送的回调。</p><p>我们在学习消息发送流程之前先来看一下用于封装一条消息的 ProducerRecord 的类图，先来认识一下 kafka 是如何对一条消息进行抽象的。</p><h2 id="1、ProducerRecord-类图"><a href="#1、ProducerRecord-类图" class="headerlink" title="1、ProducerRecord 类图"></a>1、ProducerRecord 类图</h2><p><img src="https://img-blog.csdnimg.cn/201911100956254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们首先来看一下 ProducerRecord 的核心属性，即构成 消息的6大核心要素：</p><ul><li>String topic<br>消息所属的主题。</li><li>Integer partition<br>消息所在主题的队列数，可以人为指定，如果指定了 key 的话，会使用 key 的 hashCode 与队列总数进行取模来选择分区，如果前面两者都未指定，则会轮询主题下的所有分区。</li><li>Headers headers<br>该消息的额外属性对，与消息体分开存储.</li><li>K key<br>消息键，如果指定该值，则会使用该值的 hashcode 与 队列数进行取模来选择分区。</li><li>V value<br>消息体。</li><li>Long timestamp<br>消息时间戳，根据 topic 的配置信息 message.timestamp.type 的值来赋予不同的值。<ul><li>CreateTime<br>发送客户端发送消息时的时间戳。</li><li>LogAppendTime<br>消息在 broker 追加时的时间戳。</li></ul></li></ul><p>其中Headers是一系列的 key-value 键值对。</p><p>在了解 ProducerRecord 后我们开始来探讨 Kafka 的消息发送流程。</p><a id="more"></a><h2 id="2、Kafka-消息追加流程"><a href="#2、Kafka-消息追加流程" class="headerlink" title="2、Kafka 消息追加流程"></a>2、Kafka 消息追加流程</h2><p>KafkaProducer 的 send 方法，并不会直接向 broker 发送消息，kafka 将消息发送异步化，即分解成两个步骤，send 方法的职责是将消息追加到内存中(分区的缓存队列中)，然后会由专门的 Send 线程异步将缓存中的消息批量发送到 Kafka Broker 中。</p><p>消息追加入口为 KafkaProducer#send</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// intercept the record, which can be potentially modified; this method does not throw exceptions</span></span><br><span class="line">    ProducerRecord&lt;K, V&gt; interceptedRecord = <span class="keyword">this</span>.interceptors.onSend(record);                <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">return</span> doSend(interceptedRecord, callback);                                                                     <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先执行消息发送拦截器，拦截器通过 interceptor.classes 指定，类型为 List&lt; String &gt;，每一个元素为拦截器的全类路径限定名。<br>代码@2：执行 doSend 方法，后续我们需要留意一下 Callback  的调用时机。</p><p>接下来我们来看 doSend 方法。</p><h3 id="2-1-doSend"><a href="#2-1-doSend" class="headerlink" title="2.1 doSend"></a>2.1 doSend</h3><p>KafkaProducer#doSend</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ClusterAndWaitTime clusterAndWaitTime;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    clusterAndWaitTime = waitOnMetadata(record.topic(), record.partition(), maxBlockTimeMs);</span><br><span class="line">&#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (metadata.isClosed())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">&quot;Producer closed while send in progress&quot;</span>, e);</span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> remainingWaitMs = Math.max(<span class="number">0</span>, maxBlockTimeMs - clusterAndWaitTime.waitedOnMetadataMs);</span><br></pre></td></tr></table></figure><p>Step1：获取 topic 的分区列表，如果本地没有该topic的分区信息，则需要向远端 broker 获取，该方法会返回拉取元数据所耗费的时间。在消息发送时的最大等待时间时会扣除该部分损耗的时间。</p><blockquote><p>温馨提示：本文不打算对该方法进行深入学习，后续会有专门的文章来分析 Kafka 元数据的同步机制，类似于专门介绍 RocketMQ 的 Nameserver 类似。</p></blockquote><p>KafkaProducer#doSend</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] serializedKey;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    serializedKey = keySerializer.serialize(record.topic(), record.headers(), record.key());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassCastException cce) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SerializationException(<span class="string">&quot;Can&#x27;t convert key of class &quot;</span> + record.key().getClass().getName() +</span><br><span class="line">                        <span class="string">&quot; to class &quot;</span> + producerConfig.getClass(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG).getName() +</span><br><span class="line">                        <span class="string">&quot; specified in key.serializer&quot;</span>, cce);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step2：序列化 key。注意：序列化方法虽然有传入 topic、Headers 这两个属性，但参与序列化的只是 key 。</p><p>KafkaProducer#doSend</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] serializedValue;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    serializedValue = valueSerializer.serialize(record.topic(), record.headers(), record.value());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassCastException cce) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SerializationException(<span class="string">&quot;Can&#x27;t convert value of class &quot;</span> + record.value().getClass().getName() +</span><br><span class="line">                        <span class="string">&quot; to class &quot;</span> + producerConfig.getClass(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG).getName() +</span><br><span class="line">                        <span class="string">&quot; specified in value.serializer&quot;</span>, cce);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step3：对消息体内容进行序列化。</p><p>KafkaProducer#doSend</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> partition = partition(record, serializedKey, serializedValue, cluster);</span><br><span class="line">tp = <span class="keyword">new</span> TopicPartition(record.topic(), partition);</span><br></pre></td></tr></table></figure><p>Step4：根据分区负载算法计算本次消息发送该发往的分区。其默认实现类为 DefaultPartitioner，路由算法如下：</p><ul><li>如果指定了 key ，则使用 key 的 hashcode 与分区数取模。</li><li>如果未指定 key，则轮询所有的分区。</li></ul><p>KafkaProducer#doSend</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setReadOnly(record.headers());</span><br><span class="line">Header[] headers = record.headers().toArray();</span><br></pre></td></tr></table></figure><p>Step5：如果是消息头信息(RecordHeaders)，则设置为只读。</p><p>KafkaProducer#doSend</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> serializedSize = AbstractRecords.estimateSizeInBytesUpperBound(apiVersions.maxUsableProduceMagic(),</span><br><span class="line">                    compressionType, serializedKey, serializedValue, headers);</span><br><span class="line">ensureValidRecordSize(serializedSize);</span><br></pre></td></tr></table></figure><p>Step5：根据使用的版本号，按照消息协议来计算消息的长度，并是否超过指定长度，如果超过则抛出异常。</p><p>KafkaProducer#doSend</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> timestamp = record.timestamp() == <span class="keyword">null</span> ? time.milliseconds() : record.timestamp();</span><br><span class="line">log.trace(<span class="string">&quot;Sending record &#123;&#125; with callback &#123;&#125; to topic &#123;&#125; partition &#123;&#125;&quot;</span>, record, callback, record.topic(), partition);</span><br><span class="line">Callback interceptCallback = <span class="keyword">new</span> InterceptorCallback&lt;&gt;(callback, <span class="keyword">this</span>.interceptors, tp);</span><br></pre></td></tr></table></figure><p>Step6：先初始化消息时间戳，并对传入的 Callable(回调函数) 加入到拦截器链中。</p><p>KafkaProducer#doSend</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (transactionManager != <span class="keyword">null</span> &amp;&amp; transactionManager.isTransactional())</span><br><span class="line">    transactionManager.maybeAddPartitionToTransaction(tp);</span><br></pre></td></tr></table></figure><p>Step7：如果事务处理器不为空，执行事务管理相关的，本节不考虑事务消息相关的实现细节，后续估计会有对应的文章进行解析。</p><p>KafkaProducer#doSend</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RecordAccumulator.RecordAppendResult result = accumulator.append(tp, timestamp, serializedKey, serializedValue, headers, interceptCallback, remainingWaitMs);</span><br><span class="line"><span class="keyword">if</span> (result.batchIsFull || result.newBatchCreated) &#123;</span><br><span class="line">    log.trace(<span class="string">&quot;Waking up the sender since topic &#123;&#125; partition &#123;&#125; is either full or getting a new batch&quot;</span>, record.topic(), partition);</span><br><span class="line">                <span class="keyword">this</span>.sender.wakeup();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result.future;</span><br></pre></td></tr></table></figure><p>Step8：将消息追加到缓存区，这将是本文重点需要探讨的。如果当前缓存区已写满或创建了一个新的缓存区，则唤醒 Sender(消息发送线程)，将缓存区中的消息发送到 broker 服务器，最终返回 future。这里是经典的 Future 设计模式，从这里也能得知，doSend 方法执行完成后，此时消息还不一定成功发送到 broker。</p><p>KafkaProducer#doSend</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#125; catch (ApiException e) &#123;</span><br><span class="line">    log.debug(&quot;Exception occurred during message send:&quot;, e);</span><br><span class="line">    if (callback !&#x3D; null)</span><br><span class="line">        callback.onCompletion(null, e);</span><br><span class="line">        </span><br><span class="line">this.errors.record();</span><br><span class="line">    this.interceptors.onSendError(record, tp, e);</span><br><span class="line">        return new FutureFailure(e);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    this.errors.record();</span><br><span class="line">    this.interceptors.onSendError(record, tp, e);</span><br><span class="line">    throw new InterruptException(e);</span><br><span class="line">&#125; catch (BufferExhaustedException e) &#123;</span><br><span class="line">    this.errors.record();</span><br><span class="line">    this.metrics.sensor(&quot;buffer-exhausted-records&quot;).record();</span><br><span class="line">    this.interceptors.onSendError(record, tp, e);</span><br><span class="line">    throw e;</span><br><span class="line">&#125; catch (KafkaException e) &#123;</span><br><span class="line">    this.errors.record();</span><br><span class="line">    this.interceptors.onSendError(record, tp, e);</span><br><span class="line">    throw e;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    &#x2F;&#x2F; we notify interceptor about all exceptions, since onSend is called before anything else in this method</span><br><span class="line">    this.interceptors.onSendError(record, tp, e);</span><br><span class="line">    throw e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step9：针对各种异常，进行相关信息的收集。</p><p>接下来将重点介绍如何将消息追加到生产者的发送缓存区，其实现类为：RecordAccumulator。</p><h3 id="2-2-RecordAccumulator-append-方法详解"><a href="#2-2-RecordAccumulator-append-方法详解" class="headerlink" title="2.2 RecordAccumulator append 方法详解"></a>2.2 RecordAccumulator append 方法详解</h3><p>RecordAccumulator#append</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RecordAppendResult <span class="title">append</span><span class="params">(TopicPartition tp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">long</span> timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">byte</span>[] key,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">byte</span>[] value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Header[] headers,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Callback callback,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">long</span> maxTimeToBlock)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br></pre></td></tr></table></figure><p>在介绍该方法之前，我们首先来看一下该方法的参数。</p><ul><li>TopicPartition tp<br>topic 与分区信息，即发送到哪个 topic 的那个分区。</li><li>long timestamp<br>客户端发送时的时间戳。</li><li>byte[] key<br>消息的 key。</li><li>byte[] value<br>消息体。</li><li>Header[] headers<br>消息头，可以理解为额外消息属性。</li><li>Callback callback<br>回调方法。</li><li>long maxTimeToBlock<br>消息追加超时时间。</li></ul><p>RecordAccumulator#append</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;ProducerBatch&gt; dq = getOrCreateDeque(tp);</span><br><span class="line"><span class="keyword">synchronized</span> (dq) &#123;</span><br><span class="line">    <span class="keyword">if</span> (closed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">&quot;Producer closed while send in progress&quot;</span>);</span><br><span class="line">    RecordAppendResult appendResult = tryAppend(timestamp, key, value, headers, callback, dq);</span><br><span class="line">    <span class="keyword">if</span> (appendResult != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step1：尝试根据 topic与分区在 kafka 中获取一个双端队列，如果不存在，则创建一个，然后调用 tryAppend 方法将消息追加到缓存中。Kafka 会为每一个 topic 的每一个分区创建一个消息缓存区，消息先追加到缓存中，然后消息发送 API 立即返回，然后由单独的线程 Sender 将缓存区中的消息定时发送到 broker 。这里的缓存区的实现使用的是 ArrayQeque。然后调用 tryAppend 方法尝试将消息追加到其缓存区，如果追加成功，则返回结果。</p><p>在讲解下一个流程之前，我们先来看一下 Kafka 双端队列的存储结构：<br><img src="https://img-blog.csdnimg.cn/20191110101227257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>RecordAccumulator#append</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = Math.max(<span class="keyword">this</span>.batchSize, AbstractRecords.estimateSizeInBytesUpperBound(maxUsableMagic, compression, key, value, headers));</span><br><span class="line">log.trace(<span class="string">&quot;Allocating a new &#123;&#125; byte message buffer for topic &#123;&#125; partition &#123;&#125;&quot;</span>, size, tp.topic(), tp.partition());</span><br><span class="line">buffer = free.allocate(size, maxTimeToBlock);</span><br></pre></td></tr></table></figure><p>Step2：如果第一步未追加成功，说明当前没有可用的 ProducerBatch，则需要创建一个 ProducerBatch，故先从 BufferPool 中申请 batch.size 的内存空间，为创建 ProducerBatch 做准备，如果由于 BufferPool 中未有剩余内存，则最多等待 maxTimeToBlock ，如果在指定时间内未申请到内存，则抛出异常。</p><p>RecordAccumulator#append</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (dq) &#123;</span><br><span class="line">    <span class="comment">// Need to check if producer is closed again after grabbing the dequeue lock.</span></span><br><span class="line">    <span class="keyword">if</span> (closed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">&quot;Producer closed while send in progress&quot;</span>);</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    MemoryRecordsBuilder recordsBuilder = recordsBuilder(buffer, maxUsableMagic);</span><br><span class="line">    ProducerBatch batch = <span class="keyword">new</span> ProducerBatch(tp, recordsBuilder, time.milliseconds());</span><br><span class="line">    FutureRecordMetadata future = Utils.notNull(batch.tryAppend(timestamp, key, value, headers, callback, time.milliseconds()));</span><br><span class="line">    dq.addLast(batch);</span><br><span class="line">    incomplete.add(batch);</span><br><span class="line">    <span class="comment">// Don&#x27;t deallocate this buffer in the finally block as it&#x27;s being used in the record batch</span></span><br><span class="line">    buffer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RecordAppendResult(future, dq.size() &gt; <span class="number">1</span> || batch.isFull(), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step3：创建一个新的批次 ProducerBatch，并将消息写入到该批次中，并返回追加结果，这里有如下几个关键点：</p><ul><li>创建 ProducerBatch ，其内部持有一个 MemoryRecordsBuilder对象，该对象负责将消息写入到内存中，即写入到 ProducerBatch 内部持有的内存，大小等于 batch.size。</li><li>将消息追加到 ProducerBatch 中。</li><li>将新创建的 ProducerBatch  添加到双端队列的末尾。</li><li>将该批次加入到 incomplete 容器中，该容器存放未完成发送到 broker 服务器中的消息批次，当 Sender 线程将消息发送到 broker 服务端后，会将其移除并释放所占内存。</li><li>返回追加结果。</li></ul><p>纵观 RecordAccumulator  append 的流程，基本上就是从双端队列获取一个未填充完毕的 ProducerBatch（消息批次），然后尝试将其写入到该批次中（缓存、内存中），如果追加失败，则尝试创建一个新的 ProducerBatch 然后继续追加。</p><p>接下来我们继续探究如何向 ProducerBatch 中写入消息。</p><h3 id="2-3-ProducerBatch-tryAppend方法详解"><a href="#2-3-ProducerBatch-tryAppend方法详解" class="headerlink" title="2.3 ProducerBatch  tryAppend方法详解"></a>2.3 ProducerBatch  tryAppend方法详解</h3><p>ProducerBatch #tryAppend</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FutureRecordMetadata <span class="title">tryAppend</span><span class="params">(<span class="keyword">long</span> timestamp, <span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] value, Header[] headers, Callback callback, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!recordsBuilder.hasRoomFor(timestamp, key, value, headers)) &#123;  <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Long checksum = <span class="keyword">this</span>.recordsBuilder.append(timestamp, key, value, headers);                    <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">this</span>.maxRecordSize = Math.max(<span class="keyword">this</span>.maxRecordSize, AbstractRecords.estimateSizeInBytesUpperBound(magic(),</span><br><span class="line">                    recordsBuilder.compressionType(), key, value, headers));               <span class="comment">// @3</span></span><br><span class="line">        <span class="keyword">this</span>.lastAppendTime = now;                                                                          <span class="comment">//                                                     </span></span><br><span class="line">        FutureRecordMetadata future = <span class="keyword">new</span> FutureRecordMetadata(<span class="keyword">this</span>.produceFuture, <span class="keyword">this</span>.recordCount,</span><br><span class="line">                                                                   timestamp, checksum,</span><br><span class="line">                                                                   key == <span class="keyword">null</span> ? -<span class="number">1</span> : key.length,</span><br><span class="line">                                                                   value == <span class="keyword">null</span> ? -<span class="number">1</span> : value.length,</span><br><span class="line">                                                                   Time.SYSTEM);                                        <span class="comment">// @4</span></span><br><span class="line">        <span class="comment">// we have to keep every future returned to the users in case the batch needs to be</span></span><br><span class="line">        <span class="comment">// split to several new batches and resent.</span></span><br><span class="line">        thunks.add(<span class="keyword">new</span> Thunk(callback, future));                                                           <span class="comment">// @5</span></span><br><span class="line">        <span class="keyword">this</span>.recordCount++;</span><br><span class="line">        <span class="keyword">return</span> future;                                                                            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先判断 ProducerBatch  是否还能容纳当前消息，如果剩余内存不足，将直接返回 null。如果返回 null ，会尝试再创建一个新的ProducerBatch。</p><p>代码@2：通过 MemoryRecordsBuilder 将消息写入按照 Kafka 消息格式写入到内存中，即写入到 在创建 ProducerBatch  时申请的 ByteBuffer 中。本文先不详细介绍 Kafka 各个版本的消息格式，后续会专门写一篇文章介绍 Kafka 各个版本的消息格式。</p><p>代码@3：更新 ProducerBatch  的 maxRecordSize、lastAppendTime 属性，分别表示该批次中最大的消息长度与最后一次追加消息的时间。</p><p>代码@4：构建 FutureRecordMetadata 对象，这里是典型的 Future模式，里面主要包含了该条消息对应的批次的 produceFuture、消息在该批消息的下标，key 的长度、消息体的长度以及当前的系统时间。</p><p>代码@5：将 callback 、本条消息的凭证(Future) 加入到该批次的 thunks 中，该集合存储了 一个批次中所有消息的发送回执。</p><p>流程执行到这里，KafkaProducer 的 send 方法就执行完毕了，返回给调用方的就是一个 FutureRecordMetadata 对象。</p><p>源码的阅读比较枯燥，接下来用一个流程图简单的阐述一下消息追加的关键要素，重点关注一下各个 Future。</p><h3 id="2-4-Kafka-消息追加流程图与总结"><a href="#2-4-Kafka-消息追加流程图与总结" class="headerlink" title="2.4 Kafka 消息追加流程图与总结"></a>2.4 Kafka 消息追加流程图与总结</h3><p><img src="https://img-blog.csdnimg.cn/201911101014500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上面的消息发送，其实用消息追加来表达更加贴切，因为 Kafka 的 send 方法，并不会直接向 broker 发送消息，而是首先先追加到生产者的内存缓存中，其内存存储结构如下：ConcurrentMap&lt; TopicPartition, Deque&lt; ProducerBatch&gt;&gt; batches，那我们自然而然的可以得知，Kafka 的生产者为会每一个 topic 的每一个 分区单独维护一个队列，即 ArrayDeque，内部存放的元素为 ProducerBatch，即代表一个批次，即 Kafka 消息发送是按批发送的。其缓存结果图如下：<br><img src="https://img-blog.csdnimg.cn/20191110101523210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>KafkaProducer 的 send 方法最终返回的 FutureRecordMetadata ，是 Future 的子类，即 Future 模式。那 kafka 的消息发送怎么实现异步发送、同步发送的呢？</p><p>其实答案也就蕴含在 send 方法的返回值，如果项目方需要使用同步发送的方式，只需要拿到 send 方法的返回结果后，调用其 get() 方法，此时如果消息还未发送到 Broker 上，该方法会被阻塞，等到 broker 返回消息发送结果后该方法会被唤醒并得到消息发送结果。如果需要异步发送，则建议使用 send(ProducerRecord&lt; K, V &gt; record, Callback callback),但不能调用 get 方法即可。Callback 会在收到 broker 的响应结果后被调用，并且支持拦截器。</p><p>消息追加流程就介绍到这里了，消息被追加到缓存区后，什么是会被发送到 broker 端呢？将在下一篇文章中详细介绍。</p><p>如果文章对您有所帮助的话，麻烦帮忙点个赞，谢谢您的认可与支持。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;温馨提示：本文基于 Kafka 2.2.1 版本。本文主要是以源码的手段一步一步探究消息发送流程，如果对源码不感兴趣，可以直接跳到文末查看消息发送流程图与消息发送本地缓存存储结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从上文 &lt;a href=&quot;https://blog.csdn.net/prestigeding/article/details/102881472&quot;&gt;初识 Kafka Producer 生产者&lt;/a&gt;，可以通过 KafkaProducer 的 send 方法发送消息，send 方法的声明如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Future&amp;lt;RecordMetadata&amp;gt; &lt;span class=&quot;title&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ProducerRecord&amp;lt;K, V&amp;gt; record)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Future&amp;lt;RecordMetadata&amp;gt; &lt;span class=&quot;title&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ProducerRecord&amp;lt;K, V&amp;gt; record, Callback callback)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从上面的 API 可以得知，用户在使用 KafkaProducer 发送消息时，首先需要将待发送的消息封装成 ProducerRecord，返回的是一个 Future 对象，典型的 Future 设计模式。在发送时也可以指定一个 Callable 接口用来执行消息发送的回调。&lt;/p&gt;
&lt;p&gt;我们在学习消息发送流程之前先来看一下用于封装一条消息的 ProducerRecord 的类图，先来认识一下 kafka 是如何对一条消息进行抽象的。&lt;/p&gt;
&lt;h2 id=&quot;1、ProducerRecord-类图&quot;&gt;&lt;a href=&quot;#1、ProducerRecord-类图&quot; class=&quot;headerlink&quot; title=&quot;1、ProducerRecord 类图&quot;&gt;&lt;/a&gt;1、ProducerRecord 类图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/201911100956254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;我们首先来看一下 ProducerRecord 的核心属性，即构成 消息的6大核心要素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String topic&lt;br&gt;消息所属的主题。&lt;/li&gt;
&lt;li&gt;Integer partition&lt;br&gt;消息所在主题的队列数，可以人为指定，如果指定了 key 的话，会使用 key 的 hashCode 与队列总数进行取模来选择分区，如果前面两者都未指定，则会轮询主题下的所有分区。&lt;/li&gt;
&lt;li&gt;Headers headers&lt;br&gt;该消息的额外属性对，与消息体分开存储.&lt;/li&gt;
&lt;li&gt;K key&lt;br&gt;消息键，如果指定该值，则会使用该值的 hashcode 与 队列数进行取模来选择分区。&lt;/li&gt;
&lt;li&gt;V value&lt;br&gt;消息体。&lt;/li&gt;
&lt;li&gt;Long timestamp&lt;br&gt;消息时间戳，根据 topic 的配置信息 message.timestamp.type 的值来赋予不同的值。&lt;ul&gt;
&lt;li&gt;CreateTime&lt;br&gt;发送客户端发送消息时的时间戳。&lt;/li&gt;
&lt;li&gt;LogAppendTime&lt;br&gt;消息在 broker 追加时的时间戳。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中Headers是一系列的 key-value 键值对。&lt;/p&gt;
&lt;p&gt;在了解 ProducerRecord 后我们开始来探讨 Kafka 的消息发送流程。&lt;/p&gt;</summary>
    
    
    
    <category term="kafka" scheme="http://example.com/categories/kafka/"/>
    
    
    <category term="kafka" scheme="http://example.com/tags/kafka/"/>
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="ProducerRecord" scheme="http://example.com/tags/ProducerRecord/"/>
    
    <category term="双端队列" scheme="http://example.com/tags/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Netty4 ChannelHandler 概述</title>
    <link href="http://example.com/posts/eab70bff.html"/>
    <id>http://example.com/posts/eab70bff.html</id>
    <published>2020-12-11T14:54:01.000Z</published>
    <updated>2020-12-11T15:22:06.437Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p>专栏介绍：《让天下没有难学的Netty》系列，基于 Netty，以源码分析为主要手段，关键流程给出流程图，从 通道篇、内存篇、性能篇三个维度深度剖析 Netty 的实现原理。 </p></blockquote><h2 id="1、通道概述"><a href="#1、通道概述" class="headerlink" title="1、通道概述"></a>1、通道概述</h2><p>我们从如下几个方面来简单了解一下 Channel。</p><ul><li>通道的当前状态，open(端口打开)、connect(连接)。</li><li>通道的配置，包含通道的配置属性与网络通信选项(ChannelOption)。</li><li>IO 通道方法诸如 read、write、connect、bind 与管道(ChannelPipeline)。</li><li>所有 IO 操作在 Netty 中都是异步的，调用 IO 方法例如 write 方法后，并不是等 IO 操作实际完成后再返回，而是会立即返回一个凭证，IO 操作完成后会将结果写入凭证中，典型的 Future设计模式。</li><li>Channel 具有父子关系，由于所有的 SocketChannel（客户端发起TCP连接）都是由 ServerSocketChannel（服务端接收连接）接收客户端连接而创建的，故 SocketChannel 的 parent() 方法会返回对应的 ServerSocketChannel。</li><li>所有通道对象在使用完后，请务必调用通道的colse方法来释放资源。</li></ul><p>本节将从如下3个方面来重点介绍Channel。</p><ul><li>Channel 常用API</li><li>Channel 配置与选项</li><li>NIO相关的Channel继承图</li></ul><a id="more"></a><h2 id="2、Channel常用API"><a href="#2、Channel常用API" class="headerlink" title="2、Channel常用API"></a>2、Channel常用API</h2><p>Channel 类图结构如下：<br><img src="https://img-blog.csdnimg.cn/20201129210717360.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>核心API一览：</p><ul><li>EventLoop eventLoop()<br>返回该通道注册的事件轮询器。</li><li>Channel parent()<br>返回该通道的父通道，如果是ServerSocketChannel实例则返回null，SocketChannel实例则返回对应的ServerSocketChannel。</li><li>ChannelConfig config()<br>返回该通道的配置参数。</li><li>boolean isOpen()<br>端口是否处于open，通道默认一创建isOpen方法就会返回true，close方法被调用后该方法返回false。</li><li>boolean isRegistered()<br>是否已注册到EventLoop。</li><li>public boolean isActive()<br>通道是否处于激活。NioSocketChannel的实现是java.nio.channels.SocketChannel实例的isOpen()与isConnected()都返回true。NioServerSocketChannel的实现是ServerSocketChannel.socket().isBound()，如果绑定到端口中，意味着处于激活状态。</li><li>ChannelFuture closeFuture()<br>Future模式的应用，调用该方法的目的并不是关闭通道，而是预先创建一个凭证(Future)，等通道关闭时，会通知该Future，用户可以通过该Future注册事件。</li><li>ChannelFuture bind(SocketAddress localAddress)<br>Netty服务端绑定到本地端口，开始监听客户端的连接请求。该过程会触发事件链(ChannelPipeline)。该部分将在后续讲解服务端启动流程时再详细分析。</li><li>ChannelFuture connect(SocketAddress remoteAddress)<br>Netty客户端连接到服务端，该过程同样会触发一系列事件(ChannelPipeline)。该部分将在后续讲解客户端启动流程时再详细分析。</li><li>ChannelFuture disconnect()<br>断开连接，但不会释放资源，该通道还可以再通过connect重新与服务器建立连接。</li><li>ChannelFuture close()<br>关闭通道，回收资源，该通道的生命周期完全结束。</li><li>ChannelFuture deregister()<br>取消注册。</li><li>Channel read()<br>通道读，该方法并不是直接从读写缓存区读取文件，而是向NIO Selecor注册读事件（目前主要基于NIO）。当通道收到对端的数后，事件选择器会处理读事件，从而触发ChannelInboundHandler#channelRead 事件，然后继续触发ChannelInboundHandler#channelReadComplete(ChannelHandlerContext)事件。</li><li>ChannelFuture write(Object msg)<br>向通道写字节流，会触发响应的写事件链，该方法只是会将字节流写入到通道缓存区，并不会调用flush方法写入通道中。</li><li>Channel flush()<br>刷写所有挂起的消息（刷写到流中）。</li><li>ChannelFuture writeAndFlush(Object msg)<br>相当于调用write与flush方法。</li></ul><h2 id="3、Channel配置与选项"><a href="#3、Channel配置与选项" class="headerlink" title="3、Channel配置与选项"></a>3、Channel配置与选项</h2><h4 id="3-1-Channel配置"><a href="#3-1-Channel配置" class="headerlink" title="3.1 Channel配置"></a>3.1 Channel配置</h4><p>ChannelConfig 的类图如下：<br><img src="https://img-blog.csdnimg.cn/20201129210953154.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>核心配置如下：</p><ul><li>Map&lt;ChannelOption&lt;?&gt;, Object&gt; options：选项，在下文会重点介绍。</li><li>int connectTimeoutMillis：连接超时时间。</li><li>int maxMessagesPerRead：每次读事件中调用读方法的最大次数(AbstractNioByteChannel)或读事件循环中最多处理的消息条数(AbstractNioMessageChannel)。</li><li>int writeSpinCount：一次写事件处理期间最多调用write方法的次数，引入该机制主要是为了避免一个网络通道写入大量数据，对其他网络通道的读写处理带来延迟，默认值为16。</li><li>ByteBufAllocator getAllocator()：返回该通道的内存分配器(ByteBuf)。<br>RecvByteBufAllocator getRecvByteBufAllocator()：读事件读缓冲区的分配策略。</li><li>boolean autoRead：是否自动触发read方法调用，默认为true，读事件触发后自动调用read方法 ，而无需应用程序显示调用。</li><li>int writeBufferHighWaterMark：设置写缓存区的高水位线。如果写缓存区中的数据超过该值，Channel#isWritable()方法将返回false。</li><li>int writeBufferLowWaterMark：设置写缓存区的低水位线。如果写缓存区的数据超过高水位线后，通道将变得不可写，等写缓存数据降低到低水位线后通道恢复可写状态(Channel#isWritable()将再次返回true)。<h4 id="3-2-ChannelOption"><a href="#3-2-ChannelOption" class="headerlink" title="3.2 ChannelOption"></a>3.2 ChannelOption</h4><img src="https://img-blog.csdnimg.cn/20201129211116360.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>网络通道(Channel)选项值，下面介绍一下与TCP协议相关的核心参数：</li><li>SO_BROADCAST<br>选择值类型:boolean。表值该数据包是否是广播包，true表示广播包，false表示非广播，如果包的IP地址为广播地址，但该选型为false，则在内核层会抛出错误。</li><li>SO_KEEPALIVE<br>对于面向连接的TCP socket,在实际应用中通常都要检测对端是否处于连接中,连接端口分两种情况:<ul><li><pre><code>连接正常关闭,调用close() shutdown()连接优雅关闭,send与recv立马返回错误,select返回SOCK_ERR</code></pre></li><li><pre><code>连接的对端异常关闭,比如网络断掉,突然断电.</code></pre></li></ul></li><li>SO_SNDBUF的大小<br>为了达到最大网络吞吐，socket send buffer size(SO_SNDBUF)不应该小于带宽和延迟的乘积。</li><li>SO_REUSEADDR<br>该参数如果设置为true的一个常用应用场景是端口复用(直接复用TIME_WAIT状态的socket)。</li><li>SO_LINGER<br>该参数是控制TCP关闭行为的。</li><li>SO_BACKLOG<br>服务端接受客户端连接的处理队列，在TCP三次握手协议中，服务端接收到客户端的SYN包后，会向客户端发送SYN+ACK包，同时会将连接放入到 backlog 队列中，等待客户端ACK包。在服务端没有接收到客户端的ACK包之前，连接会暂存 backlog 队列。</li><li>SO_TIMEOUT<br>以毫秒为单位定义套接字超时(SO_TIMEOUT)，它是等待数据的超时，或者换句话说，是两个连续数据包之间的最大活动周期。超时值为0将被解释为无限超时。如果没有设置该参数，读取操作将不会超时(无穷小超时)。个人思考：在NIO编程开发中应该不要设置该值，但为了保证每个连接的读平等，Netty会控制一次事件选择周期，最多可调用read方法的次数。</li><li>TCP_NODELAY<br>在TCP数据包发送的时候，有一种算法（Nagle算法）。该算法的核心是如果发生数据包比较小，为了提高带宽的利用率，会等待更多的数据到达后再发送或等待超时后将小包发送，也就是TCP发送延迟，TCP_NODELAY=true表示不使用tcp delay延迟，故禁用Nagle算法。通常接受端的ACK包也会使用延迟（默认40ms)，旨在合并多个ACK确认包。<br>Nagle 算法的改进在于：如果发送端欲多次发送包含少量字符的数据包(一般情况下,后面统一称长度小于MSS的数据包为小包,与此相对,称长度等于MSS的数据包为大包,为了某些对比说明,还有中包,即长度比小包长,但又不足一个MSS的包;MSS,TCP最大分段大小,以太网下一般就是1460字节。),则发送端会先将第一个小包发送出去,而将后面到达的少量字符数据都缓存起来而不立即发送,直到收到接收端对前一个数据包报文段的ACK确认、或当前字符属于紧急数据,或者积攒到了一定数量的数据(比如缓存的字符数据已经达到数据包报文段的最大长度)等多种情况才将其组成一个较大的数据包发送出去。</li></ul><h2 id="4、Channel-NIO-继承图"><a href="#4、Channel-NIO-继承图" class="headerlink" title="4、Channel NIO 继承图"></a>4、Channel NIO 继承图</h2><p>Channel 类继承图主要是想展示一下与 NIO 相关的 NioSocketChannel (客户端通道)与NioServerSocketChannel (服务端通道)在 Channel 中的位置。<br><img src="https://img-blog.csdnimg.cn/20201129212730624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Channel 通道统一抽象接口。</p><ul><li>AbstractChannel 通道默认抽象实现类</li><li>AbstractEpollChannel unix Epoll通道实现</li><li>AbstractOioChannel 阻塞IO通道抽象类</li><li>AbstractNioChannel NIO通道抽象类</li><li>AbstractNioByteChannel NIO客户端通道抽象类</li><li>AbstractNIoMessageChannel NIO服务端通道抽象类</li><li>NioSocketChannel  NIO客户端通道实现类</li><li>NioServerSocketChannel NIO服务端通道实现类</li></ul></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;专栏介绍：《让天下没有难学的Netty》系列，基于 Netty，以源码分析为主要手段，关键流程给出流程图，从 通道篇、内存篇、性能篇三个维度深度剖析 Netty 的实现原理。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1、通道概述&quot;&gt;&lt;a href=&quot;#1、通道概述&quot; class=&quot;headerlink&quot; title=&quot;1、通道概述&quot;&gt;&lt;/a&gt;1、通道概述&lt;/h2&gt;&lt;p&gt;我们从如下几个方面来简单了解一下 Channel。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通道的当前状态，open(端口打开)、connect(连接)。&lt;/li&gt;
&lt;li&gt;通道的配置，包含通道的配置属性与网络通信选项(ChannelOption)。&lt;/li&gt;
&lt;li&gt;IO 通道方法诸如 read、write、connect、bind 与管道(ChannelPipeline)。&lt;/li&gt;
&lt;li&gt;所有 IO 操作在 Netty 中都是异步的，调用 IO 方法例如 write 方法后，并不是等 IO 操作实际完成后再返回，而是会立即返回一个凭证，IO 操作完成后会将结果写入凭证中，典型的 Future设计模式。&lt;/li&gt;
&lt;li&gt;Channel 具有父子关系，由于所有的 SocketChannel（客户端发起TCP连接）都是由 ServerSocketChannel（服务端接收连接）接收客户端连接而创建的，故 SocketChannel 的 parent() 方法会返回对应的 ServerSocketChannel。&lt;/li&gt;
&lt;li&gt;所有通道对象在使用完后，请务必调用通道的colse方法来释放资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本节将从如下3个方面来重点介绍Channel。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Channel 常用API&lt;/li&gt;
&lt;li&gt;Channel 配置与选项&lt;/li&gt;
&lt;li&gt;NIO相关的Channel继承图&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="netty4" scheme="http://example.com/categories/netty4/"/>
    
    
    <category term="netty4" scheme="http://example.com/tags/netty4/"/>
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="ChannelHandler" scheme="http://example.com/tags/ChannelHandler/"/>
    
  </entry>
  
  <entry>
    <title>Netty4 Channel 概述</title>
    <link href="http://example.com/posts/a79560fc.html"/>
    <id>http://example.com/posts/a79560fc.html</id>
    <published>2020-12-11T14:53:01.000Z</published>
    <updated>2020-12-11T15:22:06.436Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p>专栏介绍：《让天下没有难学的Netty》系列，基于 Netty，以源码分析为主要手段，关键流程给出流程图，从 通道篇、内存篇、性能篇三个维度深度剖析 Netty 的实现原理。 </p></blockquote><h2 id="1、通道概述"><a href="#1、通道概述" class="headerlink" title="1、通道概述"></a>1、通道概述</h2><p>我们从如下几个方面来简单了解一下 Channel。</p><ul><li>通道的当前状态，open(端口打开)、connect(连接)。</li><li>通道的配置，包含通道的配置属性与网络通信选项(ChannelOption)。</li><li>IO 通道方法诸如 read、write、connect、bind 与管道(ChannelPipeline)。</li><li>所有 IO 操作在 Netty 中都是异步的，调用 IO 方法例如 write 方法后，并不是等 IO 操作实际完成后再返回，而是会立即返回一个凭证，IO 操作完成后会将结果写入凭证中，典型的 Future设计模式。</li><li>Channel 具有父子关系，由于所有的 SocketChannel（客户端发起TCP连接）都是由 ServerSocketChannel（服务端接收连接）接收客户端连接而创建的，故 SocketChannel 的 parent() 方法会返回对应的 ServerSocketChannel。</li><li>所有通道对象在使用完后，请务必调用通道的colse方法来释放资源。</li></ul><p>本节将从如下3个方面来重点介绍Channel。</p><ul><li>Channel 常用API</li><li>Channel 配置与选项</li><li>NIO相关的Channel继承图</li></ul><a id="more"></a><h2 id="2、Channel常用API"><a href="#2、Channel常用API" class="headerlink" title="2、Channel常用API"></a>2、Channel常用API</h2><p>Channel 类图结构如下：<br><img src="https://img-blog.csdnimg.cn/20201129210717360.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>核心API一览：</p><ul><li>EventLoop eventLoop()<br>返回该通道注册的事件轮询器。</li><li>Channel parent()<br>返回该通道的父通道，如果是ServerSocketChannel实例则返回null，SocketChannel实例则返回对应的ServerSocketChannel。</li><li>ChannelConfig config()<br>返回该通道的配置参数。</li><li>boolean isOpen()<br>端口是否处于open，通道默认一创建isOpen方法就会返回true，close方法被调用后该方法返回false。</li><li>boolean isRegistered()<br>是否已注册到EventLoop。</li><li>public boolean isActive()<br>通道是否处于激活。NioSocketChannel的实现是java.nio.channels.SocketChannel实例的isOpen()与isConnected()都返回true。NioServerSocketChannel的实现是ServerSocketChannel.socket().isBound()，如果绑定到端口中，意味着处于激活状态。</li><li>ChannelFuture closeFuture()<br>Future模式的应用，调用该方法的目的并不是关闭通道，而是预先创建一个凭证(Future)，等通道关闭时，会通知该Future，用户可以通过该Future注册事件。</li><li>ChannelFuture bind(SocketAddress localAddress)<br>Netty服务端绑定到本地端口，开始监听客户端的连接请求。该过程会触发事件链(ChannelPipeline)。该部分将在后续讲解服务端启动流程时再详细分析。</li><li>ChannelFuture connect(SocketAddress remoteAddress)<br>Netty客户端连接到服务端，该过程同样会触发一系列事件(ChannelPipeline)。该部分将在后续讲解客户端启动流程时再详细分析。</li><li>ChannelFuture disconnect()<br>断开连接，但不会释放资源，该通道还可以再通过connect重新与服务器建立连接。</li><li>ChannelFuture close()<br>关闭通道，回收资源，该通道的生命周期完全结束。</li><li>ChannelFuture deregister()<br>取消注册。</li><li>Channel read()<br>通道读，该方法并不是直接从读写缓存区读取文件，而是向NIO Selecor注册读事件（目前主要基于NIO）。当通道收到对端的数后，事件选择器会处理读事件，从而触发ChannelInboundHandler#channelRead 事件，然后继续触发ChannelInboundHandler#channelReadComplete(ChannelHandlerContext)事件。</li><li>ChannelFuture write(Object msg)<br>向通道写字节流，会触发响应的写事件链，该方法只是会将字节流写入到通道缓存区，并不会调用flush方法写入通道中。</li><li>Channel flush()<br>刷写所有挂起的消息（刷写到流中）。</li><li>ChannelFuture writeAndFlush(Object msg)<br>相当于调用write与flush方法。</li></ul><h2 id="3、Channel配置与选项"><a href="#3、Channel配置与选项" class="headerlink" title="3、Channel配置与选项"></a>3、Channel配置与选项</h2><h4 id="3-1-Channel配置"><a href="#3-1-Channel配置" class="headerlink" title="3.1 Channel配置"></a>3.1 Channel配置</h4><p>ChannelConfig 的类图如下：<br><img src="https://img-blog.csdnimg.cn/20201129210953154.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>核心配置如下：</p><ul><li>Map&lt;ChannelOption&lt;?&gt;, Object&gt; options：选项，在下文会重点介绍。</li><li>int connectTimeoutMillis：连接超时时间。</li><li>int maxMessagesPerRead：每次读事件中调用读方法的最大次数(AbstractNioByteChannel)或读事件循环中最多处理的消息条数(AbstractNioMessageChannel)。</li><li>int writeSpinCount：一次写事件处理期间最多调用write方法的次数，引入该机制主要是为了避免一个网络通道写入大量数据，对其他网络通道的读写处理带来延迟，默认值为16。</li><li>ByteBufAllocator getAllocator()：返回该通道的内存分配器(ByteBuf)。<br>RecvByteBufAllocator getRecvByteBufAllocator()：读事件读缓冲区的分配策略。</li><li>boolean autoRead：是否自动触发read方法调用，默认为true，读事件触发后自动调用read方法 ，而无需应用程序显示调用。</li><li>int writeBufferHighWaterMark：设置写缓存区的高水位线。如果写缓存区中的数据超过该值，Channel#isWritable()方法将返回false。</li><li>int writeBufferLowWaterMark：设置写缓存区的低水位线。如果写缓存区的数据超过高水位线后，通道将变得不可写，等写缓存数据降低到低水位线后通道恢复可写状态(Channel#isWritable()将再次返回true)。<h4 id="3-2-ChannelOption"><a href="#3-2-ChannelOption" class="headerlink" title="3.2 ChannelOption"></a>3.2 ChannelOption</h4><img src="https://img-blog.csdnimg.cn/20201129211116360.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>网络通道(Channel)选项值，下面介绍一下与TCP协议相关的核心参数：</li><li>SO_BROADCAST<br>选择值类型:boolean。表值该数据包是否是广播包，true表示广播包，false表示非广播，如果包的IP地址为广播地址，但该选型为false，则在内核层会抛出错误。</li><li>SO_KEEPALIVE<br>对于面向连接的TCP socket,在实际应用中通常都要检测对端是否处于连接中,连接端口分两种情况:<ul><li><pre><code>连接正常关闭,调用close() shutdown()连接优雅关闭,send与recv立马返回错误,select返回SOCK_ERR</code></pre></li><li><pre><code>连接的对端异常关闭,比如网络断掉,突然断电.</code></pre></li></ul></li><li>SO_SNDBUF的大小<br>为了达到最大网络吞吐，socket send buffer size(SO_SNDBUF)不应该小于带宽和延迟的乘积。</li><li>SO_REUSEADDR<br>该参数如果设置为true的一个常用应用场景是端口复用(直接复用TIME_WAIT状态的socket)。</li><li>SO_LINGER<br>该参数是控制TCP关闭行为的。</li><li>SO_BACKLOG<br>服务端接受客户端连接的处理队列，在TCP三次握手协议中，服务端接收到客户端的SYN包后，会向客户端发送SYN+ACK包，同时会将连接放入到 backlog 队列中，等待客户端ACK包。在服务端没有接收到客户端的ACK包之前，连接会暂存 backlog 队列。</li><li>SO_TIMEOUT<br>以毫秒为单位定义套接字超时(SO_TIMEOUT)，它是等待数据的超时，或者换句话说，是两个连续数据包之间的最大活动周期。超时值为0将被解释为无限超时。如果没有设置该参数，读取操作将不会超时(无穷小超时)。个人思考：在NIO编程开发中应该不要设置该值，但为了保证每个连接的读平等，Netty会控制一次事件选择周期，最多可调用read方法的次数。</li><li>TCP_NODELAY<br>在TCP数据包发送的时候，有一种算法（Nagle算法）。该算法的核心是如果发生数据包比较小，为了提高带宽的利用率，会等待更多的数据到达后再发送或等待超时后将小包发送，也就是TCP发送延迟，TCP_NODELAY=true表示不使用tcp delay延迟，故禁用Nagle算法。通常接受端的ACK包也会使用延迟（默认40ms)，旨在合并多个ACK确认包。<br>Nagle 算法的改进在于：如果发送端欲多次发送包含少量字符的数据包(一般情况下,后面统一称长度小于MSS的数据包为小包,与此相对,称长度等于MSS的数据包为大包,为了某些对比说明,还有中包,即长度比小包长,但又不足一个MSS的包;MSS,TCP最大分段大小,以太网下一般就是1460字节。),则发送端会先将第一个小包发送出去,而将后面到达的少量字符数据都缓存起来而不立即发送,直到收到接收端对前一个数据包报文段的ACK确认、或当前字符属于紧急数据,或者积攒到了一定数量的数据(比如缓存的字符数据已经达到数据包报文段的最大长度)等多种情况才将其组成一个较大的数据包发送出去。</li></ul><h2 id="4、Channel-NIO-继承图"><a href="#4、Channel-NIO-继承图" class="headerlink" title="4、Channel NIO 继承图"></a>4、Channel NIO 继承图</h2><p>Channel 类继承图主要是想展示一下与 NIO 相关的 NioSocketChannel (客户端通道)与NioServerSocketChannel (服务端通道)在 Channel 中的位置。<br><img src="https://img-blog.csdnimg.cn/20201129212730624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Channel 通道统一抽象接口。</p><ul><li>AbstractChannel 通道默认抽象实现类</li><li>AbstractEpollChannel unix Epoll通道实现</li><li>AbstractOioChannel 阻塞IO通道抽象类</li><li>AbstractNioChannel NIO通道抽象类</li><li>AbstractNioByteChannel NIO客户端通道抽象类</li><li>AbstractNIoMessageChannel NIO服务端通道抽象类</li><li>NioSocketChannel  NIO客户端通道实现类</li><li>NioServerSocketChannel NIO服务端通道实现类</li></ul></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;专栏介绍：《让天下没有难学的Netty》系列，基于 Netty，以源码分析为主要手段，关键流程给出流程图，从 通道篇、内存篇、性能篇三个维度深度剖析 Netty 的实现原理。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1、通道概述&quot;&gt;&lt;a href=&quot;#1、通道概述&quot; class=&quot;headerlink&quot; title=&quot;1、通道概述&quot;&gt;&lt;/a&gt;1、通道概述&lt;/h2&gt;&lt;p&gt;我们从如下几个方面来简单了解一下 Channel。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通道的当前状态，open(端口打开)、connect(连接)。&lt;/li&gt;
&lt;li&gt;通道的配置，包含通道的配置属性与网络通信选项(ChannelOption)。&lt;/li&gt;
&lt;li&gt;IO 通道方法诸如 read、write、connect、bind 与管道(ChannelPipeline)。&lt;/li&gt;
&lt;li&gt;所有 IO 操作在 Netty 中都是异步的，调用 IO 方法例如 write 方法后，并不是等 IO 操作实际完成后再返回，而是会立即返回一个凭证，IO 操作完成后会将结果写入凭证中，典型的 Future设计模式。&lt;/li&gt;
&lt;li&gt;Channel 具有父子关系，由于所有的 SocketChannel（客户端发起TCP连接）都是由 ServerSocketChannel（服务端接收连接）接收客户端连接而创建的，故 SocketChannel 的 parent() 方法会返回对应的 ServerSocketChannel。&lt;/li&gt;
&lt;li&gt;所有通道对象在使用完后，请务必调用通道的colse方法来释放资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本节将从如下3个方面来重点介绍Channel。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Channel 常用API&lt;/li&gt;
&lt;li&gt;Channel 配置与选项&lt;/li&gt;
&lt;li&gt;NIO相关的Channel继承图&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="netty4" scheme="http://example.com/categories/netty4/"/>
    
    
    <category term="netty4" scheme="http://example.com/tags/netty4/"/>
    
    <category term="Channel" scheme="http://example.com/tags/Channel/"/>
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>快速排序算法java版实现</title>
    <link href="http://example.com/posts/42760d48.html"/>
    <id>http://example.com/posts/42760d48.html</id>
    <published>2020-12-09T15:26:35.000Z</published>
    <updated>2020-12-11T14:09:58.446Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>快速排序思想：从待排序序列中找到一个关键字（默认为第一个元素） 然后将比关键字少的数据排列在左边，大于关键字的排在右边，然后对关键字左右两边的序列继续上面步骤，直至关键字两边的序列都已经排好序。具体算法如下：</p><p>设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，</p><p> 然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。<br> 值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。<br> 一趟快速排序的算法是：<br> 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br> 2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；<br> 3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；<br> 4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；<br> 5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,<br> 4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。</p><p> 找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</p><blockquote><p>温馨提示：上述算法的描述来源与百度，大家也可以按照上面的算法，用自己熟悉的语言尝试实现一遍。</p></blockquote><p>一言不合继续用代码说话。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> persistent.prestige.console.algorithm;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，</span></span><br><span class="line"><span class="comment"> * 然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。</span></span><br><span class="line"><span class="comment"> * 值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。</span></span><br><span class="line"><span class="comment"> * 一趟快速排序的算法是：</span></span><br><span class="line"><span class="comment"> * 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；</span></span><br><span class="line"><span class="comment"> * 2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；</span></span><br><span class="line"><span class="comment"> * 3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；</span></span><br><span class="line"><span class="comment"> * 4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；</span></span><br><span class="line"><span class="comment"> * 5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,</span></span><br><span class="line"><span class="comment"> * 4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。</span></span><br><span class="line"><span class="comment"> * 找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lenovo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> hign )</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(hign &lt;= low) <span class="keyword">return</span>; <span class="comment">// 如果hign 小于等于 low ,说明待排序队列只包含一个元素，无法再排序</span></span><br><span class="line"><span class="keyword">int</span> keyIdx = asort(a, low, hign); </span><br><span class="line"><span class="keyword">if</span>( ! (keyIdx == low &amp;&amp; low == hign) ) &#123; <span class="comment">// keyIdx == low &amp;&amp; low == hign 则说明不可分</span></span><br><span class="line"><span class="keyword">if</span>(keyIdx == low ) &#123; <span class="comment">//说明左边已经排好序了</span></span><br><span class="line">quickSort(a, low + <span class="number">1</span>, hign);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>  (keyIdx == hign ) &#123;  <span class="comment">// 说明右边已经排序好了</span></span><br><span class="line">quickSort(a, low, hign -<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">quickSort(a, low , keyIdx -<span class="number">1</span>); <span class="comment">// 关键字左边排序</span></span><br><span class="line">quickSort(a, keyIdx + <span class="number">1</span>, hign); <span class="comment">// 关键字右边排序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序   一趟排序算法实现</span></span><br><span class="line"><span class="comment"> * 一趟快速排序的算法是：(来源于百度百科)</span></span><br><span class="line"><span class="comment"> * 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；</span></span><br><span class="line"><span class="comment"> * 2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；</span></span><br><span class="line"><span class="comment"> * 3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；</span></span><br><span class="line"><span class="comment"> * 4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；</span></span><br><span class="line"><span class="comment"> * 5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,</span></span><br><span class="line"><span class="comment"> * 4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。</span></span><br><span class="line"><span class="comment"> * 找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> low       待排序起始下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hign      待排序结束下标  (low hign) 限制排序数组范围</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>          本轮排序后，关键字所在位置(下标)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">asort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> hign)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> key = a[low];</span><br><span class="line">loop :</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">// low 与 hign 相等时退出</span></span><br><span class="line"><span class="keyword">while</span>( hign &gt; <span class="number">0</span> ) &#123;</span><br><span class="line"><span class="keyword">if</span>( a[hign] &lt; key ) &#123;</span><br><span class="line">swap(a, low, hign);   <span class="comment">// 从后向前找，找到第一个比关键字小的元素后交换元素后跳出本次比较</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">hign --;</span><br><span class="line"><span class="keyword">if</span>(low == hign) <span class="keyword">break</span> loop;</span><br><span class="line">&#125;</span><br><span class="line">low ++; </span><br><span class="line"><span class="keyword">if</span>(low == hign) <span class="keyword">break</span> loop;</span><br><span class="line"><span class="keyword">while</span>( low &lt; a.length ) &#123;</span><br><span class="line"><span class="keyword">if</span>( a[low] &gt; key ) &#123;   <span class="comment">// 从前向后找，找到第一个比关键字大的元素时交换元素后跳出本次比较</span></span><br><span class="line">swap(a, low, hign);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">low ++; </span><br><span class="line"><span class="keyword">if</span>(low == hign) <span class="keyword">break</span> loop;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> low;<span class="comment">//关键字所在的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换数组中两个元素的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = a[i];</span><br><span class="line">a[i] = a[j];</span><br><span class="line">a[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">&quot;待排序数据：(5,8,2,10,6,9,21,18,19,7)&quot;</span>);</span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">21</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">7</span>&#125;;</span><br><span class="line">quickSort(a, <span class="number">0</span>, a.length -<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;排序后结果：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot; ---------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;待排序数据：(5,8,2,10,5,9,21,18,8,7)&quot;</span>);</span><br><span class="line">a = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">21</span>,<span class="number">18</span>,<span class="number">8</span>,<span class="number">7</span>&#125;;</span><br><span class="line">quickSort(a, <span class="number">0</span>, a.length -<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;排序后结果：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;快速排序思想：从待排序序列中找到一个关键字（默认为第一个元素） 然后将比关键字少的数据排列在左边，大于关键字的排在右边，然后对关键字左右两边的序列继续上面步骤，直至关键字两边的序列都已经排好序。具体算法如下：&lt;/p&gt;
&lt;p&gt;设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，&lt;/p&gt;
&lt;p&gt; 然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。&lt;br&gt; 值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。&lt;br&gt; 一趟快速排序的算法是：&lt;br&gt; 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；&lt;br&gt; 2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；&lt;br&gt; 3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；&lt;br&gt; 4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；&lt;br&gt; 5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,&lt;br&gt; 4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。&lt;/p&gt;
&lt;p&gt; 找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;温馨提示：上述算法的描述来源与百度，大家也可以按照上面的算法，用自己熟悉的语言尝试实现一遍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一言不合继续用代码说话。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序二叉树JAVA版实现</title>
    <link href="http://example.com/posts/3b6094a6.html"/>
    <id>http://example.com/posts/3b6094a6.html</id>
    <published>2020-12-09T15:22:35.000Z</published>
    <updated>2020-12-11T14:09:24.453Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>1、排序二叉树特点</p><ul><li>根节点的值大于等于左子树的节点</li><li>根节点的值小于等于它右子树的节点。</li></ul><p>2、遍历二叉树的方法</p><ul><li>先序遍历：先遍历根节点，然后遍历左子树，再遍历右子树</li><li>中序遍历：先遍历左子树，然后遍历根节点，再遍历右子树</li><li>后续遍历  </li></ul><p><strong>如果要保证节点从小到大排序，采用中序遍历</strong>；</p><p>一言不合就写代码实现，提供详细的可视化角度（代码可运行）。</p><p>目前代码中，已经实现 新增单个元素、删除单个元素、中序遍历整颗树。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br></pre></td><td class="code"><pre><span class="line">package persistent.prestige.study.datastructures.tree;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.List;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 二叉树学习</span><br><span class="line"> * </span><br><span class="line">在数据结构里，</span><br><span class="line">就是对一棵二叉树所有结点的访问</span><br><span class="line">前序遵循“根左右”</span><br><span class="line">中序遵循“左根右”</span><br><span class="line">后序遵循“左右根”</span><br><span class="line">根：根节点</span><br><span class="line">左：左子女</span><br><span class="line">右：右子女</span><br><span class="line">如：一棵二叉树 ：</span><br><span class="line">           A</span><br><span class="line">          &#x2F; \</span><br><span class="line">         B   C</span><br><span class="line">        &#x2F; \ </span><br><span class="line">       D   E</span><br><span class="line">前序访问顺序就是：ABDEC（根一定第一个）</span><br><span class="line">中序访问顺序就是：DBEAC（根一定在中间）</span><br><span class="line">后序访问顺序就是：DEBCA（根一定在最后）</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * @author prestigeding@126.com</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BinaryTree&lt;E&gt; implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * </span><br><span class="line"> *&#x2F;</span><br><span class="line">private static final long serialVersionUID &#x3D; -3970337667739333043L;</span><br><span class="line"></span><br><span class="line">private Comparator&lt;E&gt; comparator;</span><br><span class="line"></span><br><span class="line">private TreeNode&lt;E&gt; root;</span><br><span class="line"></span><br><span class="line">public BinaryTree() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public BinaryTree(Comparator&lt;E&gt; comparator) &#123;</span><br><span class="line">super();</span><br><span class="line">this.comparator &#x3D; comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 增加元素</span><br><span class="line"> * @param e</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">if(e &#x3D;&#x3D; null) return false;</span><br><span class="line"></span><br><span class="line">if(root &#x3D;&#x3D; null ) &#123;</span><br><span class="line">root &#x3D; new TreeNode&lt;E&gt;(e, null);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add0(root, e);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> *                          10</span><br><span class="line"> *                     &#x2F;          \</span><br><span class="line"> *                    3           18</span><br><span class="line"> *                  &#x2F;   \        &#x2F;   \               </span><br><span class="line"> *                 2     4      13    21       </span><br><span class="line"> *                         \</span><br><span class="line"> *                          9</span><br><span class="line"> *                        &#x2F;   \</span><br><span class="line"> *                       8     9 </span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * @param root</span><br><span class="line"> * @param e</span><br><span class="line"> *&#x2F;</span><br><span class="line">private TreeNode&lt;E&gt; add0(TreeNode&lt;E&gt; root, E e) &#123;</span><br><span class="line">final TreeNode&lt;E&gt; curNode &#x3D; root;</span><br><span class="line"></span><br><span class="line">int cmp &#x3D; compare(e, curNode.value);</span><br><span class="line">if(cmp &lt; 0 ) &#123; &#x2F;&#x2F;表示待插入的节点值，比当前节点值小</span><br><span class="line">if(curNode.left &#x3D;&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F;创建当前节点的左节点</span><br><span class="line">TreeNode&lt;E&gt; newNode &#x3D; new TreeNode&lt;E&gt;(e, curNode);</span><br><span class="line">curNode.left &#x3D; newNode;</span><br><span class="line">return newNode;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return add0(curNode.left, e);&#x2F;&#x2F;遍历左子树</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123; &#x2F;&#x2F; 大于等于0，右子树</span><br><span class="line">if(curNode.right &#x3D;&#x3D; null ) &#123;</span><br><span class="line">&#x2F;&#x2F;创建当前节点的右节点</span><br><span class="line">TreeNode&lt;E&gt; newNode &#x3D; new TreeNode&lt;E&gt;(e, curNode);</span><br><span class="line">curNode.right &#x3D; newNode;</span><br><span class="line">return newNode;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return add0(curNode.right, e);&#x2F;&#x2F;遍历右子树</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 比较两个元素的大小</span><br><span class="line"> * @param e1</span><br><span class="line"> * @param e2</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">private int compare(E e1, E e2) &#123;</span><br><span class="line">return comparator &#x3D;&#x3D; null ?  ((Comparable&lt;E&gt;) e1 ).compareTo(e2) : comparator.compare(e1, e2);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * </span><br><span class="line"> * 删除元素</span><br><span class="line"> * @param e  </span><br><span class="line"> * @return  如果返回ture,表示删除成功,如果返回false,表示删除失败，没有找到元素</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean remove(E e) &#123;</span><br><span class="line">if( e &#x3D;&#x3D; null ) return false;</span><br><span class="line"></span><br><span class="line">TreeNode&lt;E&gt; cur &#x3D; root;</span><br><span class="line">int cmp;</span><br><span class="line">while (cur !&#x3D; null ) &#123;</span><br><span class="line">if(e.equals(cur.value)) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">cmp &#x3D; compare(e, root.value);</span><br><span class="line">if(cmp &lt; 0 ) &#123; &#x2F;&#x2F;表示待删除的节点值，比当前节点值小</span><br><span class="line">cur &#x3D; cur.left;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">cur &#x3D; cur.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(cur !&#x3D; null ) &#123; &#x2F;&#x2F;找到了元素，需要删除该元素</span><br><span class="line">TreeNode&lt;E&gt; cLeft &#x3D; cur.left;</span><br><span class="line">TreeNode&lt;E&gt; cRight &#x3D; cur.right;</span><br><span class="line"></span><br><span class="line">if(cLeft !&#x3D; null ) &#123; &#x2F;&#x2F;如果被删除节点的左子树不为空，则将左子树放入当前节点的位置</span><br><span class="line">remove0(cLeft, cur);</span><br><span class="line">if(cLeft.right !&#x3D; null &amp;&amp;  cur.right !&#x3D; null) &#123; &#x2F;&#x2F;需要移动相应节点</span><br><span class="line">TreeNode&lt;E&gt; wNode &#x3D; cLeft.right;</span><br><span class="line">cLeft.right &#x3D; cur.right;</span><br><span class="line">wNode.parent &#x3D; null;</span><br><span class="line">TreeNode&lt;E&gt; newNode &#x3D; add0(cLeft, wNode.value);</span><br><span class="line">newNode.left &#x3D; wNode.left;</span><br><span class="line">newNode.right &#x3D; wNode.right;</span><br><span class="line">wNode &#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">remove0(cRight, cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将当前节点释放，，help GC</span><br><span class="line">cur.value &#x3D; null;</span><br><span class="line">cur.right &#x3D; null;</span><br><span class="line">cur.left &#x3D; null;</span><br><span class="line">cur.parent &#x3D; null;</span><br><span class="line">cur &#x3D; null;</span><br><span class="line"></span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void remove0(TreeNode&lt;E&gt; newNode, TreeNode&lt;E&gt; cur) &#123;</span><br><span class="line">TreeNode&lt;E&gt; parent &#x3D; cur.parent;</span><br><span class="line">newNode.parent &#x3D; parent;</span><br><span class="line">if(cur.parent.left &#x3D;&#x3D; cur) &#123;</span><br><span class="line">cur.parent.left &#x3D; newNode;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">cur.parent.right &#x3D; newNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 中序遍历</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void middleOrderTraversal() &#123;</span><br><span class="line">System.out.println(&quot;----------中序遍历开始---------\n&quot;);</span><br><span class="line">if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">System.out.print(&quot;二叉树&quot;);</span><br><span class="line">System.out.println(&quot;----------中序遍历结束---------\n&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">middleOrderTraversal0(root);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;\n----------中序遍历结束---------\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 中序遍历</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void middleOrderTraversal0(TreeNode&lt;E&gt; root) &#123;</span><br><span class="line">if (root &#x3D;&#x3D; null)</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">final TreeNode&lt;E&gt; cur &#x3D; root;</span><br><span class="line">if (cur.left !&#x3D; null) &#123;</span><br><span class="line">middleOrderTraversal0(cur.left);</span><br><span class="line">System.out.print(toObjectString(cur.value) + &quot;,&quot;);</span><br><span class="line">middleOrderTraversal0(cur.right);</span><br><span class="line">&#125; else if (cur.right !&#x3D; null) &#123;</span><br><span class="line">System.out.print(cur.value + &quot;,&quot;);</span><br><span class="line">middleOrderTraversal0(cur.right);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; 此时输出节点</span><br><span class="line">System.out.print(cur.value + &quot;,&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public TreeNode&lt;E&gt; getRoot() &#123;</span><br><span class="line">return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setRoot(TreeNode&lt;E&gt; root) &#123;</span><br><span class="line">this.root &#x3D; root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private String toObjectString(E value) &#123;</span><br><span class="line">return value &#x3D;&#x3D; null ? &quot;&quot; : value.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 二叉数</span><br><span class="line"> * </span><br><span class="line"> * @author Administrator</span><br><span class="line"> *</span><br><span class="line"> * @param &lt;E&gt;</span><br><span class="line"> *&#x2F;</span><br><span class="line">@SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">private final static class TreeNode&lt;E&gt; implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">private static final long serialVersionUID &#x3D; 6540618639489225256L;</span><br><span class="line"></span><br><span class="line">public E value;</span><br><span class="line">public TreeNode&lt;E&gt; left;</span><br><span class="line">public TreeNode&lt;E&gt; right;</span><br><span class="line"></span><br><span class="line">public TreeNode&lt;E&gt; parent;</span><br><span class="line"></span><br><span class="line">public TreeNode(E value, TreeNode&lt;E&gt; parent) &#123;</span><br><span class="line">super();</span><br><span class="line">this.value &#x3D; value;</span><br><span class="line">this.parent &#x3D; parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public TreeNode(E value, TreeNode&lt;E&gt; left, TreeNode&lt;E&gt; right, TreeNode&lt;E&gt; parent) &#123;</span><br><span class="line">super();</span><br><span class="line">this.value &#x3D; value;</span><br><span class="line">this.left &#x3D; left;</span><br><span class="line">this.right &#x3D; right;</span><br><span class="line">this.parent &#x3D; parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">if(value !&#x3D; null)</span><br><span class="line">return value.toString();</span><br><span class="line"></span><br><span class="line">return super.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** *******************测试 start ***************************&#x2F;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;测试开始&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;BinaryTree&lt;Integer&gt; t &#x3D; new BinaryTree&lt;Integer&gt;();</span><br><span class="line">&#x2F;&#x2F;t.setRoot(t.initTree());</span><br><span class="line">&#x2F;&#x2F;t.middleOrderTraversal();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;先研究一下 Comparator o1 &gt; o2 的排序逻辑</span><br><span class="line">&#x2F;&#x2F;testSort();</span><br><span class="line"></span><br><span class="line">&#x2F;* *                          10</span><br><span class="line"> *                     &#x2F;              \</span><br><span class="line"> *                    3                18</span><br><span class="line"> *                  &#x2F;   \            &#x2F;   \               </span><br><span class="line"> *                 2     4          13    21       </span><br><span class="line"> *                         \       &#x2F;  \  </span><br><span class="line"> *                          9     11    15  </span><br><span class="line"> *                        &#x2F;   \</span><br><span class="line"> *                       8     9 </span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; add 方法测试</span><br><span class="line">BinaryTree&lt;Integer&gt; t &#x3D; new BinaryTree&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;t.add(new Integer(10));</span><br><span class="line">&#x2F;&#x2F;t.add(new Integer(18));</span><br><span class="line">&#x2F;&#x2F;t.add(new Integer(3));</span><br><span class="line">&#x2F;&#x2F;t.add(new Integer(2));</span><br><span class="line">&#x2F;&#x2F;t.add(new Integer(4));</span><br><span class="line">&#x2F;&#x2F;t.add(new Integer(8));</span><br><span class="line">&#x2F;&#x2F;t.add(new Integer(9));</span><br><span class="line">&#x2F;&#x2F;t.add(new Integer(9));</span><br><span class="line">&#x2F;&#x2F;t.add(new Integer(21));</span><br><span class="line">&#x2F;&#x2F;t.add(new Integer(13));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t.add(new Integer(10));</span><br><span class="line">t.add(new Integer(18));</span><br><span class="line">t.add(new Integer(3));</span><br><span class="line">t.add(new Integer(9));</span><br><span class="line">t.add(new Integer(8));</span><br><span class="line">t.add(new Integer(2));</span><br><span class="line">t.add(new Integer(21));</span><br><span class="line">t.add(new Integer(4));</span><br><span class="line">t.add(new Integer(9));</span><br><span class="line">t.add(new Integer(13));</span><br><span class="line">t.add(new Integer(11));</span><br><span class="line">t.add(new Integer(15));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;查看数结构，中序遍历</span><br><span class="line">t.middleOrderTraversal();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;测试删除</span><br><span class="line">System.out.println(&quot;删除节点18&quot;);</span><br><span class="line">t.remove(new Integer(18));</span><br><span class="line">System.err.println(&quot;删除节点18号的排序二叉树&quot;);</span><br><span class="line">t.middleOrderTraversal();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;测试结束&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 当用升序排序时，则 o1 &gt; o2 时要返回大于0的数</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static void testSort() &#123;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; a &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">a.add(1);</span><br><span class="line">a.add(8);</span><br><span class="line">a.add(9);</span><br><span class="line">a.add(3);</span><br><span class="line">a.add(5);</span><br><span class="line"></span><br><span class="line">Collections.sort(a, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line"></span><br><span class="line">return o1.intValue() &gt; o2.intValue() ? 1 : -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(a);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 用来测试的，后续会完善 加入元素</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> *                          </span><br><span class="line"> *                          10</span><br><span class="line"> *                     &#x2F;          \</span><br><span class="line"> *                    3           18</span><br><span class="line"> *                  &#x2F;   \        &#x2F;   \               </span><br><span class="line"> *                 2     4      13    21       </span><br><span class="line"> *                         \</span><br><span class="line"> *                          9</span><br><span class="line"> *                        &#x2F;   \</span><br><span class="line"> *                       8     9 </span><br><span class="line"> *                       </span><br><span class="line"> *                       </span><br><span class="line"></span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Deprecated</span><br><span class="line">public TreeNode&lt;Integer&gt; initTree() &#123;</span><br><span class="line">TreeNode&lt;Integer&gt; _root &#x3D; new TreeNode&lt;Integer&gt;(new Integer(10), null); &#x2F;&#x2F; 根节点</span><br><span class="line"></span><br><span class="line">TreeNode&lt;Integer&gt; l3 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(3), _root);</span><br><span class="line">_root.left &#x3D; l3;</span><br><span class="line"></span><br><span class="line">TreeNode&lt;Integer&gt; l2 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(2), l3);</span><br><span class="line">l3.left &#x3D; l2;</span><br><span class="line"></span><br><span class="line">TreeNode&lt;Integer&gt; l4 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(4), l3);</span><br><span class="line">l3.right &#x3D; l4;</span><br><span class="line"></span><br><span class="line">TreeNode&lt;Integer&gt; l91 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(9), l4);</span><br><span class="line">l4.right &#x3D; l91;</span><br><span class="line"></span><br><span class="line">TreeNode&lt;Integer&gt; l8 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(8), l91);</span><br><span class="line">l91.left &#x3D; l8;</span><br><span class="line"></span><br><span class="line">TreeNode&lt;Integer&gt; l92 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(9), l91);</span><br><span class="line">l91.right &#x3D; l92;</span><br><span class="line"></span><br><span class="line">TreeNode&lt;Integer&gt; l18 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(18), _root);</span><br><span class="line">_root.right &#x3D; l18;</span><br><span class="line"></span><br><span class="line">TreeNode&lt;Integer&gt; l13 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(13), l18);</span><br><span class="line">l18.left &#x3D; l13;</span><br><span class="line"></span><br><span class="line">TreeNode&lt;Integer&gt; l21 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(21), l18);</span><br><span class="line">l18.right &#x3D; l21;</span><br><span class="line"></span><br><span class="line">return _root;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** *******************测试 end ***************************&#x2F;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;1、排序二叉树特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根节点的值大于等于左子树的节点&lt;/li&gt;
&lt;li&gt;根节点的值小于等于它右子树的节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、遍历二叉树的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先序遍历：先遍历根节点，然后遍历左子树，再遍历右子树&lt;/li&gt;
&lt;li&gt;中序遍历：先遍历左子树，然后遍历根节点，再遍历右子树&lt;/li&gt;
&lt;li&gt;后续遍历  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;如果要保证节点从小到大排序，采用中序遍历&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;一言不合就写代码实现，提供详细的可视化角度（代码可运行）。&lt;/p&gt;
&lt;p&gt;目前代码中，已经实现 新增单个元素、删除单个元素、中序遍历整颗树。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java Reference 引用学习总结</title>
    <link href="http://example.com/posts/3c69fbc4.html"/>
    <id>http://example.com/posts/3c69fbc4.html</id>
    <published>2020-12-09T15:12:35.000Z</published>
    <updated>2020-12-11T04:38:09.508Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="1、Java引用的类型"><a href="#1、Java引用的类型" class="headerlink" title="1、Java引用的类型"></a>1、Java引用的类型</h2><p>强引用、软引用(java.lang.ref.SoftReference)、弱引用(java.lang.ref.WeakReference)、虚引用(　java.lang.ref.PhantomReference　)。</p><p>java默认的引用类型为强引用，比如 Object a = new Object();其中 a 为强引用，new Object()为一个具体的对象。</p><p>至于软应用，弱引用，虚引用，就是 JAVA 虚拟机管理对象的范畴了，可以这样理解，SoftReference、WeakReference、PlantomReference 只是一种标记，JAVA 虚拟机在垃圾回收时，对上述不同的标记【引用的对象】采取不同的措施。采取措施如下：</p><ul><li><p>软引用(SoftReference)：当内存足够时，该引用【引用的对象】不会被回收，那什么是内存足够呢？进行年轻代的垃圾回收不会触发SoftReference所指向对象的回收,如果触发Full GC，那SoftReference所指向的对象将被回收。</p></li><li><p>弱引用(WeakReference) :当进行年轻代垃圾回收时，该引用指向的对象，就会被回收。</p></li><li><p>虚引用(PhantomeReference) 该引用指向的对象，无法对垃圾收集器收集对象时产生任何影响，唯一有用的是，如果被垃圾收集器收集的对象，被PhantomeReference标记，垃圾收集器会通过注册在PhantomeReference上的队列来通知应用程序，该引用指向的对象，已经被垃圾收集器回收。</p></li></ul><p>从上文的描述，也清楚的知道，上述应用是直接JVM打交道，更直接的说是与垃圾回收器直接的交互。</p><a id="more"></a><h2 id="2、java-lang-ref-Reference-详解"><a href="#2、java-lang-ref-Reference-详解" class="headerlink" title="2、java.lang.ref.Reference 详解"></a>2、java.lang.ref.Reference 详解</h2><h4 id="2-1-关键数据结构"><a href="#2-1-关键数据结构" class="headerlink" title="2.1 关键数据结构"></a>2.1 关键数据结构</h4><ul><li><p>private T referent;     /* Treated specially by GC */</p></li><li><p>private ReferenceQueue&lt;? super T&gt; queue;</p></li><li><p>private Reference next;<br>非常关键：Reference 本身可以当场一个 Reference 链表使用，在 ReferenceHandler 线程中从 pending 队列中，取出一个Reference, 如果该 Reference 相关的 queue 不为null,则执行入队操作，r.queue.enqueue(r); 参数为当前的引用，在入队列操作时，只要第一次进入队列，该引用的queue会被设置为 ReferenceQueue.ENQUEUE,也就算是再次调用进入队列操作，此时也无法再次与构造方法中传入的队 列绑定  在一起了。</p></li><li><p>private static Reference pending = null<br>关键中的关键；此队列维护着需要进入通知队列的引用，由 JVM 虚拟机垃圾回收器在检测到被引用指向的对象可达性发生改变后，如果该对象的引用（Referecnce）注册了引用队列 (ReferenceQueue),则 JVM 虚拟机垃圾收集器会将该引用加入到 pending 队列，注意这个 pending 队列是一个静态类变量。</p><p>为了便于理解上述的观点，先展示一下引用如何使用。</p><p>SoftReference sf = new SoftReference( new Object() );</p><p>其中sf 为引用，new Object为 sf指向的对象，其实也就是建立了 sf 到 new Object 对象的引用（关联），然后垃圾回收器发现 new Object 的可达性发生变化（其实就是变为不可达后），此时JVM虚拟机会根据引用对象 sf 的 queue 是否为空，如果为空，则直接将引用的状态变为 InActivie(非激活，离真正回收不远了)</p></li><li><p>ReferenceQueue queue = new ReferenceQueue();<br>  如果 SoftReference sf2 = new SoftRerence( new Object(),  queue );如果垃圾回收器检测到 new Object 的可达性发生变化后，会将该引用添加到 pending 引用链上，然后有专门的线程 ReferenceHandle 线程来将引用加入到引用链中（入队），也就是应用程序可以从 queue 中获取到所以垃圾回收器回收的对象的应用，也就是 queue是 垃圾回收器通知应用程序 被引用指向的对象已经被垃圾回收的消息。</p></li></ul><p>####　2.2 Reference 的状态</p><ul><li><p>Active<br>激活状态（可达），一般新建的引用就是该状态，该状态的属性特点  next = null; queue = ReferenceQueue.Null(默认值) 或者  构造方法指定的 queue  Reference( T referent, ReferenceQueue queue)。</p><p>当垃圾回收器检测到可达性发生变化（变为不可达时），如果 queue == ReferenceQueue.Null 的话，状态直接变为 InActive, 如果 queue 不为空，则加入到 Reference 的静态变量 pending 的队列中，并将状态设置为 Pending。</p></li><li><p>Pending</p><p>会有一个专门的线程 ReferenceHandler 来处理pengding链表中的引用[pending链表，应该是后进先出的特点]，将该引用入队（如果有注册队列，也可以看出是垃圾回收器以此来通知应用程序做些事情【请参考 WeakHashMap 的实现】）。在r.queue.enque(r) 方法中，有个关键点，保证一个引用，只能入队一次，入队后，该引用就与原来的引用队列失去关联；为了清晰展示次过程，将该代码附加上（来源于 java.lang.ref.Reference）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueue(Reference&lt;? extends T&gt; r) &#123; &#x2F;* Called only by Reference class *&#x2F;</span><br><span class="line">        synchronized (r) &#123;</span><br><span class="line">            if (r.queue &#x3D;&#x3D; ENQUEUED) return false; &#x2F;&#x2F;关注这里</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                r.queue &#x3D; ENQUEUED;                &#x2F;&#x2F; 关注这里</span><br><span class="line">                r.next &#x3D; (head &#x3D;&#x3D; null) ? r : head;</span><br><span class="line">                head &#x3D; r;</span><br><span class="line">                queueLength++;</span><br><span class="line">                if (r instanceof FinalReference) &#123;</span><br><span class="line">                    sun.misc.VM.addFinalRefCount(1);</span><br><span class="line">                &#125;</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p></li><li><p>Enqueue<br>进入队列中的Reference 中的 next 为队列中一个引用，或等于this(表示当前引用为最后一个), queue = ReferenceQueue.ENQUEUE。</p></li><li><p>InActive</p><p>queue = ReferenceQueue.NULL; next = this</p></li></ul><p>JAVA 四种引用的理解就到这了，其实 JAVA 中还有一种引用，java.lang.ref.FinalReference 应用，不过修饰符是 default, 包访问权限，主要用于 finalizer方法的执行，请关注下一篇博文。</p><p>再统一聊聊 java 引用中涉及到的引用的几个队列。</p><p>Reference中涉及到的队列(链表)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Reference next;</span><br><span class="line"></span><br><span class="line">private static Reference pending &#x3D; null;</span><br><span class="line"></span><br><span class="line">private ReferenceQueue queue;</span><br></pre></td></tr></table></figure><p>每个引用可以关联一个引用队列，该引用队列由应用程序创建的，，然后垃圾回收器在检测到引用不可达时，将该引用加入到该队列，应用程序可以根据该引用队列来做些处理。（也就是该引用队列 成为 垃圾回收器与应用程序的通信机制）。</p><p>ReferenceQueue 自身的结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private volatile Reference&lt;? extends T&gt; head &#x3D; null;</span><br></pre></td></tr></table></figure><p>首先，应用程序如下使用引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class TestReference &#123;</span><br><span class="line"></span><br><span class="line">           private static ReferenceQueue aQueue &#x3D; new ReferenceQueue();</span><br><span class="line"></span><br><span class="line">           public static void main(String args) &#123;</span><br><span class="line"></span><br><span class="line">                  Object a &#x3D; new Object();   &#x2F;&#x2F; 代码1</span><br><span class="line"></span><br><span class="line">                  WeakReference ref &#x3D; new WeakReference( a, aQueue );  </span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后在程序运行过程，内存不断消耗，直至触发垃圾回收操作。此时，垃圾收集器发现 代码1处的 a 所指向的对象，只有 ref引用它，从根路径不可达，故垃圾回收器，会将 ref 引用加入到  static Reference pending 链表中。</p><blockquote><p>注意，此代码是写在JVM实现中的】</p></blockquote><p>所处理的操作无非就是</p><p>1、如果pending 为空，则将当前引用(ref) 设置为pengding,,并且将 ref对象的next指针指向自己； 如果pending不为空，则将当前的引用(ref)的next指向pengding,然后pengding = 当前的引用ref,所以 pengding 其实就是 一个后进新出的链表单向链表结构。</p><p>2、由此总结出  ref 与 pengding链表关联的第一步  由JVM垃圾回收器完成。<br>从pengding 链表中取出引用，进行入队操作。该操作由专门的线程(ReferenceHandle 线程处理)，我重点将 ReferenceHandle线程的源代码贴出已供分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private static class ReferenceHandler extends Thread &#123;</span><br><span class="line">        ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class="line">            super(g, name);</span><br><span class="line">        &#125;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                Reference r;</span><br><span class="line">                synchronized (lock) &#123;</span><br><span class="line">                    if (pending !&#x3D; null) &#123;        </span><br><span class="line">                        &#x2F;&#x2F; 如果pengding不为空，则取出pengding 的第一个引用，</span><br><span class="line">                        &#x2F;&#x2F; 然后重新设置pengding 的值（为原来的pending.next,见如下代码   a,b,c）</span><br><span class="line">                        r &#x3D; pending;                &#x2F;&#x2F; a 将pending取出，准备入队操作</span><br><span class="line">                        Reference rn &#x3D; r.next;  &#x2F;&#x2F; b 先获取原先pending 的 next</span><br><span class="line">                        pending &#x3D; (rn &#x3D;&#x3D; r) ? null : rn;  </span><br><span class="line">                        &#x2F;&#x2F; c  如果pending的next等于本身，则设在pending为空，否则为链表的下一个。</span><br><span class="line">                        &#x2F;&#x2F; 从这里更加看出 pending 是后进先出队列。</span><br><span class="line">                        r.next &#x3D; r;</span><br><span class="line">                    &#125; else &#123; </span><br><span class="line">                        &#x2F;&#x2F; 如果 pending 为空，则线程阻塞，等待垃圾回收器添加新的引用到 pending链表中</span><br><span class="line">                        try &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; catch (InterruptedException x) &#123; &#125;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; Fast path for cleaners</span><br><span class="line">                if (r instanceof Cleaner) &#123;</span><br><span class="line">                    ((Cleaner)r).clean();</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                ReferenceQueue q &#x3D; r.queue;</span><br><span class="line">                if (q !&#x3D; ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1、Java引用的类型&quot;&gt;&lt;a href=&quot;#1、Java引用的类型&quot; class=&quot;headerlink&quot; title=&quot;1、Java引用的类型&quot;&gt;&lt;/a&gt;1、Java引用的类型&lt;/h2&gt;&lt;p&gt;强引用、软引用(java.lang.ref.SoftReference)、弱引用(java.lang.ref.WeakReference)、虚引用(　java.lang.ref.PhantomReference　)。&lt;/p&gt;
&lt;p&gt;java默认的引用类型为强引用，比如 Object a = new Object();其中 a 为强引用，new Object()为一个具体的对象。&lt;/p&gt;
&lt;p&gt;至于软应用，弱引用，虚引用，就是 JAVA 虚拟机管理对象的范畴了，可以这样理解，SoftReference、WeakReference、PlantomReference 只是一种标记，JAVA 虚拟机在垃圾回收时，对上述不同的标记【引用的对象】采取不同的措施。采取措施如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;软引用(SoftReference)：当内存足够时，该引用【引用的对象】不会被回收，那什么是内存足够呢？进行年轻代的垃圾回收不会触发SoftReference所指向对象的回收,如果触发Full GC，那SoftReference所指向的对象将被回收。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;弱引用(WeakReference) :当进行年轻代垃圾回收时，该引用指向的对象，就会被回收。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;虚引用(PhantomeReference) 该引用指向的对象，无法对垃圾收集器收集对象时产生任何影响，唯一有用的是，如果被垃圾收集器收集的对象，被PhantomeReference标记，垃圾收集器会通过注册在PhantomeReference上的队列来通知应用程序，该引用指向的对象，已经被垃圾收集器回收。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上文的描述，也清楚的知道，上述应用是直接JVM打交道，更直接的说是与垃圾回收器直接的交互。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="reference" scheme="http://example.com/tags/reference/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis一二级缓存实现原理与使用指南</title>
    <link href="http://example.com/posts/36b32da.html"/>
    <id>http://example.com/posts/36b32da.html</id>
    <published>2020-12-09T15:08:35.000Z</published>
    <updated>2020-12-11T04:38:09.531Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>Mybatis 与 Hibernate 一样，支持一二级缓存。一级缓存指的是 Session 级别的缓存，即在一个会话中多次执行同一条 SQL 语句并且参数相同，则后面的查询将不会发送到数据库，直接从 Session 缓存中获取。二级缓存，指的是 SessionFactory 级别的缓存，即不同的会话可以共享。</p><p>缓存，通常涉及到缓存的写、读、过期(更新缓存)等几个方面，请带着这些问题一起来探究Mybatis关于缓存的实现原理吧。</p><blockquote><p>提出问题：缓存的查询顺序，是先查一级缓存还是二级缓存？</p></blockquote><p>本文以SQL查询与更新两个流程来揭开Mybatis缓存实现的细节。</p><h2 id="1、从-SQL-查询流程看一二级缓存"><a href="#1、从-SQL-查询流程看一二级缓存" class="headerlink" title="1、从 SQL 查询流程看一二级缓存"></a>1、从 SQL 查询流程看一二级缓存</h2><blockquote><p>温馨提示，本文不会详细介绍详细的 SQL 执行流程，如果对其感兴趣，可以查阅笔者的另外一篇文章：<a href="https://blog.csdn.net/prestigeding/article/details/90647674">源码分析Mybatis SQL执行流程</a></p></blockquote><h3 id="1-1-创建Executor"><a href="#1-1-创建Executor" class="headerlink" title="1.1 创建Executor"></a>1.1 创建Executor</h3><p>Configuration#newExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;                                                           <span class="comment">// @1</span></span><br><span class="line">      executor = <span class="keyword">new</span> CachingExecutor(executor);                 <span class="comment">// @2</span></span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果 cacheEnabled 为 true，表示开启缓存机制，缓存的实现类为 CachingExecutor，这里使用了经典的装饰模式，处理了缓存的相关逻辑后，委托给的具体的 Executor 执行。</p><p>cacheEnable 在实际的使用中通过在 mybatis-config.xml 文件中指定，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该值默认为true。</p><h3 id="1-2-CachingExecutor-query"><a href="#1-2-CachingExecutor-query" class="headerlink" title="1.2 CachingExecutor#query"></a>1.2 CachingExecutor#query</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameterObject);  <span class="comment">// @1</span></span><br><span class="line">    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);   <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);       <span class="comment">// @3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：根据参数生成SQL语句。</p><p>代码@2：根据 MappedStatement、参数、分页参数、SQL 生成缓存 Key。</p><p>代码@3：调用6个参数的 query 方法。</p><p>缓存 Key 的创建比较简单，本文就只贴出代码，大家一目了然,大家重点关注组成缓存Key的要素。<br>BaseExecute#createCacheKey</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  CacheKey cacheKey = <span class="keyword">new</span> CacheKey();</span><br><span class="line">  cacheKey.update(ms.getId());</span><br><span class="line">  cacheKey.update(rowBounds.getOffset());</span><br><span class="line">  cacheKey.update(rowBounds.getLimit());</span><br><span class="line">  cacheKey.update(boundSql.getSql());</span><br><span class="line">  List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">  <span class="comment">// mimic DefaultParameterHandler logic</span></span><br><span class="line">  <span class="keyword">for</span> (ParameterMapping parameterMapping : parameterMappings) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">      Object value;</span><br><span class="line">      String propertyName = parameterMapping.getProperty();</span><br><span class="line">      <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">        value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">        value = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">        value = parameterObject;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">        value = metaObject.getValue(propertyName);</span><br><span class="line">      &#125;</span><br><span class="line">      cacheKey.update(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (configuration.getEnvironment() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// issue #176</span></span><br><span class="line">    cacheKey.update(configuration.getEnvironment().getId());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cacheKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来重点看CachingExecutor的另外一个query方法。</p><p>CachingExecutor#query</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Cache cache = ms.getCache();    <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      flushCacheIfRequired(ms);        <span class="comment">// @2</span></span><br><span class="line">      <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ensureNoOutParams(ms, boundSql);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);      <span class="comment">// @3</span></span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;                                                              <span class="comment">// @4</span></span><br><span class="line">          list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);    <span class="comment">//@5</span></span><br><span class="line">          tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116                                                               // @6</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);  <span class="comment">//@7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：获取 MappedStatement 中的 Cache cache 属性。<br>代码@2：如果不为空，则尝试从缓存中获取，否则直接委托给具体的执行器执行，例如 SimpleExecutor (@7)。<br>代码@3：尝试从缓存中根据缓存 Key 查找。<br>代码@4：如果从缓存中获取的值不为空，则直接返回缓存中的值，否则先从数据库查询@5，将查询结果更新到缓存中。</p><p>这里的缓存即 MappedStatement 中的 Cache 对象是一级缓存还是二级缓存？通常在 ORM 类框架中，Session 级别的缓存为一级缓存，即会话结束后就会失效，显然这里不会随着 Session 的失效而失效，因为 Cache 对象是存储在于 MappedStatement 对象中的，每一个 MappedStatement 对象代表一个 Dao(Mapper) 中的一个方法，即代表一条对应的 SQL 语句，是一个全局的概念。</p><p>相信大家也会觉得，想继续深入了解 CachingExecutor 中使用的 Cache 是一级缓存还是二级缓存，了解 Cache 对象的创建至关重要。关于 MappedStatement 的创建流程，建议查阅笔者的另外一篇博文：<a href="https://blog.csdn.net/prestigeding/article/details/90488395">源码分析Mybatis MappedStatement的创建流程</a>。</p><p>本文只会关注 MappedStatement 对象流程中关于于缓存相关的部分。</p><p>接下来将按照先二级缓存，再一级缓存的思路进行讲解。</p><h4 id="1-2-1-二级缓存"><a href="#1-2-1-二级缓存" class="headerlink" title="1.2.1 二级缓存"></a>1.2.1 二级缓存</h4><h5 id="1-2-1-1-MappedStatement-cache属性创建机制"><a href="#1-2-1-1-MappedStatement-cache属性创建机制" class="headerlink" title="1.2.1.1 MappedStatement#cache属性创建机制"></a>1.2.1.1 MappedStatement#cache属性创建机制</h5><p>从上面看，如果 cacheEnable 为 true 并且 MappedStatement 对象的 cache 属性不为空，则能使用二级缓存。</p><p>我们可以看到 MappedStatement 对象的 cache 属性赋值的地方为：MapperBuilderAssistant#addMappedStatement，从该方法的调用链可以得知是在解析 Mapper 定义的时候就会创建。<br><img src="https://img-blog.csdnimg.cn/20190826205429651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>使用的 cache 属性为 MapperBuilderAssistant 的 currentCache,我们跟踪一下该属性的赋值方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Cache <span class="title">useCacheRef</span><span class="params">(String namespace)</span></span></span><br></pre></td></tr></table></figure><p>其调用链如下：<br><img src="https://img-blog.csdnimg.cn/2019082620552683.png" alt="在这里插入图片描述"><br>可以看出是在解析 cacheRef 标签，即在解析 Mapper.xml 文件中的 cacheRef 标签时，即二级缓存的使用和 cacheRef 标签离不开关系，并且特别注意一点，其参数为 namespace，即每一个 namespace 对应一个 Cache 对象，在 Mybatis 的方法中，通常namespace 对一个 Mapper.java 对象，对应对数据库一张表的更新、新增操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Cache useNewCache</span><br></pre></td></tr></table></figure><p>其调用链如下图所示：<br><img src="https://img-blog.csdnimg.cn/20190826205659301.png" alt="在这里插入图片描述">在解析 Mapper.xml 文件中的 cache 标签时被调用。</p><h5 id="1-2-1-2-cache标签解析"><a href="#1-2-1-2-cache标签解析" class="headerlink" title="1.2.1.2 cache标签解析"></a>1.2.1.2 cache标签解析</h5><p>接下来我们根据 cache 标签简单看一下 cache 标签的解析，下面以 xml 配置方式为例展开，基于注解的解析，其原理类似，其代码 XMLMapperBuilder 的 cacheElement 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">      String type = context.getStringAttribute(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;PERPETUAL&quot;</span>);                                                      </span><br><span class="line">      Class&lt;? extends Cache&gt; typeClass = typeAliasRegistry.resolveAlias(type);</span><br><span class="line">      String eviction = context.getStringAttribute(<span class="string">&quot;eviction&quot;</span>, <span class="string">&quot;LRU&quot;</span>);</span><br><span class="line">      Class&lt;? extends Cache&gt; evictionClass = typeAliasRegistry.resolveAlias(eviction);</span><br><span class="line">      Long flushInterval = context.getLongAttribute(<span class="string">&quot;flushInterval&quot;</span>);</span><br><span class="line">      Integer size = context.getIntAttribute(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">      <span class="keyword">boolean</span> readWrite = !context.getBooleanAttribute(<span class="string">&quot;readOnly&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">boolean</span> blocking = context.getBooleanAttribute(<span class="string">&quot;blocking&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">      Properties props = context.getChildrenAsProperties();</span><br><span class="line">      builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从上面 cache 标签的核心属性如下：</p><ul><li>type<br>缓存实现类，可选择值：PERPETUAL、LRU 等，Mybatis 中所有的缓存实现类如下：<br><img src="https://img-blog.csdnimg.cn/2019082620593518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>eviction<br>移除算法，默认为 LRU。</li><li>flushInterval<br>缓存过期时间。</li><li>size<br>缓存在内存中的缓存个数。</li><li>readOnly<br>是否是只读。</li><li>blocking<br>是否阻塞，具体实现请看 BlockingCache。</li></ul><h5 id="1-2-1-3-cacheRef"><a href="#1-2-1-3-cacheRef" class="headerlink" title="1.2.1.3 cacheRef"></a>1.2.1.3 cacheRef</h5><p><img src="https://img-blog.csdnimg.cn/20190826210042752.png" alt="在这里插入图片描述"><br>cacheRef 只有一个属性，就是 namespace，就是引用其他 namespace 中的 cache。</p><p>Cache 的创建流程就讲解到这里，同一个 Namespace 只会定义一个 Cache。二级缓存的创建是在 *Mapper.xml 文件中使用了&lt; cache/&gt;、&lt; cacheRef/&gt;标签时创建，并且会按 NameSpace 为维度，为各个 MapperStatement 传入它所属的 Namespace 的二级缓存对象。</p><p>二级缓存的查询逻辑就介绍到这里了，我们再次回成 CacheingExecutor 的查询方法：<br>CachingExecutor#query</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Cache cache = ms.getCache();    <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      flushCacheIfRequired(ms);        <span class="comment">// @2</span></span><br><span class="line">      <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ensureNoOutParams(ms, boundSql);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);      <span class="comment">// @3</span></span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;                                                              <span class="comment">// @4</span></span><br><span class="line">          list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);    <span class="comment">//@5</span></span><br><span class="line">          tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116                                                               // @6</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);  <span class="comment">//@7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 MappedStatement 的 cache 属性为空，则直接调用内部的 Executor 的查询方法。也就时如果在 *.Mapper.xm l文件中未定义&lt; cache/&gt;或&lt; cacheRef/&gt;，则 cache 属性会为空。</p><h4 id="1-2-2-一级缓存"><a href="#1-2-2-一级缓存" class="headerlink" title="1.2.2 一级缓存"></a>1.2.2 一级缓存</h4><p>Mybatis 根据 SQL 的类型共有如下3种 Executor类型，分别是 SIMPLE,  REUSE, BATCH，本文将以 SimpleExecutor为 例来对一级缓存的介绍。</p><p>BaseExecutor#query</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;   <span class="comment">// @1</span></span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      queryStack++;                                                              </span><br><span class="line">      list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;     <span class="comment">// @2</span></span><br><span class="line">      <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);   <span class="comment">// @3</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      queryStack--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">        deferredLoad.load();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// issue #601</span></span><br><span class="line">      deferredLoads.clear();</span><br><span class="line">      <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">        <span class="comment">// issue #482</span></span><br><span class="line">        clearLocalCache();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码@1：queryStack：查询栈，每次查询之前，加一，查询返回结果后减一，如果为1，表示整个会会话中没有执行的查询语句，并根据 MappedStatement 是否需要执行清除缓存，如果是查询类的请求，无需清除缓存，如果是更新类操作的MappedStatemt，每次执行之前都需要清除缓存。<br>代码@2：如果缓存中存在，直接返回缓存中的数据。<br>代码@3：如果缓存未命中，则调用 queryFromDatabase 从数据中查询。</p><p>我们顺便看一下 queryFromDatabase 方法，再来看一下一级缓存的实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   List&lt;E&gt; list;</span><br><span class="line">   localCache.putObject(key, EXECUTION_PLACEHOLDER);   <span class="comment">//@!</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);   <span class="comment">// @2</span></span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     localCache.removeObject(key);                                                            <span class="comment">// @3</span></span><br><span class="line">   &#125;</span><br><span class="line">   localCache.putObject(key, list);                                                              <span class="comment">// @4</span></span><br><span class="line">   <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">     localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> list;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>代码@1：先往本地遍历存储一个厂里，表示正在执行中。<br>代码@2：从数据中查询数据。<br>代码@3：先移除正在执行中的标记。<br>代码@4：将数据库中的值存储到一级缓存中。</p><p>可以看出一级缓存的属性为 localCache，为 Executor 的属性。如果大家看过笔者发布的这个 Mybatis 系列就能轻易得出一个结论，每一个 SQL 会话对应一个 SqlSession 对象，每一个 SqlSession 会对应一个 Executor 对象，故 Executor 级别的缓存即为Session 级别的缓存，即为 Mybatis 的一级缓存。</p><p>上面已经介绍了一二级缓存的查找与添加，在查询的时候，首先查询缓存，如果缓存未命中，则查询数据库，然后将查询到的结果存入缓存中。</p><p>下面我们来简单看看缓存的更新。</p><h2 id="2、从SQL更新流程看一二级缓存"><a href="#2、从SQL更新流程看一二级缓存" class="headerlink" title="2、从SQL更新流程看一二级缓存"></a>2、从SQL更新流程看一二级缓存</h2><p>从更新的角度，更加的是关注缓存的更新，即当数据发生变化后，如果清除对应的缓存。</p><a id="more"></a><h3 id="2-1-二级缓存"><a href="#2-1-二级缓存" class="headerlink" title="2.1 二级缓存"></a>2.1 二级缓存</h3><p>CachingExecutor#update</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameterObject)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    flushCacheIfRequired(ms);    <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">return</span> delegate.update(ms, parameterObject);  <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果有必要则刷新缓存。<br>代码@2：调用内部的 Executor，例如 SimpleExecutor。</p><p>接下来重点看一下 flushCacheIfRequired 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;      </span><br><span class="line">      tcm.clear(cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TransactionalCacheManager#clear</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">    getTransactionalCache(cache).clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TransactionalCacheManager 事务缓存管理器，其实就是对 MappedStatement 的 cache 属性进行装饰，最终调用的还是MappedStatement 的 getCache 方法得到其缓存对象然后调用 clear 方法，清空所有的缓存，即缓存的更新策略是只要namespace 的任何一条插入或更新语句执行，整个 namespace 的缓存数据将全部清空。</p><h3 id="2-2-一级缓存的更新"><a href="#2-2-一级缓存的更新" class="headerlink" title="2.2 一级缓存的更新"></a>2.2 一级缓存的更新</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing an update&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  clearLocalCache();</span><br><span class="line">  <span class="keyword">return</span> doUpdate(ms, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其更新策略与二级缓存维护的一样。</p><p>一二级缓存的的新增、查询、更新就介绍到这里了，接下来对其进行一个总结。</p><h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><h3 id="3-1-一二级缓存作用序列图"><a href="#3-1-一二级缓存作用序列图" class="headerlink" title="3.1 一二级缓存作用序列图"></a>3.1 一二级缓存作用序列图</h3><p>Mybatis 一二级缓存时序图如下：<br><img src="https://img-blog.csdnimg.cn/20190826210834511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-2-如何使用二级缓存"><a href="#3-2-如何使用二级缓存" class="headerlink" title="3.2 如何使用二级缓存"></a>3.2 如何使用二级缓存</h3><p>1、在mybatis-config.xml中将cacheEnable设置为true。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不过该值默认为true。</p><p>2、在需要缓存的表操作，对应的 Dao 的配置文件中，例如 *Mapper.xml 文件中使用 cache、或 cacheRef 标签来定义缓存。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.winterchen.dao.UserDao&quot;</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.winterchen.model.UserDomain&quot;</span>&gt;</span></span><br><span class="line">    //省略</span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.winterchen.model.UserDomain&quot;</span>&gt;</span></span><br><span class="line">      //省略</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;lru&quot;</span> <span class="attr">readOnly</span>=<span class="string">&quot;true&quot;</span> <span class="attr">flushInterval</span>=<span class="string">&quot;3600000&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样就定义了一个 Cache，其 namespace 为 com.winterchen.dao.UserDao。其中 flushInterval 定义该 cache 定时清除的时间间隔，单位为 ms。</p><p>如果一个表的更新操作、新增操作位于不同的 Mapper.xml 文件中，如果对一个表的操作的 Cache 定义在不同的文件，则缓存数据则会出现不一致的情况，因为 Cache 的更新逻辑是，在一个 Namespace 中，如果有更新、插入语句的执行，则会清除该 namespace 对应的 cache 里面的所有缓存。那怎么来处理这种场景呢？cacheRef 闪亮登场。</p><p>如果一个 Mapper.xml 文件需要引入定义在别的 Mapper.xml 文件中定义的 cache,则使用 cacheRef，示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cacheRef</span> &quot;<span class="attr">namespace</span>&quot; = <span class="string">&quot;com.winterchen.dao.UserDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>一级缓存默认是开启的，也无法关闭。</p><p>缓存的介绍就介绍到这里。如果本文对您有所帮助，麻烦点一下赞，谢谢。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;Mybatis 与 Hibernate 一样，支持一二级缓存。一级缓存指的是 Session 级别的缓存，即在一个会话中多次执行同一条 SQL 语句并且参数相同，则后面的查询将不会发送到数据库，直接从 Session 缓存中获取。二级缓存，指的是 SessionFactory 级别的缓存，即不同的会话可以共享。&lt;/p&gt;
&lt;p&gt;缓存，通常涉及到缓存的写、读、过期(更新缓存)等几个方面，请带着这些问题一起来探究Mybatis关于缓存的实现原理吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;提出问题：缓存的查询顺序，是先查一级缓存还是二级缓存？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文以SQL查询与更新两个流程来揭开Mybatis缓存实现的细节。&lt;/p&gt;
&lt;h2 id=&quot;1、从-SQL-查询流程看一二级缓存&quot;&gt;&lt;a href=&quot;#1、从-SQL-查询流程看一二级缓存&quot; class=&quot;headerlink&quot; title=&quot;1、从 SQL 查询流程看一二级缓存&quot;&gt;&lt;/a&gt;1、从 SQL 查询流程看一二级缓存&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;温馨提示，本文不会详细介绍详细的 SQL 执行流程，如果对其感兴趣，可以查阅笔者的另外一篇文章：&lt;a href=&quot;https://blog.csdn.net/prestigeding/article/details/90647674&quot;&gt;源码分析Mybatis SQL执行流程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-1-创建Executor&quot;&gt;&lt;a href=&quot;#1-1-创建Executor&quot; class=&quot;headerlink&quot; title=&quot;1.1 创建Executor&quot;&gt;&lt;/a&gt;1.1 创建Executor&lt;/h3&gt;&lt;p&gt;Configuration#newExecutor&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Executor &lt;span class=&quot;title&quot;&gt;newExecutor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Transaction transaction, ExecutorType executorType)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	executorType = executorType == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? defaultExecutorType : executorType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    executorType = executorType == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? ExecutorType.SIMPLE : executorType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Executor executor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ExecutorType.BATCH == executorType) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BatchExecutor(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ExecutorType.REUSE == executorType) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ReuseExecutor(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SimpleExecutor(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cacheEnabled) &amp;#123;                                                           &lt;span class=&quot;comment&quot;&gt;// @1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CachingExecutor(executor);                 &lt;span class=&quot;comment&quot;&gt;// @2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    executor = (Executor) interceptorChain.pluginAll(executor);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; executor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码@1：如果 cacheEnabled 为 true，表示开启缓存机制，缓存的实现类为 CachingExecutor，这里使用了经典的装饰模式，处理了缓存的相关逻辑后，委托给的具体的 Executor 执行。&lt;/p&gt;
&lt;p&gt;cacheEnable 在实际的使用中通过在 mybatis-config.xml 文件中指定，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;settings&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;setting&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;cacheEnabled&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;settings&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该值默认为true。&lt;/p&gt;
&lt;h3 id=&quot;1-2-CachingExecutor-query&quot;&gt;&lt;a href=&quot;#1-2-CachingExecutor-query&quot; class=&quot;headerlink&quot; title=&quot;1.2 CachingExecutor#query&quot;&gt;&lt;/a&gt;1.2 CachingExecutor#query&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &amp;lt;E&amp;gt; &lt;span class=&quot;function&quot;&gt;List&amp;lt;E&amp;gt; &lt;span class=&quot;title&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; SQLException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BoundSql boundSql = ms.getBoundSql(parameterObject);  &lt;span class=&quot;comment&quot;&gt;// @1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);   &lt;span class=&quot;comment&quot;&gt;// @2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);       &lt;span class=&quot;comment&quot;&gt;// @3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码@1：根据参数生成SQL语句。&lt;/p&gt;
&lt;p&gt;代码@2：根据 MappedStatement、参数、分页参数、SQL 生成缓存 Key。&lt;/p&gt;
&lt;p&gt;代码@3：调用6个参数的 query 方法。&lt;/p&gt;
&lt;p&gt;缓存 Key 的创建比较简单，本文就只贴出代码，大家一目了然,大家重点关注组成缓存Key的要素。&lt;br&gt;BaseExecute#createCacheKey&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; CacheKey &lt;span class=&quot;title&quot;&gt;createCacheKey&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (closed) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ExecutorException(&lt;span class=&quot;string&quot;&gt;&amp;quot;Executor was closed.&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CacheKey cacheKey = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CacheKey();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cacheKey.update(ms.getId());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cacheKey.update(rowBounds.getOffset());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cacheKey.update(rowBounds.getLimit());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cacheKey.update(boundSql.getSql());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  List&amp;lt;ParameterMapping&amp;gt; parameterMappings = boundSql.getParameterMappings();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// mimic DefaultParameterHandler logic&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (ParameterMapping parameterMapping : parameterMappings) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (parameterMapping.getMode() != ParameterMode.OUT) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Object value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      String propertyName = parameterMapping.getProperty();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (boundSql.hasAdditionalParameter(propertyName)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        value = boundSql.getAdditionalParameter(propertyName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (parameterObject == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        value = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        value = parameterObject;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MetaObject metaObject = configuration.newMetaObject(parameterObject);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        value = metaObject.getValue(propertyName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      cacheKey.update(value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (configuration.getEnvironment() != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// issue #176&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cacheKey.update(configuration.getEnvironment().getId());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; cacheKey;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接下来重点看CachingExecutor的另外一个query方法。&lt;/p&gt;
&lt;p&gt;CachingExecutor#query&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &amp;lt;E&amp;gt; &lt;span class=&quot;function&quot;&gt;List&amp;lt;E&amp;gt; &lt;span class=&quot;title&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; SQLException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Cache cache = ms.getCache();    &lt;span class=&quot;comment&quot;&gt;// @1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cache != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      flushCacheIfRequired(ms);        &lt;span class=&quot;comment&quot;&gt;// @2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ms.isUseCache() &amp;amp;&amp;amp; resultHandler == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ensureNoOutParams(ms, boundSql);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;meta&quot;&gt;@SuppressWarnings(&amp;quot;unchecked&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;E&amp;gt; list = (List&amp;lt;E&amp;gt;) tcm.getObject(cache, key);      &lt;span class=&quot;comment&quot;&gt;// @3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (list == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;                                                              &lt;span class=&quot;comment&quot;&gt;// @4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          list = delegate.&amp;lt;E&amp;gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);    &lt;span class=&quot;comment&quot;&gt;//@5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          tcm.putObject(cache, key, list); &lt;span class=&quot;comment&quot;&gt;// issue #578 and #116                                                               // @6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; list;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; delegate.&amp;lt;E&amp;gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);  &lt;span class=&quot;comment&quot;&gt;//@7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码@1：获取 MappedStatement 中的 Cache cache 属性。&lt;br&gt;代码@2：如果不为空，则尝试从缓存中获取，否则直接委托给具体的执行器执行，例如 SimpleExecutor (@7)。&lt;br&gt;代码@3：尝试从缓存中根据缓存 Key 查找。&lt;br&gt;代码@4：如果从缓存中获取的值不为空，则直接返回缓存中的值，否则先从数据库查询@5，将查询结果更新到缓存中。&lt;/p&gt;
&lt;p&gt;这里的缓存即 MappedStatement 中的 Cache 对象是一级缓存还是二级缓存？通常在 ORM 类框架中，Session 级别的缓存为一级缓存，即会话结束后就会失效，显然这里不会随着 Session 的失效而失效，因为 Cache 对象是存储在于 MappedStatement 对象中的，每一个 MappedStatement 对象代表一个 Dao(Mapper) 中的一个方法，即代表一条对应的 SQL 语句，是一个全局的概念。&lt;/p&gt;
&lt;p&gt;相信大家也会觉得，想继续深入了解 CachingExecutor 中使用的 Cache 是一级缓存还是二级缓存，了解 Cache 对象的创建至关重要。关于 MappedStatement 的创建流程，建议查阅笔者的另外一篇博文：&lt;a href=&quot;https://blog.csdn.net/prestigeding/article/details/90488395&quot;&gt;源码分析Mybatis MappedStatement的创建流程&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本文只会关注 MappedStatement 对象流程中关于于缓存相关的部分。&lt;/p&gt;
&lt;p&gt;接下来将按照先二级缓存，再一级缓存的思路进行讲解。&lt;/p&gt;
&lt;h4 id=&quot;1-2-1-二级缓存&quot;&gt;&lt;a href=&quot;#1-2-1-二级缓存&quot; class=&quot;headerlink&quot; title=&quot;1.2.1 二级缓存&quot;&gt;&lt;/a&gt;1.2.1 二级缓存&lt;/h4&gt;&lt;h5 id=&quot;1-2-1-1-MappedStatement-cache属性创建机制&quot;&gt;&lt;a href=&quot;#1-2-1-1-MappedStatement-cache属性创建机制&quot; class=&quot;headerlink&quot; title=&quot;1.2.1.1 MappedStatement#cache属性创建机制&quot;&gt;&lt;/a&gt;1.2.1.1 MappedStatement#cache属性创建机制&lt;/h5&gt;&lt;p&gt;从上面看，如果 cacheEnable 为 true 并且 MappedStatement 对象的 cache 属性不为空，则能使用二级缓存。&lt;/p&gt;
&lt;p&gt;我们可以看到 MappedStatement 对象的 cache 属性赋值的地方为：MapperBuilderAssistant#addMappedStatement，从该方法的调用链可以得知是在解析 Mapper 定义的时候就会创建。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190826205429651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;使用的 cache 属性为 MapperBuilderAssistant 的 currentCache,我们跟踪一下该属性的赋值方法：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Cache &lt;span class=&quot;title&quot;&gt;useCacheRef&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String namespace)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其调用链如下：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019082620552683.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;可以看出是在解析 cacheRef 标签，即在解析 Mapper.xml 文件中的 cacheRef 标签时，即二级缓存的使用和 cacheRef 标签离不开关系，并且特别注意一点，其参数为 namespace，即每一个 namespace 对应一个 Cache 对象，在 Mybatis 的方法中，通常namespace 对一个 Mapper.java 对象，对应对数据库一张表的更新、新增操作。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Cache useNewCache&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其调用链如下图所示：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190826205659301.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;在解析 Mapper.xml 文件中的 cache 标签时被调用。&lt;/p&gt;
&lt;h5 id=&quot;1-2-1-2-cache标签解析&quot;&gt;&lt;a href=&quot;#1-2-1-2-cache标签解析&quot; class=&quot;headerlink&quot; title=&quot;1.2.1.2 cache标签解析&quot;&gt;&lt;/a&gt;1.2.1.2 cache标签解析&lt;/h5&gt;&lt;p&gt;接下来我们根据 cache 标签简单看一下 cache 标签的解析，下面以 xml 配置方式为例展开，基于注解的解析，其原理类似，其代码 XMLMapperBuilder 的 cacheElement 方法。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;cacheElement&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(XNode context)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (context != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      String type = context.getStringAttribute(&lt;span class=&quot;string&quot;&gt;&amp;quot;type&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;PERPETUAL&amp;quot;&lt;/span&gt;);                                                      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Class&amp;lt;? extends Cache&amp;gt; typeClass = typeAliasRegistry.resolveAlias(type);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      String eviction = context.getStringAttribute(&lt;span class=&quot;string&quot;&gt;&amp;quot;eviction&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;LRU&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Class&amp;lt;? extends Cache&amp;gt; evictionClass = typeAliasRegistry.resolveAlias(eviction);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Long flushInterval = context.getLongAttribute(&lt;span class=&quot;string&quot;&gt;&amp;quot;flushInterval&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Integer size = context.getIntAttribute(&lt;span class=&quot;string&quot;&gt;&amp;quot;size&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; readWrite = !context.getBooleanAttribute(&lt;span class=&quot;string&quot;&gt;&amp;quot;readOnly&amp;quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; blocking = context.getBooleanAttribute(&lt;span class=&quot;string&quot;&gt;&amp;quot;blocking&amp;quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Properties props = context.getChildrenAsProperties();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从上面 cache 标签的核心属性如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;type&lt;br&gt;缓存实现类，可选择值：PERPETUAL、LRU 等，Mybatis 中所有的缓存实现类如下：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019082620593518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/li&gt;
&lt;li&gt;eviction&lt;br&gt;移除算法，默认为 LRU。&lt;/li&gt;
&lt;li&gt;flushInterval&lt;br&gt;缓存过期时间。&lt;/li&gt;
&lt;li&gt;size&lt;br&gt;缓存在内存中的缓存个数。&lt;/li&gt;
&lt;li&gt;readOnly&lt;br&gt;是否是只读。&lt;/li&gt;
&lt;li&gt;blocking&lt;br&gt;是否阻塞，具体实现请看 BlockingCache。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;1-2-1-3-cacheRef&quot;&gt;&lt;a href=&quot;#1-2-1-3-cacheRef&quot; class=&quot;headerlink&quot; title=&quot;1.2.1.3 cacheRef&quot;&gt;&lt;/a&gt;1.2.1.3 cacheRef&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190826210042752.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;cacheRef 只有一个属性，就是 namespace，就是引用其他 namespace 中的 cache。&lt;/p&gt;
&lt;p&gt;Cache 的创建流程就讲解到这里，同一个 Namespace 只会定义一个 Cache。二级缓存的创建是在 *Mapper.xml 文件中使用了&amp;lt; cache/&amp;gt;、&amp;lt; cacheRef/&amp;gt;标签时创建，并且会按 NameSpace 为维度，为各个 MapperStatement 传入它所属的 Namespace 的二级缓存对象。&lt;/p&gt;
&lt;p&gt;二级缓存的查询逻辑就介绍到这里了，我们再次回成 CacheingExecutor 的查询方法：&lt;br&gt;CachingExecutor#query&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &amp;lt;E&amp;gt; &lt;span class=&quot;function&quot;&gt;List&amp;lt;E&amp;gt; &lt;span class=&quot;title&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; SQLException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Cache cache = ms.getCache();    &lt;span class=&quot;comment&quot;&gt;// @1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cache != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      flushCacheIfRequired(ms);        &lt;span class=&quot;comment&quot;&gt;// @2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ms.isUseCache() &amp;amp;&amp;amp; resultHandler == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ensureNoOutParams(ms, boundSql);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;meta&quot;&gt;@SuppressWarnings(&amp;quot;unchecked&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;E&amp;gt; list = (List&amp;lt;E&amp;gt;) tcm.getObject(cache, key);      &lt;span class=&quot;comment&quot;&gt;// @3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (list == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;                                                              &lt;span class=&quot;comment&quot;&gt;// @4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          list = delegate.&amp;lt;E&amp;gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);    &lt;span class=&quot;comment&quot;&gt;//@5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          tcm.putObject(cache, key, list); &lt;span class=&quot;comment&quot;&gt;// issue #578 and #116                                                               // @6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; list;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; delegate.&amp;lt;E&amp;gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);  &lt;span class=&quot;comment&quot;&gt;//@7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果 MappedStatement 的 cache 属性为空，则直接调用内部的 Executor 的查询方法。也就时如果在 *.Mapper.xm l文件中未定义&amp;lt; cache/&amp;gt;或&amp;lt; cacheRef/&amp;gt;，则 cache 属性会为空。&lt;/p&gt;
&lt;h4 id=&quot;1-2-2-一级缓存&quot;&gt;&lt;a href=&quot;#1-2-2-一级缓存&quot; class=&quot;headerlink&quot; title=&quot;1.2.2 一级缓存&quot;&gt;&lt;/a&gt;1.2.2 一级缓存&lt;/h4&gt;&lt;p&gt;Mybatis 根据 SQL 的类型共有如下3种 Executor类型，分别是 SIMPLE,  REUSE, BATCH，本文将以 SimpleExecutor为 例来对一级缓存的介绍。&lt;/p&gt;
&lt;p&gt;BaseExecutor#query&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &amp;lt;E&amp;gt; &lt;span class=&quot;function&quot;&gt;List&amp;lt;E&amp;gt; &lt;span class=&quot;title&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; SQLException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ErrorContext.instance().resource(ms.getResource()).activity(&lt;span class=&quot;string&quot;&gt;&amp;quot;executing a query&amp;quot;&lt;/span&gt;).object(ms.getId());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (closed) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ExecutorException(&lt;span class=&quot;string&quot;&gt;&amp;quot;Executor was closed.&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (queryStack == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; ms.isFlushCacheRequired()) &amp;#123;   &lt;span class=&quot;comment&quot;&gt;// @1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      clearLocalCache();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List&amp;lt;E&amp;gt; list;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      queryStack++;                                                              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      list = resultHandler == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? (List&amp;lt;E&amp;gt;) localCache.getObject(key) : &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;     &lt;span class=&quot;comment&quot;&gt;// @2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (list != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);   &lt;span class=&quot;comment&quot;&gt;// @3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      queryStack--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (queryStack == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (DeferredLoad deferredLoad : deferredLoads) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        deferredLoad.load();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// issue #601&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      deferredLoads.clear();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// issue #482&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        clearLocalCache();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; list;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码@1：queryStack：查询栈，每次查询之前，加一，查询返回结果后减一，如果为1，表示整个会会话中没有执行的查询语句，并根据 MappedStatement 是否需要执行清除缓存，如果是查询类的请求，无需清除缓存，如果是更新类操作的MappedStatemt，每次执行之前都需要清除缓存。&lt;br&gt;代码@2：如果缓存中存在，直接返回缓存中的数据。&lt;br&gt;代码@3：如果缓存未命中，则调用 queryFromDatabase 从数据中查询。&lt;/p&gt;
&lt;p&gt;我们顺便看一下 queryFromDatabase 方法，再来看一下一级缓存的实现类。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &amp;lt;E&amp;gt; &lt;span class=&quot;function&quot;&gt;List&amp;lt;E&amp;gt; &lt;span class=&quot;title&quot;&gt;queryFromDatabase&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; SQLException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   List&amp;lt;E&amp;gt; list;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   localCache.putObject(key, EXECUTION_PLACEHOLDER);   &lt;span class=&quot;comment&quot;&gt;//@!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);   &lt;span class=&quot;comment&quot;&gt;// @2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     localCache.removeObject(key);                                                            &lt;span class=&quot;comment&quot;&gt;// @3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   localCache.putObject(key, list);                                                              &lt;span class=&quot;comment&quot;&gt;// @4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ms.getStatementType() == StatementType.CALLABLE) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     localOutputParameterCache.putObject(key, parameter);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; list;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码@1：先往本地遍历存储一个厂里，表示正在执行中。&lt;br&gt;代码@2：从数据中查询数据。&lt;br&gt;代码@3：先移除正在执行中的标记。&lt;br&gt;代码@4：将数据库中的值存储到一级缓存中。&lt;/p&gt;
&lt;p&gt;可以看出一级缓存的属性为 localCache，为 Executor 的属性。如果大家看过笔者发布的这个 Mybatis 系列就能轻易得出一个结论，每一个 SQL 会话对应一个 SqlSession 对象，每一个 SqlSession 会对应一个 Executor 对象，故 Executor 级别的缓存即为Session 级别的缓存，即为 Mybatis 的一级缓存。&lt;/p&gt;
&lt;p&gt;上面已经介绍了一二级缓存的查找与添加，在查询的时候，首先查询缓存，如果缓存未命中，则查询数据库，然后将查询到的结果存入缓存中。&lt;/p&gt;
&lt;p&gt;下面我们来简单看看缓存的更新。&lt;/p&gt;
&lt;h2 id=&quot;2、从SQL更新流程看一二级缓存&quot;&gt;&lt;a href=&quot;#2、从SQL更新流程看一二级缓存&quot; class=&quot;headerlink&quot; title=&quot;2、从SQL更新流程看一二级缓存&quot;&gt;&lt;/a&gt;2、从SQL更新流程看一二级缓存&lt;/h2&gt;&lt;p&gt;从更新的角度，更加的是关注缓存的更新，即当数据发生变化后，如果清除对应的缓存。&lt;/p&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://example.com/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://example.com/tags/mybatis/"/>
    
    <category term="一级缓存" scheme="http://example.com/tags/%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    
    <category term="二级缓存" scheme="http://example.com/tags/%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>源码分析Mybatis插件(Plugin)机制与实战</title>
    <link href="http://example.com/posts/3e30e205.html"/>
    <id>http://example.com/posts/3e30e205.html</id>
    <published>2020-12-09T15:07:35.000Z</published>
    <updated>2020-12-11T14:45:15.234Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><p>温馨提示：本文也是以提问式阅读与探究源码的技巧展示。</p></blockquote><h2 id="1、回顾"><a href="#1、回顾" class="headerlink" title="1、回顾"></a>1、回顾</h2><p>从前面的文章我们已经知道，Mybatis在执行SQL语句的扩展点为Executor、StatementHandler、ParameterHandler与ResultSetHandler，我们本节将以Executor为入口，向大家展示Mybatis插件的扩展机制。</p><p>我们先来看回顾一下Mybatis Executor的创建入口。</p><h3 id="1-1-Configuration-newExecutor"><a href="#1-1-Configuration-newExecutor" class="headerlink" title="1.1 Configuration#newExecutor"></a>1.1 Configuration#newExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">  Executor executor;</span><br><span class="line">  <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">  &#125;</span><br><span class="line">  executor = (Executor) interceptorChain.pluginAll(executor);   <span class="comment">// @1</span></span><br><span class="line">  <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1,：使用InterceptorChain.pluginAll(executor)进行拆件化处理。</p><p>思考：使用该方法调用后，会返回一个什么对象呢？如何自定义拆件，自定义插件如何执行呢？</p><p>那接下来我们带着上述疑问，从InterceptorChain类开始进行深入学习。</p><h2 id="2、InterceptorChain"><a href="#2、InterceptorChain" class="headerlink" title="2、InterceptorChain"></a>2、InterceptorChain</h2><p>从名字上看其大意为拦截器链。</p><h3 id="2-1-类图"><a href="#2-1-类图" class="headerlink" title="2.1 类图"></a>2.1 类图</h3><p><img src="https://img-blog.csdnimg.cn/20190530205753805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>InterceptorChain<br>拦截器链，其内部维护一个interceptors,表示拦截器链中所有的拦截器，并提供增加或获取拦截器链的方法，下面会重点分析pluginAll方法。</li><li>Interceptor<br>拦截器接口，用户自定义的拦截器需要实现该接口。</li><li>Invocation<br>拦截器执行时的上下文环境，其实就是目标方法的调用信息，包含目标对象、调用的方法信息、参数信息。其中包含一个非常重要的方法：proceed。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>该方法的主要目的就是进行处理链的传播，执行完拦截器的方法后，最终需要调用目标方法的invoke方法。</li></ul><p>记下来中先重点分析一下InterceptorChain方法的pluginAll方法，因为从开头也知道,Mybatis在创建对象时，是调用该方法，完成目标对象的包装。</p><a id="more"></a><h3 id="2-2-核心方法一览"><a href="#2-2-核心方法一览" class="headerlink" title="2.2 核心方法一览"></a>2.2 核心方法一览</h3><h4 id="2-2-1-pluginAll"><a href="#2-2-1-pluginAll" class="headerlink" title="2.2.1 pluginAll"></a>2.2.1 pluginAll</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;   <span class="comment">// @1</span></span><br><span class="line">  <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;   <span class="comment">// @2</span></span><br><span class="line">    target = interceptor.plugin(target);         </span><br><span class="line">  <span class="comment">// @3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：目标对象，需要被代理的对象。</p><p>代码@2：遍历InterceptorChain的拦截器链，分别调用Intercpetor对象的Plugin进行拦截(@3)。</p><p>那接下来有三个疑问？<br>问题1：InterceptorChain中的interceptors是从什么时候初始化的呢，即拦截链中的拦截器从何而来。<br>问题2：从前面也得知，无论是创建Executor，还是创建StatementHandler等，都是调用InterceptorChain#pluginAll方法，那是不是拦截器中的拦截器都会作用与目标对象，这应该是有问题的，该如何处理？<br>问题3：代理对象是如何创建的。</p><h4 id="2-2-1-addInterceptor"><a href="#2-2-1-addInterceptor" class="headerlink" title="2.2.1 addInterceptor"></a>2.2.1 addInterceptor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">  interceptors.add(interceptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想知道interceptors是如何初始化的，我们只需要查看该方法的调用链即可。</p><p>一路跟踪到源头，我们会发现在初始化SqlSessionFactory时，会解析一个标签plugin，就可以得知，会在SqlSessionFacotry的一个属性中配置所有的拦截器。<br>具体配置示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;shardingDataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath*:META-INF/mybatis/mappers/OrderMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;plugins&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;teneantInteceptor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.demo.inteceptor.TenaInteceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>问题1已经解决。但后面两个问题似乎没有什么突破口。由于目前所涉及的三个类，显然不足以给我们提供答案，我们先将目光移到InterceptorChain所在包中的其他类，看看其他类的职责如何。</p><h2 id="3、Intercepts与Signature"><a href="#3、Intercepts与Signature" class="headerlink" title="3、Intercepts与Signature"></a>3、Intercepts与Signature</h2><p>在org.apache.ibatis.plugin中存在如下两个注解类：Intercepts与Signature，从字面意思就是用来配置拦截的方法信息。<br><img src="https://img-blog.csdnimg.cn/2019053021040719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>Siganature注解的属性说明如下：<ul><li>Class&lt;?&gt; type ：需要拦截目标对象的类。</li><li>String method：需要拦截目标类的方法名。</li><li>Class&lt;?&gt;[] args：需要拦截目标类的方法名的参数类型签名。</li></ul></li></ul><p>备注：至于如何得知上述字段的含义，请看下文的Plugin#getSignatureMap方法。</p><p>但另外一个类型Plugin类确引起了我的注意。接下来我们将重点分析Plugin方法。</p><h2 id="4、Plugin详解"><a href="#4、Plugin详解" class="headerlink" title="4、Plugin详解"></a>4、Plugin详解</h2><h3 id="4-1-Plugin类图"><a href="#4-1-Plugin类图" class="headerlink" title="4.1 Plugin类图"></a>4.1 Plugin类图</h3><p><img src="https://img-blog.csdnimg.cn/20190530210628459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其中InvocationHandler为JDK的动态代理机制中的事件执行器，我们可以隐约阈值代理对象的生成将基于JDK内置的动态代理机制。</p><p>Plugin的核心属性如下：</p><ul><li>Object target<br>目标对象。</li><li>Interceptor interceptor<br>拦截器对象。</li><li>Map&lt;Class&lt;?&gt;, Set&lt; Method&gt;&gt; signatureMap<br>拦截器中的签名映射。</li></ul><h2 id="4-2-构造函数"><a href="#4-2-构造函数" class="headerlink" title="4.2  构造函数"></a>4.2  构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Plugin</span><span class="params">(Object target, Interceptor interceptor, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    <span class="keyword">this</span>.interceptor = interceptor;</span><br><span class="line">    <span class="keyword">this</span>.signatureMap = signatureMap;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注意：其构造函数为私有的，那如何构建Plugin呢，其构造方法为Plugin的镜头方法wrap中被调用。</p><h3 id="4-3-核心方法详解"><a href="#4-3-核心方法详解" class="headerlink" title="4.3 核心方法详解"></a>4.3 核心方法详解</h3><h4 id="4-3-1-wrap"><a href="#4-3-1-wrap" class="headerlink" title="4.3.1 wrap"></a>4.3.1 wrap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">  Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);  <span class="comment">// @1</span></span><br><span class="line">  Class&lt;?&gt; type = target.getClass();   </span><br><span class="line">  Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);   <span class="comment">// @2</span></span><br><span class="line">  <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(    <span class="comment">// @3</span></span><br><span class="line">        type.getClassLoader(),</span><br><span class="line">        interfaces,</span><br><span class="line">        <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：获取待包装的Interceptor的方法签名映射表，稍后详细分析。</p><p>代码@2：获取需要代理的对象的Class上声明的所有接口。</p><p>代码@3：使用JDK内置的Proxy创建代理对象。Proxy创建代理对象的方法声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span>，</span></span><br></pre></td></tr></table></figure><p>注意其事件处理器为Plugin，故在动态运行过程中会执行Plugin的invoker方法。</p><p>在进入Plugin#invoker方法学习之前，我们先重点查看一下getSignatureMap、getAllInterfaces的实现。</p><h4 id="4-3-2-getSignatureMap"><a href="#4-3-2-getSignatureMap" class="headerlink" title="4.3.2 getSignatureMap"></a>4.3.2 getSignatureMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; getSignatureMap(Interceptor interceptor) &#123;</span><br><span class="line">  Intercepts interceptsAnnotation = interceptor.getClass().getAnnotation(Intercepts.class);  <span class="comment">// @1</span></span><br><span class="line">  <span class="keyword">if</span> (interceptsAnnotation == <span class="keyword">null</span>) &#123; <span class="comment">// issue #251                                          // @2</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> PluginException(<span class="string">&quot;No @Intercepts annotation was found in interceptor &quot;</span> + interceptor.getClass().getName());      </span><br><span class="line">  &#125;</span><br><span class="line">  Signature[] sigs = interceptsAnnotation.value();   <span class="comment">// @3</span></span><br><span class="line">  Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;(); </span><br><span class="line">  <span class="keyword">for</span> (Signature sig : sigs) &#123;</span><br><span class="line">    Set&lt;Method&gt; methods = signatureMap.get(sig.type());</span><br><span class="line">    <span class="keyword">if</span> (methods == <span class="keyword">null</span>) &#123;</span><br><span class="line">      methods = <span class="keyword">new</span> HashSet&lt;Method&gt;();</span><br><span class="line">      signatureMap.put(sig.type(), methods);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Method method = sig.type().getMethod(sig.method(), sig.args());    </span><br><span class="line">      methods.add(method);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> PluginException(<span class="string">&quot;Could not find method on &quot;</span> + sig.type() + <span class="string">&quot; named &quot;</span> + sig.method() + <span class="string">&quot;. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> signatureMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先从Interceptor的类上获取Intercepts注解。</p><p>代码@2：如果Interceptor的类上没有定义Intercepts注解，则抛出异常，说明我们在自定义插件时，必须要有Intercepts注解。</p><p>代码@3：解析Interceptor的values属性（Signature[]）数组，然后存入HashMap&lt;Class&lt;?&gt;, Set&lt; Method&gt;&gt;容器内。</p><blockquote><p>温馨提示：从这里可以得知：自定义的插件必须定义Intercepts注解，其注解的value值为Signature。</p></blockquote><h4 id="4-3-3-getAllInterfaces"><a href="#4-3-3-getAllInterfaces" class="headerlink" title="4.3.3 getAllInterfaces"></a>4.3.3 getAllInterfaces</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt;[] getAllInterfaces(Class&lt;?&gt; type, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) &#123;</span><br><span class="line">  Set&lt;Class&lt;?&gt;&gt; interfaces = <span class="keyword">new</span> HashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">  <span class="keyword">while</span> (type != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; c : type.getInterfaces()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (signatureMap.containsKey(c)) &#123;</span><br><span class="line">        interfaces.add(c);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    type = type.getSuperclass();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> interfaces.toArray(<span class="keyword">new</span> Class&lt;?&gt;[interfaces.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的实现比较简单，并不是获取目标对象所实现的所有接口，而是返回需要拦截的方法所包括的接口。</p><h4 id="4-3-4-invoke"><a href="#4-3-4-invoke" class="headerlink" title="4.3.4 invoke"></a>4.3.4 invoke</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123; <span class="comment">// @1</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">    <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.contains(method)) &#123;   <span class="comment">// @2</span></span><br><span class="line">      <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));   <span class="comment">// @3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> method.invoke(target, args);                           <span class="comment">// @4</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先对其参数列表做一个简单的说明：</p><ul><li>Object proxy 当前的代理对象</li><li>Method method 当前执行的方法</li><li>Object[] args 当前执行方法的参数</li></ul><p>代码@2：获取当前执行方法所属的类，并获取需要被拦截的方法集合。</p><p>代码@3：如果需被拦截的方法集合包含当前执行的方法，则执行拦截器的interceptor方法。</p><p>代码@4：如果不是，则直接调用目标方法的Invoke方法。</p><p>从该方法可以看出Interceptor接口的intercept方法就是拦截器自身需要实现的逻辑，其参数为Invocation，在该方法的结束，需要调用invocation#proceed()方法，进行拦截器链的传播。</p><p>从目前的学习中，我们已经了解了Plugin.wrap方法就是生成带来带来类的唯一入口，那该方法在什么地方调用呢？从代码类库中没有找到该方法的调用链，说明该方法是供用户调用的。</p><p>再看InterceptorChain方法的pluginAll方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;   <span class="comment">// @1</span></span><br><span class="line">  <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;   <span class="comment">// @2</span></span><br><span class="line">    target = interceptor.plugin(target);           <span class="comment">// @3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会遍历用户定义的插件实现类（Interceptor），并调用Interceptor的plugin方法，对target进行拆件化处理，即我们在实现自定义的Interceptor方法时，在plugin中需要根据自己的逻辑，对目标对象进行包装（代理），创建代理对象，那我们就可以在该方法中使用Plugin#wrap来创建代理类。</p><p>接下来我们再来用序列图来对上述源码分析做一个总结：<br><img src="https://img-blog.csdnimg.cn/2019053021182314.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>看到这里，大家是否对上面提出的3个问题都已经有了自己的答案了。</p><p>问题1：InterceptorChain中的interceptors是从什么时候初始化的呢，即拦截链中的拦截器从何而来。<br>答：在初始化SqlSesstionFactory的时候，会解析属性plugins属性，会加载所有的拦截器到InterceptorChain中。</p><p>问题2：从前面也得知，无论是创建Executor，还是创建StatementHandler等，都是调用InterceptorChain#pluginAll方法，那是不是拦截器中的拦截器都会作用与目标对象，这应该是有问题的，该如何处理？</p><p>答案是在各自订阅的Interceptor#plugin方法中，我们可以根据传入的目标对象，是否是该拦截器关注的，如果不关注，则直接返回目标对象，如果关注，则使用Plugin#wrap方法创建代理对象。</p><p>问题3：代理对象是如何创建的？<br>代理对象是使用JDK的动态代理机制创建，使用Plugin#wrap方法创建。</p><h2 id="5、实践"><a href="#5、实践" class="headerlink" title="5、实践"></a>5、实践</h2><p>实践是检验真理的唯一标准，那到底如何使用Mybatis的插件机制呢？<br>创建自定义的拦截器Interceptor,实现Interceptor接口。<br>1）实现plugin方法，在该方法中决定是否需要创建代理对象，如果创建，使用Plugin#wrap方法创建。<br>2）实现interceptor方法，该方法中定义拦截器的逻辑，并且在最后请调用invocation.proceed()方法传递拦截器链。<br>3）使用Intercepts注解，定义需要拦截目标对象的方法签名，支持多个。<br>将实现的Interceptor在定义SqlSessionFactory的配置中，放入plugins属性。</p><p>最后给出一个Mybatis Plugin插件机制使用案例：基于Mycat+Mybatis的多租户方案：<a href="https://blog.csdn.net/prestigeding/article/details/52662426">基于Mybatis与Mycat的多租户方式，通过Mybatis的插件机制，动态改写SQL语句来实现多租户</a></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;温馨提示：本文也是以提问式阅读与探究源码的技巧展示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1、回顾&quot;&gt;&lt;a href=&quot;#1、回顾&quot; class=&quot;headerlink&quot; title=&quot;1、回顾&quot;&gt;&lt;/a&gt;1、回顾&lt;/h2&gt;&lt;p&gt;从前面的文章我们已经知道，Mybatis在执行SQL语句的扩展点为Executor、StatementHandler、ParameterHandler与ResultSetHandler，我们本节将以Executor为入口，向大家展示Mybatis插件的扩展机制。&lt;/p&gt;
&lt;p&gt;我们先来看回顾一下Mybatis Executor的创建入口。&lt;/p&gt;
&lt;h3 id=&quot;1-1-Configuration-newExecutor&quot;&gt;&lt;a href=&quot;#1-1-Configuration-newExecutor&quot; class=&quot;headerlink&quot; title=&quot;1.1 Configuration#newExecutor&quot;&gt;&lt;/a&gt;1.1 Configuration#newExecutor&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Executor &lt;span class=&quot;title&quot;&gt;newExecutor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Transaction transaction, ExecutorType executorType)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  executorType = executorType == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? defaultExecutorType : executorType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  executorType = executorType == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? ExecutorType.SIMPLE : executorType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Executor executor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ExecutorType.BATCH == executorType) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BatchExecutor(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ExecutorType.REUSE == executorType) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ReuseExecutor(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SimpleExecutor(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cacheEnabled) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CachingExecutor(executor);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  executor = (Executor) interceptorChain.pluginAll(executor);   &lt;span class=&quot;comment&quot;&gt;// @1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; executor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码@1,：使用InterceptorChain.pluginAll(executor)进行拆件化处理。&lt;/p&gt;
&lt;p&gt;思考：使用该方法调用后，会返回一个什么对象呢？如何自定义拆件，自定义插件如何执行呢？&lt;/p&gt;
&lt;p&gt;那接下来我们带着上述疑问，从InterceptorChain类开始进行深入学习。&lt;/p&gt;
&lt;h2 id=&quot;2、InterceptorChain&quot;&gt;&lt;a href=&quot;#2、InterceptorChain&quot; class=&quot;headerlink&quot; title=&quot;2、InterceptorChain&quot;&gt;&lt;/a&gt;2、InterceptorChain&lt;/h2&gt;&lt;p&gt;从名字上看其大意为拦截器链。&lt;/p&gt;
&lt;h3 id=&quot;2-1-类图&quot;&gt;&lt;a href=&quot;#2-1-类图&quot; class=&quot;headerlink&quot; title=&quot;2.1 类图&quot;&gt;&lt;/a&gt;2.1 类图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190530205753805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;InterceptorChain&lt;br&gt;拦截器链，其内部维护一个interceptors,表示拦截器链中所有的拦截器，并提供增加或获取拦截器链的方法，下面会重点分析pluginAll方法。&lt;/li&gt;
&lt;li&gt;Interceptor&lt;br&gt;拦截器接口，用户自定义的拦截器需要实现该接口。&lt;/li&gt;
&lt;li&gt;Invocation&lt;br&gt;拦截器执行时的上下文环境，其实就是目标方法的调用信息，包含目标对象、调用的方法信息、参数信息。其中包含一个非常重要的方法：proceed。&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;title&quot;&gt;proceed&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InvocationTargetException, IllegalAccessException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; method.invoke(target, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
该方法的主要目的就是进行处理链的传播，执行完拦截器的方法后，最终需要调用目标方法的invoke方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记下来中先重点分析一下InterceptorChain方法的pluginAll方法，因为从开头也知道,Mybatis在创建对象时，是调用该方法，完成目标对象的包装。&lt;/p&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://example.com/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://example.com/tags/mybatis/"/>
    
    <category term="实战" scheme="http://example.com/tags/%E5%AE%9E%E6%88%98/"/>
    
    <category term="Plugin" scheme="http://example.com/tags/Plugin/"/>
    
  </entry>
  
  <entry>
    <title>源码解析MyBatis Sharding-Jdbc SQL语句执行流程详解</title>
    <link href="http://example.com/posts/6620f9ec.html"/>
    <id>http://example.com/posts/6620f9ec.html</id>
    <published>2020-12-09T15:04:35.000Z</published>
    <updated>2020-12-11T14:29:51.517Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文将详细介绍Mybatis SQL语句执行的全流程，本文与上篇具有一定的关联性，建议先阅读该系列中的前面3篇文章，重点掌握Mybatis Mapper类的初始化过程，因为在Mybatis中，Mapper是执行SQL语句的入口，类似下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> UserService implements IUserService &#123;</span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUser</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.find(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始进入本文的主题，以源码为手段，分析Mybatis执行SQL语句的流行，并且使用了数据库分库分表中间件sharding-jdbc,其版本为sharding-jdbc1.4.1。</p><p>为了方便大家对本文的源码分析，先给出Mybatis层面核心类的方法调用序列图。</p><h2 id="1、SQL执行序列图"><a href="#1、SQL执行序列图" class="headerlink" title="1、SQL执行序列图"></a>1、SQL执行序列图</h2><p><img src="https://img-blog.csdnimg.cn/20190528210928807.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><a id="more"></a><h2 id="2、源码解析SQL执行流程"><a href="#2、源码解析SQL执行流程" class="headerlink" title="2、源码解析SQL执行流程"></a>2、源码解析SQL执行流程</h2><p>接下来从从源码的角度对其进行剖析。</p><blockquote><p>温馨提示：在本文的末尾，还会给出一张详细的Mybatis Shardingjdbc语句执行流程图。（请勿错过哦）。</p></blockquote><h3 id="2-1-MapperProxy-invoker"><a href="#2-1-MapperProxy-invoker" class="headerlink" title="2.1 MapperProxy#invoker"></a>2.1 MapperProxy#invoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);                                     <span class="comment">// @2</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码@1：创建并缓存MapperMethod对象。</p><p>代码@2：调用MapperMethod对象的execute方法，即mapperInterface中定义的每一个方法最终会对应一个MapperMethod。</p><h3 id="2-2-MapperMethod-execute"><a href="#2-2-MapperMethod-execute" class="headerlink" title="2.2 MapperMethod#execute"></a>2.2 MapperMethod#execute</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">if</span> (SqlCommandType.INSERT == command.getType()) &#123; </span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SqlCommandType.UPDATE == command.getType()) &#123;</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SqlCommandType.DELETE == command.getType()) &#123;</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SqlCommandType.SELECT == command.getType()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">        executeWithResultHandler(sqlSession, args);</span><br><span class="line">        result = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">        result = executeForMany(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">        result = executeForMap(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Unknown execution method for: &quot;</span> + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Mapper method &#x27;&quot;</span> + command.getName() </span><br><span class="line">          + <span class="string">&quot; attempted to return null from a method with a primitive return type (&quot;</span> + method.getReturnType() + <span class="string">&quot;).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>该方法主要是根据SQL类型，insert、update、select等操作，执行对应的逻辑，本文我们以查询语句，进行跟踪，进入executeForMany(sqlSession, args)方法。</p><h3 id="2-3-MapperMethod-executeForMany"><a href="#2-3-MapperMethod-executeForMany" class="headerlink" title="2.3 MapperMethod#executeForMany"></a>2.3 MapperMethod#executeForMany</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">executeForMany</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;E&gt; result;</span><br><span class="line">    Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">    <span class="keyword">if</span> (method.hasRowBounds()) &#123;</span><br><span class="line">      RowBounds rowBounds = method.extractRowBounds(args);</span><br><span class="line">      result = sqlSession.&lt;E&gt;selectList(command.getName(), param, rowBounds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = sqlSession.&lt;E&gt;selectList(command.getName(), param);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// issue #510 Collections &amp; arrays support</span></span><br><span class="line">    <span class="keyword">if</span> (!method.getReturnType().isAssignableFrom(result.getClass())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (method.getReturnType().isArray()) &#123;</span><br><span class="line">        <span class="keyword">return</span> convertToArray(result);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> convertToDeclaredCollection(sqlSession.getConfiguration(), result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>该方法也比较简单，最终通过SqlSession调用selectList方法。</p><h3 id="2-4-DefaultSqlSession-selectList"><a href="#2-4-DefaultSqlSession-selectList" class="headerlink" title="2.4 DefaultSqlSession#selectList"></a>2.4 DefaultSqlSession#selectList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      MappedStatement ms = configuration.getMappedStatement(statement);   <span class="comment">// @1</span></span><br><span class="line">      List&lt;E&gt; result = executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);   <span class="comment">// @2</span></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error querying database.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码@1：根据资源名称获取对应的MappedStatement对象，此时的statement为资源名称，例如com.demo.UserMapper.findUser。至于MappedStatement对象的生成在上一节初始化时已详细介绍过，此处不再重复介绍。</p><p>代码@2：调用Executor的query方法。这里说明一下，其实一开始会进入到CachingExecutor#query方法，由于CachingExecutor的Executor delegate属性默认是SimpleExecutor，故最终还是会进入到SimpleExecutor#query中。</p><p>接下来我们进入到SimpleExecutor的父类BaseExecutor的query方法中。</p><h3 id="2-5-BaseExecutor-query"><a href="#2-5-BaseExecutor-query" class="headerlink" title="2.5 BaseExecutor#query"></a>2.5 BaseExecutor#query</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;   <span class="comment">// @1</span></span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      queryStack++;</span><br><span class="line">      list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;                                            <span class="comment">// @2</span></span><br><span class="line">      <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);                   <span class="comment">// @3</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      queryStack--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">        deferredLoad.load();</span><br><span class="line">      &#125;</span><br><span class="line">      deferredLoads.clear(); <span class="comment">// issue #601</span></span><br><span class="line">      <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;                         <span class="comment">// @4</span></span><br><span class="line">        clearLocalCache(); <span class="comment">// issue #482</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先介绍一下该方法的入参，这些类都是Mybatis的重要类：</p><ul><li>MappedStatement ms<br>映射语句，一个MappedStatemnet对象代表一个Mapper中的一个方法，是映射的最基本对象。</li><li>Object parameter<br>SQL语句的参数列表。</li><li>RowBounds rowBounds<br>行边界对象，其实就是分页参数limit与size。</li><li>ResultHandler resultHandler<br>结果处理Handler。</li><li>CacheKey key<br>Mybatis缓存Key</li><li>BoundSql boundSql<br>SQL与参数绑定信息，从该对象可以获取在映射文件中的SQL语句。</li></ul><p>代码@2：首先从缓存中获取，Mybatis支持一级缓存（SqlSession）与二级缓存（多个SqlSession共享）。</p><p>代码@3：从数据库查询结果，然后进入到doQuery方法，执行真正的查询动作。</p><p>代码@4：如果一级缓存是语句级别的，则语句执行完毕后，删除缓存。</p><h3 id="2-6-SimpleExecutor-doQuery"><a href="#2-6-SimpleExecutor-doQuery" class="headerlink" title="2.6 SimpleExecutor#doQuery"></a>2.6 SimpleExecutor#doQuery</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Configuration configuration = ms.getConfiguration();</span><br><span class="line">      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);   <span class="comment">// @1</span></span><br><span class="line">      stmt = prepareStatement(handler, ms.getStatementLog());                                                                                                                   <span class="comment">// @2</span></span><br><span class="line">      <span class="keyword">return</span> handler.&lt;E&gt;query(stmt, resultHandler);                                                                                                                                        <span class="comment">// @3</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码@1：创建StatementHandler，这里会加入Mybatis的插件扩展机制(将在下篇详细介绍)，如图所示：<br><img src="https://img-blog.csdnimg.cn/20190528211610596.png" alt="在这里插入图片描述"><br>代码@2：创建Statement对象，注意，这里就是JDBC协议的java.sql.Statement对象了。</p><p>代码@3：使用Statment对象执行SQL语句。</p><p>接下来详细介绍Statement对象的创建过程与执行过程，即分布详细跟踪代码@2与代码@3。</p><h2 id="3、Statement对象创建流程"><a href="#3、Statement对象创建流程" class="headerlink" title="3、Statement对象创建流程"></a>3、Statement对象创建流程</h2><h3 id="3-1-java-sql-Connection对象创建"><a href="#3-1-java-sql-Connection对象创建" class="headerlink" title="3.1 java.sql.Connection对象创建"></a>3.1 java.sql.Connection对象创建</h3><h4 id="3-1-1-SimpleExecutor-prepareStatement"><a href="#3-1-1-SimpleExecutor-prepareStatement" class="headerlink" title="3.1.1 SimpleExecutor#prepareStatement"></a>3.1.1 SimpleExecutor#prepareStatement</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    Connection connection = getConnection(statementLog);  <span class="comment">// @1</span></span><br><span class="line">    stmt = handler.prepare(connection);                                  <span class="comment">// @2</span></span><br><span class="line">    handler.parameterize(stmt);                                               <span class="comment">// @3</span></span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Statement对象，分成三步：<br>代码@1：创建java.sql.Connection对象。</p><p>代码@2：使用Connection对象创建Statment对象。</p><p>代码@3：对Statement进行额外处理，特别是PrepareStatement的参数设置(ParameterHandler)。</p><h4 id="3-1-2-SimpleExecutor-getConnection"><a href="#3-1-2-SimpleExecutor-getConnection" class="headerlink" title="3.1.2 SimpleExecutor#getConnection"></a>3.1.2 SimpleExecutor#getConnection</h4><p>getConnection方法，根据上面流程图所示，先是进入到org.mybatis.spring.transaction.SpringManagedTransaction，再通过spring-jdbc框架，利用DataSourceUtils获取连接，其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">doGetConnection</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> SQLException </span>&#123;  </span><br><span class="line">Assert.notNull(dataSource, <span class="string">&quot;No DataSource specified&quot;</span>);</span><br><span class="line">ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource); </span><br><span class="line"><span class="keyword">if</span> (conHolder != <span class="keyword">null</span> &amp;&amp; (conHolder.hasConnection() || conHolder.isSynchronizedWithTransaction())) &#123;</span><br><span class="line">conHolder.requested();</span><br><span class="line"><span class="keyword">if</span> (!conHolder.hasConnection()) &#123;</span><br><span class="line">conHolder.setConnection(dataSource.getConnection());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> conHolder.getConnection();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Else we either got no holder or an empty thread-bound holder here.</span></span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">&quot;Fetching JDBC Connection from DataSource&quot;</span>);</span><br><span class="line">Connection con = dataSource.getConnection();      <span class="comment">// @1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里省略与事务处理相关的代码</span></span><br><span class="line"><span class="keyword">return</span> con;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：通过DataSource获取connection，那此处的DataSource是“谁”呢？看一下我们工程的配置：<br><img src="https://img-blog.csdnimg.cn/20190528212019407.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190528212039288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>故最终dataSouce.getConnection获取的连接，是从SpringShardingDataSource中获取连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">com.dangdang.ddframe.rdb.sharding.jdbc.ShardingDataSource#getConnection</span><br><span class="line"><span class="function"><span class="keyword">public</span> ShardingConnection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        MetricsContext.init(shardingProperties);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ShardingConnection(shardingContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的结果如下：<br><img src="https://img-blog.csdnimg.cn/20190528212138293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>备注：这里只是返回了一个ShardingConnection对象，该对象包含了分库分表上下文，但此时并没有执行具体的分库操作（切换数据源）。</p><p>Connection的获取流程清楚后，我们继续来看一下Statemnet对象的创建。</p><h3 id="3-2-java-sql-Statement对象创建"><a href="#3-2-java-sql-Statement对象创建" class="headerlink" title="3.2 java.sql.Statement对象创建"></a>3.2 java.sql.Statement对象创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stmt = prepareStatement(handler, ms.getStatementLog());            </span><br></pre></td></tr></table></figure><p>上面语句的调用链：RoutingStatementHandler -》BaseStatementHandler</p><h4 id="3-2-1-BaseStatementHandler-prepare"><a href="#3-2-1-BaseStatementHandler-prepare" class="headerlink" title="3.2.1 BaseStatementHandler#prepare"></a>3.2.1 BaseStatementHandler#prepare</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Statement <span class="title">prepare</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().sql(boundSql.getSql());</span><br><span class="line">    Statement statement = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      statement = instantiateStatement(connection);    <span class="comment">// @1</span></span><br><span class="line">      setStatementTimeout(statement);                         <span class="comment">// @2</span></span><br><span class="line">      setFetchSize(statement);                                      <span class="comment">// @3</span></span><br><span class="line">      <span class="keyword">return</span> statement;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      closeStatement(statement);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeStatement(statement);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Error preparing statement.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码@1：根据Connection对象（本文中是ShardingConnection)来创建Statement对象，其默认实现类：PreparedStatementHandler#instantiateStatement方法。</p><p>代码@2：为Statement设置超时时间。</p><p>代码@3：设置fetchSize。</p><h4 id="3-2-2-PreparedStatementHandler-instantiateStatement"><a href="#3-2-2-PreparedStatementHandler-instantiateStatement" class="headerlink" title="3.2.2 PreparedStatementHandler#instantiateStatement"></a>3.2.2 PreparedStatementHandler#instantiateStatement</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Statement <span class="title">instantiateStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    String sql = boundSql.getSql();</span><br><span class="line">    <span class="keyword">if</span> (mappedStatement.getKeyGenerator() <span class="keyword">instanceof</span> Jdbc3KeyGenerator) &#123;</span><br><span class="line">      String[] keyColumnNames = mappedStatement.getKeyColumns();</span><br><span class="line">      <span class="keyword">if</span> (keyColumnNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> connection.prepareStatement(sql, keyColumnNames);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappedStatement.getResultSetType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其实Statement对象的创建，就比较简单了，既然Connection是ShardingConnection，那就看一下其对应的prepareStatement方法即可。</p><h4 id="3-2-2-ShardingConnection-prepareStatement"><a href="#3-2-2-ShardingConnection-prepareStatement" class="headerlink" title="3.2.2 ShardingConnection#prepareStatement"></a>3.2.2 ShardingConnection#prepareStatement</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(<span class="keyword">final</span> String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;   <span class="comment">// sql，为配置在mybatis xml文件中的sql语句</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ShardingPreparedStatement(<span class="keyword">this</span>, sql);</span><br><span class="line">&#125;</span><br><span class="line">ShardingPreparedStatement(<span class="keyword">final</span> ShardingConnection shardingConnection, </span><br><span class="line">            <span class="keyword">final</span> String sql, <span class="keyword">final</span> <span class="keyword">int</span> resultSetType, <span class="keyword">final</span> <span class="keyword">int</span> resultSetConcurrency, <span class="keyword">final</span> <span class="keyword">int</span> resultSetHoldability) &#123;</span><br><span class="line">        <span class="keyword">super</span>(shardingConnection, resultSetType, resultSetConcurrency, resultSetHoldability);</span><br><span class="line">        preparedSQLRouter = shardingConnection.getShardingContext().getSqlRouteEngine().prepareSQL(sql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构建ShardingPreparedStatement对象的时候，会根据SQL语句创建解析SQL路由的解析器对象，但此时并不会执行相关的路由计算，PreparedStatement对象创建完成后，就开始进入SQL执行流程中。</p><h2 id="4、SQL执行流程"><a href="#4、SQL执行流程" class="headerlink" title="4、SQL执行流程"></a>4、SQL执行流程</h2><p>接下来我们继续看SimpleExecutor#doQuery方法的第3步，执行SQL语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handler.&lt;E&gt;query(stmt, resultHandler)。</span><br></pre></td></tr></table></figure><p>首先会进入RoutingStatementHandler这个类中，进行Mybatis层面的路由（主要是根据Statement类型）<br><img src="https://img-blog.csdnimg.cn/20190528212729690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后进入到PreparedStatementHandler#query中。</p><h3 id="4-1-PreparedStatementHandler-query"><a href="#4-1-PreparedStatementHandler-query" class="headerlink" title="4.1 PreparedStatementHandler#query"></a>4.1 PreparedStatementHandler#query</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">    ps.execute();  <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">return</span> resultSetHandler.&lt;E&gt; handleResultSets(ps);  <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：调用PreparedStatement的execute方法，由于本例是使用了Sharding-jdbc分库分表，此时调用的具体实现为：ShardingPreparedStatement。</p><p>代码@2：处理结果。</p><p>我们接下来分别来跟进execute与结果处理方法。</p><h3 id="4-2-ShardingPreparedStatement-execute"><a href="#4-2-ShardingPreparedStatement-execute" class="headerlink" title="4.2 ShardingPreparedStatement#execute"></a>4.2 ShardingPreparedStatement#execute</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PreparedStatementExecutor(getShardingConnection().getShardingContext().getExecutorEngine(), routeSQL()).execute(); <span class="comment">// @1</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        clearRouteContext();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里奥妙无穷，其关键点如下：<br>1）创造PreparedStatementExecutor对象，其两个核心参数：</p><ul><li>ExecutorEngine executorEngine：shardingjdbc执行引擎。</li><li>Collection&lt; PreparedStatementExecutorWrapper&gt; preparedStatemenWrappers<br>一个集合，每一个集合是PreparedStatement的包装类，这个集合如何而来？</li></ul><p>2）preparedStatemenWrappers是通过routeSQL方法产生的。</p><p>3）最终调用PreparedStatementExecutor方法的execute来执行。</p><p>接下来分别看一下routeSQL与execute方法。</p><h3 id="4-3-ShardingPreparedStatement-routeSQL"><a href="#4-3-ShardingPreparedStatement-routeSQL" class="headerlink" title="4.3 ShardingPreparedStatement#routeSQL"></a>4.3 ShardingPreparedStatement#routeSQL</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;PreparedStatementExecutorWrapper&gt; <span class="title">routeSQL</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        List&lt;PreparedStatementExecutorWrapper&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        SQLRouteResult sqlRouteResult = preparedSQLRouter.route(getParameters());   <span class="comment">// @1</span></span><br><span class="line">        MergeContext mergeContext = sqlRouteResult.getMergeContext();                      </span><br><span class="line">        setMergeContext(mergeContext);</span><br><span class="line">        setGeneratedKeyContext(sqlRouteResult.getGeneratedKeyContext());</span><br><span class="line">        <span class="keyword">for</span> (SQLExecutionUnit each : sqlRouteResult.getExecutionUnits()) &#123;                      <span class="comment">// @2          </span></span><br><span class="line">            PreparedStatement preparedStatement = (PreparedStatement) getStatement(getShardingConnection().getConnection(each.getDataSource(), sqlRouteResult.getSqlStatementType()), each.getSql());     <span class="comment">// @3</span></span><br><span class="line">            replayMethodsInvocation(preparedStatement);</span><br><span class="line">            getParameters().replayMethodsInvocation(preparedStatement);</span><br><span class="line">            result.add(wrap(preparedStatement, each));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：根据SQL参数进行路由计算，本文暂不关注其具体实现细节，这些将在具体分析Sharding-jdbc时具体详解，在这里就直观看一下其结果：</p><p>代码@2、@3：对分库分表的结果进行遍历，然后使用底层Datasource来创建Connection，创建PreparedStatement 对象。</p><p>routeSQL就暂时讲到这，从这里我们得知，会在这里根据路由结果，使用底层的具体数据源创建对应的Connection与PreparedStatement 对象。</p><h3 id="4-4-PreparedStatementExecutor-execute"><a href="#4-4-PreparedStatementExecutor-execute" class="headerlink" title="4.4 PreparedStatementExecutor#execute"></a>4.4 PreparedStatementExecutor#execute</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Context context = MetricsContext.start(<span class="string">&quot;ShardingPreparedStatement-execute&quot;</span>);</span><br><span class="line">    eventPostman.postExecutionEvents();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isExceptionThrown = ExecutorExceptionHandler.isExceptionThrown();</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, Object&gt; dataMap = ExecutorDataMap.getDataMap();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == preparedStatementExecutorWrappers.size()) &#123;     <span class="comment">// @1</span></span><br><span class="line">            PreparedStatementExecutorWrapper preparedStatementExecutorWrapper = preparedStatementExecutorWrappers.iterator().next();</span><br><span class="line">            <span class="keyword">return</span> executeInternal(preparedStatementExecutorWrapper, isExceptionThrown, dataMap);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Boolean&gt; result = executorEngine.execute(preparedStatementExecutorWrappers, <span class="keyword">new</span> ExecuteUnit&lt;PreparedStatementExecutorWrapper, Boolean&gt;() &#123;    <span class="comment">// @2</span></span><br><span class="line">        </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">execute</span><span class="params">(<span class="keyword">final</span> PreparedStatementExecutorWrapper input)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (input.getPreparedStatement().getConnection()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> executeInternal(input, isExceptionThrown, dataMap);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span> == result || result.isEmpty()) ? <span class="keyword">false</span> : result.get(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        MetricsContext.stop(context);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果计算出来的路由信息为1个，则同步执行。</p><p>代码@2：如果计算出来的路由信息有多个，则使用线程池异步执行。</p><p>那还有一个问题，通过PreparedStatement#execute方法执行后，如何返回结果呢？特别是异步执行的。</p><p>在上文其实已经谈到：</p><h3 id="4-4-DefaultResultSetHandler-handleResultSets"><a href="#4-4-DefaultResultSetHandler-handleResultSets" class="headerlink" title="4.4 DefaultResultSetHandler#handleResultSets"></a>4.4 DefaultResultSetHandler#handleResultSets</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().activity(<span class="string">&quot;handling results&quot;</span>).object(mappedStatement.getId());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> List&lt;Object&gt; multipleResults = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resultSetCount = <span class="number">0</span>;</span><br><span class="line">    ResultSetWrapper rsw = getFirstResultSet(stmt);         <span class="comment">// @1</span></span><br><span class="line">    <span class="comment">//省略部分代码，完整代码可以查看DefaultResultSetHandler方法。</span></span><br><span class="line">    <span class="keyword">return</span> collapseSingleResultList(multipleResults);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ResultSetWrapper <span class="title">getFirstResultSet</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ResultSet rs = stmt.getResultSet();              <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">while</span> (rs == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// move forward to get the first resultset in case the driver</span></span><br><span class="line">      <span class="comment">// doesn&#x27;t return the resultset as the first result (HSQLDB 2.1)</span></span><br><span class="line">      <span class="keyword">if</span> (stmt.getMoreResults()) &#123;</span><br><span class="line">        rs = stmt.getResultSet();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stmt.getUpdateCount() == -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// no more results. Must be no resultset</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rs != <span class="keyword">null</span> ? <span class="keyword">new</span> ResultSetWrapper(rs, configuration) : <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们看一下其关键代码如下：<br>代码@1：调用Statement#getResultSet()方法，如果使用shardingJdbc，则会调用ShardingStatement#getResultSet()，并会处理分库分表结果集的合并，在这里就不详细进行介绍，该部分会在shardingjdbc专栏详细分析。</p><p>代码@2：jdbc statement中获取结果集的通用写法，这里也不过多的介绍。</p><p>mybatis shardingjdbc SQL执行流程就介绍到这里了，为了方便大家对上述流程的理解，最后给出SQL执行的流程图：<br><img src="https://img-blog.csdnimg.cn/2019052821331476.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>Mybatis Sharding-Jdbc的SQL执行流程就介绍到这里了，从图中也能清晰看到Mybatis的拆件机制，将在下文详细介绍。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将详细介绍Mybatis SQL语句执行的全流程，本文与上篇具有一定的关联性，建议先阅读该系列中的前面3篇文章，重点掌握Mybatis Mapper类的初始化过程，因为在Mybatis中，Mapper是执行SQL语句的入口，类似下面这段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Service&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; UserService implements IUserService &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 	&lt;span class=&quot;meta&quot;&gt;@Autowired&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; UserMapper userMapper;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; User &lt;span class=&quot;title&quot;&gt;findUser&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Integer id)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; userMapper.find(id);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;开始进入本文的主题，以源码为手段，分析Mybatis执行SQL语句的流行，并且使用了数据库分库分表中间件sharding-jdbc,其版本为sharding-jdbc1.4.1。&lt;/p&gt;
&lt;p&gt;为了方便大家对本文的源码分析，先给出Mybatis层面核心类的方法调用序列图。&lt;/p&gt;
&lt;h2 id=&quot;1、SQL执行序列图&quot;&gt;&lt;a href=&quot;#1、SQL执行序列图&quot; class=&quot;headerlink&quot; title=&quot;1、SQL执行序列图&quot;&gt;&lt;/a&gt;1、SQL执行序列图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190528210928807.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://example.com/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://example.com/tags/mybatis/"/>
    
    <category term="Sharding" scheme="http://example.com/tags/Sharding/"/>
    
    <category term="SQL执行流程" scheme="http://example.com/tags/SQL%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis执行SQL的4大基础组件详解</title>
    <link href="http://example.com/posts/7c04b5f0.html"/>
    <id>http://example.com/posts/7c04b5f0.html</id>
    <published>2020-12-09T14:53:35.000Z</published>
    <updated>2020-12-11T14:12:16.561Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="1、Executor"><a href="#1、Executor" class="headerlink" title="1、Executor"></a>1、Executor</h2><p>sql执行器，其对应的类全路径：org.apache.ibatis.executor.Executor。</p><h3 id="1-1-Executor类图"><a href="#1-1-Executor类图" class="headerlink" title="1.1 Executor类图"></a>1.1 Executor类图</h3><p><img src="https://img-blog.csdnimg.cn/20190526170433414.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>Executor<br>执行器根据接口，定义update(更新或插入)、query(查询)、commit(提交事务)、rollback(回滚事务)。接下来简单介绍几个重要方法：</p><ul><li>int update(MappedStatement ms, Object parameter) throws SQLException<br>更新或插入方法，其参数含义如下：、<br>1）MappedStatement ms：SQL映射语句（Mapper.xml文件每一个方法对应一个MappedStatement对象）<br>2）Object parameter：参数，通常是List集合。</li><li>&lt; E&gt; List&lt; E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)<br>查询方法，其参数含义如下：<br>1）RowBounds：行边界，主要值分页参数limit、offset。<br>2）ResultHandler resultHandler：结果处理器。</li><li>CacheKey createCacheKey(MappedStatement ms, Object parameterObj, RowBounds bounds, BoundSql bSql)<br>创建缓存Key，Mybatis一二级缓存的缓存Key，可以看出Key由上述4个参数来决定。<br>1）BoundSql boundSql：可以通过该对象获取SQL语句。</li></ul></li><li><p>CachingExecutor<br>支持结果缓存的SQL执行器，注意其设计模式的应用，该类中，会持有Executor的一个委托对象，CachingExecutor关注与缓存特定的逻辑，其最终的SQL执行由其委托对象来实现，即其内部的委托对象为BaseExecutor的实现类。</p></li><li><p>BaseExecutor<br>Executor的基础实现类，该类为抽象类，关于查询、更新具体的实现由其子类来实现，下面4个都是其子类。</p></li><li><p>SimpleExecutor<br>简单的Executor执行器。</p></li><li><p>BatchExecutor<br>支持批量执行的Executor执行器。</p></li><li><p>ClosedExecutor<br>表示一个已关闭的Executor。</p></li><li><p>ReuseExecutor<br>支持重复使用Statement,以SQL为键，缓存Statement对象。</p></li></ul><h3 id="1-2-创建Executor"><a href="#1-2-创建Executor" class="headerlink" title="1.2 创建Executor"></a>1.2 创建Executor</h3><p>在Mybatis中，Executor的创建由Configuration对象来创建，具体的代码如下：</p><h4 id="Configuration-newExecitor"><a href="#Configuration-newExecitor" class="headerlink" title="Configuration#newExecitor"></a>Configuration#newExecitor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> newExecutor(transaction, defaultExecutorType);   <span class="comment">// @1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">  Executor executor;</span><br><span class="line">  <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;   <span class="comment">// @2</span></span><br><span class="line">    executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cacheEnabled) &#123; <span class="comment">// @3</span></span><br><span class="line">    executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">  &#125;</span><br><span class="line">  executor = (Executor) interceptorChain.pluginAll(executor);  <span class="comment">// @4</span></span><br><span class="line">  <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，Executor的创建由如下三个关键点：<br>代码@1：默认的ExecutorType为ExecutorType.SIMPLE，即默认创建的Executory为SimpleExecutor。<br>代码@2：根据executorType的值创建对应的Executory。<br>代码@3：如果cacheEnabled为true，则创建CachingExecutory，然后在其内部持有上面创建的Executor,cacheEnabled默认为true，则默认创建的Executor为CachingExecutor，并且其内部包裹着SimpleExecutor。<br>代码@4：使用InterceptorChain.pluginAll为executor创建代理对象，即Mybatis的拆件机制，将在该系列文章中详细介绍。</p><a id="more"></a><h2 id="2、StatementHandler"><a href="#2、StatementHandler" class="headerlink" title="2、StatementHandler"></a>2、StatementHandler</h2><p>在学习StatementHandler之前，我们先来回顾一下JDBC相关的知识。JDBC与语句执行的两大主流对象：java.sql.Statement、java.sql.PrepareStatement对象大家应该不会陌生，该对象的execute方法就是执行SQL语句的入口，通过java.sql.Connection对象创建Statement对象。Mybatis的StatementHandler，是Mybatis创建Statement对象的处理器，即StatementHandler会接管Statement对象的创建。</p><h3 id="2-1-StatementHandler类图"><a href="#2-1-StatementHandler类图" class="headerlink" title="2.1 StatementHandler类图"></a>2.1 StatementHandler类图</h3><p><img src="https://img-blog.csdnimg.cn/20190526171050653.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>StatementHandler<br>根接口，我们重点关注一下其定义的方法：</p><ul><li>Statement prepare(Connection connection)<br>创建Statement对象，即该方法会通过Connection对象创建Statement对象。</li><li>void parameterize(Statement statement)<br>对Statement对象参数化，特别是PreapreStatement对象。</li><li>void batch(Statement statement)<br>批量执行SQL。</li><li>int update(Statement statement)<br>更新操作。</li><li>&lt; E&gt; List&lt; E&gt; query(Statement statement, ResultHandler resultHandler)<br>查询操作。</li><li>BoundSql getBoundSql()<br>获取SQL语句。</li><li>ParameterHandler getParameterHandler()<br>获取对应的参数处理器。</li></ul></li><li><p>BaseStatementHandler<br>StatementHandler的抽象实现类，SimpleStatementHandler、PrepareStatementHandler、CallableStatementHandler是其子类。<br>我们来一一看一下其示例变量：</p><ul><li>Configuration configuration<br>Mybatis全局配置对象。</li><li>ObjectFactory objectFactory<br>对象工厂。</li><li>TypeHandlerRegistry typeHandlerRegistry<br>类型注册器。</li><li>ResultSetHandler resultSetHandler<br>结果集Handler。</li><li>ParameterHandler parameterHandler<br>参数处理器Handler。</li><li>Executor executor<br>SQL执行器。</li><li>MappedStatement mappedStatement<br>SQL映射语句（Mapper.xml文件每一个方法对应一个MappedStatement对象）</li><li>RowBounds rowBounds<br>行边界，主要值分页参数limit、offset。</li><li>BoundSql boundSql<br>可以通过该对象获取SQL语句。</li></ul></li><li><p>SimpleStatementHandler<br>具体的StatementHandler实现器，java.sql.Statement对象创建处理器。</p></li><li><p>PrepareStatementHandler<br>java.sql.PrepareStatement对象的创建处理器。</p></li><li><p>CallableStatementHandler<br>java.sql.CallableStatement对象的创建处理器，可用来执行存储过程调用的Statement。</p></li><li><p>RoutingStatementHandler<br>StatementHandler路由器，我们看一下其构造方法后，就会对该类了然于胸。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (ms.getStatementType()) &#123; <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">case</span> STATEMENT:</span><br><span class="line">      delegate = <span class="keyword">new</span> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PREPARED:</span><br><span class="line">      delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CALLABLE:</span><br><span class="line">      delegate = <span class="keyword">new</span> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Unknown statement type: &quot;</span> + ms.getStatementType());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来是会根据MappedStatement对象的statementType创建对应的StatementHandler。</p></li></ul><h3 id="2-2-创建StatementHandler"><a href="#2-2-创建StatementHandler" class="headerlink" title="2.2 创建StatementHandler"></a>2.2 创建StatementHandler</h3><h4 id="Configuration-newStatementHandler"><a href="#Configuration-newStatementHandler" class="headerlink" title="Configuration#newStatementHandler"></a>Configuration#newStatementHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql); <span class="comment">// @1</span></span><br><span class="line">  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler); <span class="comment">// @2</span></span><br><span class="line">  <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的两个关键点如下：<br>代码@1：创建RoutingStatementHandler对象，在其内部再根据SQL语句的类型，创建对应的StatementHandler对象。<br>代码@2：对StatementHandler引入拆件机制，该部分将在该专题的后续文章中会详细介绍，这里暂时跳过。</p><h2 id="3、ParameterHandler"><a href="#3、ParameterHandler" class="headerlink" title="3、ParameterHandler"></a>3、ParameterHandler</h2><p>参数处理器。同样我们先来看一下其类图。</p><h3 id="3-1-ParameterHandler类图"><a href="#3-1-ParameterHandler类图" class="headerlink" title="3.1 ParameterHandler类图"></a>3.1 ParameterHandler类图</h3><p><img src="https://img-blog.csdnimg.cn/20190526171502281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这个比较简单，就是处理PreparedStatemet接口的参数化处理，也可以顺便看一下其调用链(该部分会在下一篇中详细介绍)。<br><img src="https://img-blog.csdnimg.cn/20190526171635381.png" alt="在这里插入图片描述"></p><h3 id="3-2-创建ParameterHandler"><a href="#3-2-创建ParameterHandler" class="headerlink" title="3.2 创建ParameterHandler"></a>3.2 创建ParameterHandler</h3><h4 id="Configuration-newParameterHandler"><a href="#Configuration-newParameterHandler" class="headerlink" title="Configuration#newParameterHandler"></a>Configuration#newParameterHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">  parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);  <span class="comment">// @1</span></span><br><span class="line">  <span class="keyword">return</span> parameterHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样该接口也支持插件化机制。</p><h2 id="4、ResultSetHandler"><a href="#4、ResultSetHandler" class="headerlink" title="4、ResultSetHandler"></a>4、ResultSetHandler</h2><p>处理结果的Handler。我们同样看一下其类图。</p><h3 id="4-1-ResultSetHandler类图"><a href="#4-1-ResultSetHandler类图" class="headerlink" title="4.1 ResultSetHandler类图"></a>4.1 ResultSetHandler类图</h3><p><img src="https://img-blog.csdnimg.cn/20190526171756530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>处理Jdbc ResultSet的处理器。</p><h3 id="4-2-ResultSetHandler创建"><a href="#4-2-ResultSetHandler创建" class="headerlink" title="4.2 ResultSetHandler创建"></a>4.2 ResultSetHandler创建</h3><h4 id="Configuration-newResultSetHandler"><a href="#Configuration-newResultSetHandler" class="headerlink" title="Configuration#newResultSetHandler"></a>Configuration#newResultSetHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultSetHandler <span class="title">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">    ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  ResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">  resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">  <span class="keyword">return</span> resultSetHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样支持插件化机制，我们也稍微再看一下其调用链：<br><img src="https://img-blog.csdnimg.cn/20190526171844420.png" alt="在这里插入图片描述"><br>可以看出其调用的入口为SQL执行时。</p><p>本文作为下一篇《源码分析Mybatis整合ShardingJdbc SQL执行流程》的前置篇，重点介绍Executor、StatementHandler、ParameterHandler、ResultSetHandler的具体职责，以类图为基础并详细介绍其核心方法的作用，然后详细介绍了这些对象是如何创建，并引出Mybatis拆件机制。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1、Executor&quot;&gt;&lt;a href=&quot;#1、Executor&quot; class=&quot;headerlink&quot; title=&quot;1、Executor&quot;&gt;&lt;/a&gt;1、Executor&lt;/h2&gt;&lt;p&gt;sql执行器，其对应的类全路径：org.apache.ibatis.executor.Executor。&lt;/p&gt;
&lt;h3 id=&quot;1-1-Executor类图&quot;&gt;&lt;a href=&quot;#1-1-Executor类图&quot; class=&quot;headerlink&quot; title=&quot;1.1 Executor类图&quot;&gt;&lt;/a&gt;1.1 Executor类图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190526170433414.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Executor&lt;br&gt;执行器根据接口，定义update(更新或插入)、query(查询)、commit(提交事务)、rollback(回滚事务)。接下来简单介绍几个重要方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;int update(MappedStatement ms, Object parameter) throws SQLException&lt;br&gt;更新或插入方法，其参数含义如下：、&lt;br&gt;1）MappedStatement ms：SQL映射语句（Mapper.xml文件每一个方法对应一个MappedStatement对象）&lt;br&gt;2）Object parameter：参数，通常是List集合。&lt;/li&gt;
&lt;li&gt;&amp;lt; E&amp;gt; List&amp;lt; E&amp;gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)&lt;br&gt;查询方法，其参数含义如下：&lt;br&gt;1）RowBounds：行边界，主要值分页参数limit、offset。&lt;br&gt;2）ResultHandler resultHandler：结果处理器。&lt;/li&gt;
&lt;li&gt;CacheKey createCacheKey(MappedStatement ms, Object parameterObj, RowBounds bounds, BoundSql bSql)&lt;br&gt;创建缓存Key，Mybatis一二级缓存的缓存Key，可以看出Key由上述4个参数来决定。&lt;br&gt;1）BoundSql boundSql：可以通过该对象获取SQL语句。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CachingExecutor&lt;br&gt;支持结果缓存的SQL执行器，注意其设计模式的应用，该类中，会持有Executor的一个委托对象，CachingExecutor关注与缓存特定的逻辑，其最终的SQL执行由其委托对象来实现，即其内部的委托对象为BaseExecutor的实现类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;BaseExecutor&lt;br&gt;Executor的基础实现类，该类为抽象类，关于查询、更新具体的实现由其子类来实现，下面4个都是其子类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SimpleExecutor&lt;br&gt;简单的Executor执行器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;BatchExecutor&lt;br&gt;支持批量执行的Executor执行器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ClosedExecutor&lt;br&gt;表示一个已关闭的Executor。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ReuseExecutor&lt;br&gt;支持重复使用Statement,以SQL为键，缓存Statement对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-2-创建Executor&quot;&gt;&lt;a href=&quot;#1-2-创建Executor&quot; class=&quot;headerlink&quot; title=&quot;1.2 创建Executor&quot;&gt;&lt;/a&gt;1.2 创建Executor&lt;/h3&gt;&lt;p&gt;在Mybatis中，Executor的创建由Configuration对象来创建，具体的代码如下：&lt;/p&gt;
&lt;h4 id=&quot;Configuration-newExecitor&quot;&gt;&lt;a href=&quot;#Configuration-newExecitor&quot; class=&quot;headerlink&quot; title=&quot;Configuration#newExecitor&quot;&gt;&lt;/a&gt;Configuration#newExecitor&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Executor &lt;span class=&quot;title&quot;&gt;newExecutor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Transaction transaction)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; newExecutor(transaction, defaultExecutorType);   &lt;span class=&quot;comment&quot;&gt;// @1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Executor &lt;span class=&quot;title&quot;&gt;newExecutor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Transaction transaction, ExecutorType executorType)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  executorType = executorType == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? defaultExecutorType : executorType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  executorType = executorType == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? ExecutorType.SIMPLE : executorType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Executor executor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ExecutorType.BATCH == executorType) &amp;#123;   &lt;span class=&quot;comment&quot;&gt;// @2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BatchExecutor(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ExecutorType.REUSE == executorType) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ReuseExecutor(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SimpleExecutor(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cacheEnabled) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// @3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CachingExecutor(executor);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  executor = (Executor) interceptorChain.pluginAll(executor);  &lt;span class=&quot;comment&quot;&gt;// @4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; executor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从上面的代码可以看出，Executor的创建由如下三个关键点：&lt;br&gt;代码@1：默认的ExecutorType为ExecutorType.SIMPLE，即默认创建的Executory为SimpleExecutor。&lt;br&gt;代码@2：根据executorType的值创建对应的Executory。&lt;br&gt;代码@3：如果cacheEnabled为true，则创建CachingExecutory，然后在其内部持有上面创建的Executor,cacheEnabled默认为true，则默认创建的Executor为CachingExecutor，并且其内部包裹着SimpleExecutor。&lt;br&gt;代码@4：使用InterceptorChain.pluginAll为executor创建代理对象，即Mybatis的拆件机制，将在该系列文章中详细介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://example.com/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://example.com/tags/mybatis/"/>
    
    <category term="Executor" scheme="http://example.com/tags/Executor/"/>
    
    <category term="StatementHandler" scheme="http://example.com/tags/StatementHandler/"/>
    
    <category term="ParameterHandler" scheme="http://example.com/tags/ParameterHandler/"/>
    
    <category term="ResultSetHandler" scheme="http://example.com/tags/ResultSetHandler/"/>
    
  </entry>
  
  <entry>
    <title>源码分析Mybatis MappedStatement的创建流程</title>
    <link href="http://example.com/posts/18c7756d.html"/>
    <id>http://example.com/posts/18c7756d.html</id>
    <published>2020-12-09T14:51:35.000Z</published>
    <updated>2020-12-11T14:46:15.097Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>上文<a href="https://blog.csdn.net/prestigeding/article/details/90415680">源码分析Mybatis MapperProxy创建流程</a>重点阐述MapperProxy的创建流程，但并没有介绍*.Mapper.java(UserMapper.java)是如何与*Mapper.xml文件中的SQL语句是如何建立关联的。本文将重点接开这个谜团。</p><p>接下来重点从源码的角度分析Mybatis MappedStatement的创建流程。</p><h2 id="1、上节回顾"><a href="#1、上节回顾" class="headerlink" title="1、上节回顾"></a>1、上节回顾</h2><p>我们注意到这里有两三个与Mapper相关的配置：</p><ol><li>SqlSessionFactory#mapperLocations，指定xml文件的配置路径。</li><li>SqlSessionFactory#configLocation，指定mybaits的配置文件，该配置文件也可以配置mapper.xml的配置路径信息。</li><li>MapperScannerConfigurer，扫描Mapper的java类(DAO)。</li></ol><p>我们已经详细介绍了Mybatis Mapper对象的扫描与构建，那接下来我们将重点介绍MaperProxy与mapper.xml文件是如何建立关联关系的。</p><p>根据上面的罗列以及上文的讲述，Mapper.xml与Mapper建立联系主要的入口有三：<br>1）MapperScannerConfigurer扫描Bean流程中，在调用MapperReigistry#addMapper时如果Mapper对应的映射文件(Mapper.xml)未加载到内存，会触发加载。<br>2）实例化SqlSessionFactory时，如果配置了mapperLocations。<br>3）示例化SqlSessionFactory时，如果配置了configLocation。</p><p>本节的行文思路：从SqlSessionFacotry的初始化开始讲起，因为mapperLocations、configLocation都是是SqlSessionFactory的属性。</p><blockquote><p>温馨提示：下面开始从源码的角度对其进行介绍，大家可以先跳到文末看看其调用序列图。</p></blockquote><a id="more"></a><h2 id="2、SqlSessionFacotry"><a href="#2、SqlSessionFacotry" class="headerlink" title="2、SqlSessionFacotry"></a>2、SqlSessionFacotry</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (xmlConfigBuilder != <span class="keyword">null</span>) &#123;  <span class="comment">// XMLConfigBuilder   // @1</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        xmlConfigBuilder.parse();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">&quot;Parsed configuration file: &#x27;&quot;</span> + <span class="keyword">this</span>.configLocation + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">&quot;Failed to parse config resource: &quot;</span> + <span class="keyword">this</span>.configLocation, ex);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isEmpty(<span class="keyword">this</span>.mapperLocations)) &#123;   <span class="comment">// @2</span></span><br><span class="line">      <span class="keyword">for</span> (Resource mapperLocation : <span class="keyword">this</span>.mapperLocations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mapperLocation == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          XMLMapperBuilder xmlMapperBuilder = <span class="keyword">new</span> XMLMapperBuilder(mapperLocation.getInputStream(),</span><br><span class="line">              configuration, mapperLocation.toString(), configuration.getSqlFragments());</span><br><span class="line">          xmlMapperBuilder.parse();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">&quot;Failed to parse mapping resource: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          ErrorContext.instance().reset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">&quot;Parsed mapper file: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Property &#x27;mapperLocations&#x27; was not specified or no matching resources found&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上文有两个入口：<br>代码@1：处理configLocation属性。<br>代码@2：处理mapperLocations属性。</p><p>我们先从XMLConfigBuilder#parse开始进行追踪。该方法主要是解析configLocation指定的配置路径，对其进行解析，具体调用parseConfiguration方法。</p><h3 id="2-1-XMLConfigBuilder"><a href="#2-1-XMLConfigBuilder" class="headerlink" title="2.1 XMLConfigBuilder"></a>2.1 XMLConfigBuilder</h3><p>我们直接查看其parseConfiguration方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      propertiesElement(root.evalNode(<span class="string">&quot;properties&quot;</span>)); <span class="comment">//issue #117 read properties first</span></span><br><span class="line">      typeAliasesElement(root.evalNode(<span class="string">&quot;typeAliases&quot;</span>));</span><br><span class="line">      pluginElement(root.evalNode(<span class="string">&quot;plugins&quot;</span>));</span><br><span class="line">      objectFactoryElement(root.evalNode(<span class="string">&quot;objectFactory&quot;</span>));</span><br><span class="line">      objectWrapperFactoryElement(root.evalNode(<span class="string">&quot;objectWrapperFactory&quot;</span>));</span><br><span class="line">      settingsElement(root.evalNode(<span class="string">&quot;settings&quot;</span>));</span><br><span class="line">      environmentsElement(root.evalNode(<span class="string">&quot;environments&quot;</span>)); <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">      databaseIdProviderElement(root.evalNode(<span class="string">&quot;databaseIdProvider&quot;</span>));</span><br><span class="line">      typeHandlerElement(root.evalNode(<span class="string">&quot;typeHandlers&quot;</span>));</span><br><span class="line">      mapperElement(root.evalNode(<span class="string">&quot;mappers&quot;</span>));   <span class="comment">// @1</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>重点关注mapperElement，从名称与参数即可以看出，该方法主要是处理中mappers的定义，即mapper sql语句的解析与处理。如果使用过Mapper的人应该不难知道，我们使用mapper节点，通过resource标签定义具体xml文件的位置。</p><h4 id="2-1-1XMLConfigBuilder-mapperElement"><a href="#2-1-1XMLConfigBuilder-mapperElement" class="headerlink" title="2.1.1XMLConfigBuilder#mapperElement"></a>2.1.1XMLConfigBuilder#mapperElement</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">          String mapperPackage = child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">          configuration.addMappers(mapperPackage);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          String resource = child.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">          String url = child.getStringAttribute(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">          String mapperClass = child.getStringAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ErrorContext.instance().resource(resource);</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());    <span class="comment">// @1</span></span><br><span class="line">            mapperParser.parse();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ErrorContext.instance().resource(url);</span><br><span class="line">            InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">            XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">            mapperParser.parse();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">            configuration.addMapper(mapperInterface);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面的代码比较简单，不难看出，解析出Mapper标签，解析出resource标签的属性，创建对应的文件流，通过构建XMLMapperBuilder来解析对应的mapper.xml文件。此时大家会惊讶的发现，在SqlSessionFacotry的初始化代码中，处理mapperLocations时就是通过构建XMLMapperBuilder来解析mapper文件，其实也不难理解，因为这是mybatis支持的两个地方可以使用mapper标签来定义mapper映射文件，具体解析代码当然是一样的逻辑。那我们解析来重点把目光投向XMLMapperBuilder。</p><h3 id="2-2-XMLMapperBuilder"><a href="#2-2-XMLMapperBuilder" class="headerlink" title="2.2 XMLMapperBuilder"></a>2.2 XMLMapperBuilder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">XMLMapperBuilder#parse</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;     <span class="comment">// @1</span></span><br><span class="line">      configurationElement(parser.evalNode(<span class="string">&quot;/mapper&quot;</span>));</span><br><span class="line">      configuration.addLoadedResource(resource);</span><br><span class="line">      bindMapperForNamespace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parsePendingResultMaps();                                    <span class="comment">// @2</span></span><br><span class="line">    parsePendingChacheRefs();                                   <span class="comment">// @3</span></span><br><span class="line">    parsePendingStatements();                                     <span class="comment">// @4</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果该映射文件(*.Mapper.xml)文件未加载，则首先先加载，完成xml文件的解析，提取xml中与mybatis相关的数据，例如sql、resultMap等等。<br>代码@2：处理mybatis xml中ResultMap。<br>代码@3：处理mybatis缓存相关的配置。<br>代码@4：处理mybatis statment相关配置，这里就是本篇关注的，Sql语句如何与Mapper进行关联的核心实现。</p><p>接下来我们重点探讨parsePendingStatements()方法，解析statement(对应SQL语句)。</p><h4 id="2-2-1-XMLMapperBuilder-parsePendingStatements"><a href="#2-2-1-XMLMapperBuilder-parsePendingStatements" class="headerlink" title="2.2.1 XMLMapperBuilder#parsePendingStatements"></a>2.2.1 XMLMapperBuilder#parsePendingStatements</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parsePendingStatements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Collection&lt;XMLStatementBuilder&gt; incompleteStatements = configuration.getIncompleteStatements();</span><br><span class="line">  <span class="keyword">synchronized</span> (incompleteStatements) &#123;</span><br><span class="line">  Iterator&lt;XMLStatementBuilder&gt; iter = incompleteStatements.iterator();    <span class="comment">// @1</span></span><br><span class="line">  <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  iter.next().parseStatementNode();   <span class="comment">// @2</span></span><br><span class="line">  iter.remove();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">  <span class="comment">// Statement is still missing a resource...</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码@1：遍历解析出来的所有SQL语句，用的是XMLStatementBuilder对象封装的，故接下来重点看一下代码@2，如果解析statmentNode。</p><h4 id="2-2-2-XMLStatementBuilder-parseStatementNode"><a href="#2-2-2-XMLStatementBuilder-parseStatementNode" class="headerlink" title="2.2.2 XMLStatementBuilder#parseStatementNode"></a>2.2.2 XMLStatementBuilder#parseStatementNode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseStatementNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String id = context.getStringAttribute(<span class="string">&quot;id&quot;</span>);                                                                  <span class="comment">// @1 start</span></span><br><span class="line">    String databaseId = context.getStringAttribute(<span class="string">&quot;databaseId&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!databaseIdMatchesCurrent(id, databaseId, <span class="keyword">this</span>.requiredDatabaseId)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Integer fetchSize = context.getIntAttribute(<span class="string">&quot;fetchSize&quot;</span>);</span><br><span class="line">    Integer timeout = context.getIntAttribute(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">    String parameterMap = context.getStringAttribute(<span class="string">&quot;parameterMap&quot;</span>);</span><br><span class="line">    String parameterType = context.getStringAttribute(<span class="string">&quot;parameterType&quot;</span>);</span><br><span class="line">    Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);</span><br><span class="line">    String resultMap = context.getStringAttribute(<span class="string">&quot;resultMap&quot;</span>);</span><br><span class="line">    String resultType = context.getStringAttribute(<span class="string">&quot;resultType&quot;</span>);</span><br><span class="line">    String lang = context.getStringAttribute(<span class="string">&quot;lang&quot;</span>);</span><br><span class="line">    LanguageDriver langDriver = getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">    String resultSetType = context.getStringAttribute(<span class="string">&quot;resultSetType&quot;</span>);</span><br><span class="line">    StatementType statementType = StatementType.valueOf(context.getStringAttribute(<span class="string">&quot;statementType&quot;</span>, StatementType.PREPARED.toString()));</span><br><span class="line">    ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);</span><br><span class="line"></span><br><span class="line">    String nodeName = context.getNode().getNodeName();</span><br><span class="line">    SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">    <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">    <span class="keyword">boolean</span> flushCache = context.getBooleanAttribute(<span class="string">&quot;flushCache&quot;</span>, !isSelect);</span><br><span class="line">    <span class="keyword">boolean</span> useCache = context.getBooleanAttribute(<span class="string">&quot;useCache&quot;</span>, isSelect);</span><br><span class="line">    <span class="keyword">boolean</span> resultOrdered = context.getBooleanAttribute(<span class="string">&quot;resultOrdered&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Include Fragments before parsing</span></span><br><span class="line">    XMLIncludeTransformer includeParser = <span class="keyword">new</span> XMLIncludeTransformer(configuration, builderAssistant);</span><br><span class="line">    includeParser.applyIncludes(context.getNode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse selectKey after includes and remove them.</span></span><br><span class="line">    processSelectKeyNodes(id, parameterTypeClass, langDriver);             <span class="comment">// @1 end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed)</span></span><br><span class="line">    SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);                <span class="comment">// @2</span></span><br><span class="line">    String resultSets = context.getStringAttribute(<span class="string">&quot;resultSets&quot;</span>);</span><br><span class="line">    String keyProperty = context.getStringAttribute(<span class="string">&quot;keyProperty&quot;</span>);</span><br><span class="line">    String keyColumn = context.getStringAttribute(<span class="string">&quot;keyColumn&quot;</span>);</span><br><span class="line">    KeyGenerator keyGenerator;</span><br><span class="line">    String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">    keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">      keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      keyGenerator = context.getBooleanAttribute(<span class="string">&quot;useGeneratedKeys&quot;</span>,</span><br><span class="line">          configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">          ? <span class="keyword">new</span> Jdbc3KeyGenerator() : <span class="keyword">new</span> NoKeyGenerator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,                             <span class="comment">// @3</span></span><br><span class="line">        fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">        resultSetTypeEnum, flushCache, useCache, resultOrdered, </span><br><span class="line">        keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个方法有点长，其关注点主要有3个：<br>代码@1：构建基本属性，其实就是构建MappedStatement的属性，因为MappedStatement对象就是用来描述Mapper-SQL映射的对象。</p><p>代码@2：根据xml配置的内容，解析出实际的SQL语句，使用SqlSource对象来表示。</p><p>代码@3：使用MapperBuilderAssistant对象，根据准备好的属性，构建MappedStatement对象，最终将其存储在Configuration中。</p><h4 id="2-2-3-Configuration-addMappedStatement"><a href="#2-2-3-Configuration-addMappedStatement" class="headerlink" title="2.2.3 Configuration#addMappedStatement"></a>2.2.3 Configuration#addMappedStatement</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMappedStatement</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">   mappedStatements.put(ms.getId(), ms);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MappedStatement的id为：mapperInterface + methodName，例如com.demo.dao.UserMapper.findUser。</p><p>即上述流程完成了xml的解析与初始化，对终极目标是创建MappedStatement对象，上一篇文章介绍了mapperInterface的初始化，最终会初始化为MapperProxy对象，那这两个对象如何关联起来呢？</p><p>从下文可知，MapperProxy与MappedStatement是在调用具Mapper方法时，可以根据mapperInterface.getName + methodName构建出MappedStatement的id，然后就可以从Configuration的mappedStatements容器中根据id获取到对应的MappedStatement对象，这样就建立起联系了。</p><p>其对应的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MapperMethod 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MapperMethod</span><span class="params">(Class&lt;?&gt; mapperInterface, Method method, Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.command = <span class="keyword">new</span> SqlCommand(config, mapperInterface, method);</span><br><span class="line">    <span class="keyword">this</span>.method = <span class="keyword">new</span> MethodSignature(config, method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SqlCommand 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SqlCommand</span><span class="params">(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method)</span> <span class="keyword">throws</span> BindingException </span>&#123;</span><br><span class="line">      String statementName = mapperInterface.getName() + <span class="string">&quot;.&quot;</span> + method.getName();</span><br><span class="line">      MappedStatement ms = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (configuration.hasStatement(statementName)) &#123;</span><br><span class="line">        ms = configuration.getMappedStatement(statementName);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mapperInterface.equals(method.getDeclaringClass().getName())) &#123; <span class="comment">// issue #35</span></span><br><span class="line">        String parentStatementName = method.getDeclaringClass().getName() + <span class="string">&quot;.&quot;</span> + method.getName();</span><br><span class="line">        <span class="keyword">if</span> (configuration.hasStatement(parentStatementName)) &#123;</span><br><span class="line">          ms = configuration.getMappedStatement(parentStatementName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (ms == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Invalid bound statement (not found): &quot;</span> + statementName);</span><br><span class="line">      &#125;</span><br><span class="line">      name = ms.getId();</span><br><span class="line">      type = ms.getSqlCommandType();</span><br><span class="line">      <span class="keyword">if</span> (type == SqlCommandType.UNKNOWN) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Unknown execution method for: &quot;</span> + name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>怎么样，从上面的源码分析中，大家是否已经了解MapperProxy与Xml中的SQL语句是怎样建立的关系了吗？为了让大家更清晰的了解上述过程，现给出其调用时序图：<br><img src="https://img-blog.csdnimg.cn/2019052321283257.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;上文&lt;a href=&quot;https://blog.csdn.net/prestigeding/article/details/90415680&quot;&gt;源码分析Mybatis MapperProxy创建流程&lt;/a&gt;重点阐述MapperProxy的创建流程，但并没有介绍*.Mapper.java(UserMapper.java)是如何与*Mapper.xml文件中的SQL语句是如何建立关联的。本文将重点接开这个谜团。&lt;/p&gt;
&lt;p&gt;接下来重点从源码的角度分析Mybatis MappedStatement的创建流程。&lt;/p&gt;
&lt;h2 id=&quot;1、上节回顾&quot;&gt;&lt;a href=&quot;#1、上节回顾&quot; class=&quot;headerlink&quot; title=&quot;1、上节回顾&quot;&gt;&lt;/a&gt;1、上节回顾&lt;/h2&gt;&lt;p&gt;我们注意到这里有两三个与Mapper相关的配置：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SqlSessionFactory#mapperLocations，指定xml文件的配置路径。&lt;/li&gt;
&lt;li&gt;SqlSessionFactory#configLocation，指定mybaits的配置文件，该配置文件也可以配置mapper.xml的配置路径信息。&lt;/li&gt;
&lt;li&gt;MapperScannerConfigurer，扫描Mapper的java类(DAO)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们已经详细介绍了Mybatis Mapper对象的扫描与构建，那接下来我们将重点介绍MaperProxy与mapper.xml文件是如何建立关联关系的。&lt;/p&gt;
&lt;p&gt;根据上面的罗列以及上文的讲述，Mapper.xml与Mapper建立联系主要的入口有三：&lt;br&gt;1）MapperScannerConfigurer扫描Bean流程中，在调用MapperReigistry#addMapper时如果Mapper对应的映射文件(Mapper.xml)未加载到内存，会触发加载。&lt;br&gt;2）实例化SqlSessionFactory时，如果配置了mapperLocations。&lt;br&gt;3）示例化SqlSessionFactory时，如果配置了configLocation。&lt;/p&gt;
&lt;p&gt;本节的行文思路：从SqlSessionFacotry的初始化开始讲起，因为mapperLocations、configLocation都是是SqlSessionFactory的属性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;温馨提示：下面开始从源码的角度对其进行介绍，大家可以先跳到文末看看其调用序列图。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://example.com/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://example.com/tags/mybatis/"/>
    
    <category term="MappedStatement" scheme="http://example.com/tags/MappedStatement/"/>
    
  </entry>
  
  <entry>
    <title>源码分析Mybatis MapperProxy初始化之Mapper对象的扫描与构建</title>
    <link href="http://example.com/posts/47c4bb93.html"/>
    <id>http://example.com/posts/47c4bb93.html</id>
    <published>2020-12-09T14:49:35.000Z</published>
    <updated>2020-12-11T14:45:48.703Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>MapperScannerConfigurer，Spring整合Mybatis的核心类，其作用是扫描项目中Dao类，将其创建为Mybatis的Maper对象即MapperProxy对象。</p><p>首先进入源码学习之前，我们先看一下在项目中的配置文件信息。<br><img src="https://img-blog.csdnimg.cn/20190521205718910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们注意到这里有两三个与Mapper相关的配置：</p><ol><li>SqlSessionFactory#mapperLocations，指定xml文件的配置路径。</li><li>SqlSessionFactory#configLocation，指定mybaits的配置文件，该配置文件也可以配置mapper.xml的配置路径信息。</li><li>MapperScannerConfigurer，扫描Mapper的java类(DAO)。</li></ol><p>本文的行文思路如下：</p><ol><li>Mybatis MapperProxy对象的扫描与构建</li><li>Mapper类与SQL语句如何建立关联<br>这部分主要阐述Java类的运行实例Mapper对象（例如UserMapper、BookMapper)是如何与mapper.xml(UserMapper.xml、BookMapper.xml文件建立联系的)。</li></ol><h2 id="Mybatis-MapperProxy对象创建流程"><a href="#Mybatis-MapperProxy对象创建流程" class="headerlink" title="Mybatis MapperProxy对象创建流程"></a>Mybatis MapperProxy对象创建流程</h2><p>下面的源码分析或许会比较枯燥，进入源码分析之前，先给出MapperProxy的创建序列图。</p><h3 id="1-1-MapperProxy创建序列图"><a href="#1-1-MapperProxy创建序列图" class="headerlink" title="1.1 MapperProxy创建序列图"></a>1.1 MapperProxy创建序列图</h3><p><img src="https://img-blog.csdnimg.cn/20190521215333400.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-2-MapperScannerConfigurer详解"><a href="#1-2-MapperScannerConfigurer详解" class="headerlink" title="1.2 MapperScannerConfigurer详解"></a>1.2 MapperScannerConfigurer详解</h3><p>MapperScannerConfigurer的类图如下所示：<br><img src="https://img-blog.csdnimg.cn/20190521210119671.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>MapperScannerConfigurer实现Spring Bean生命周期相关的类：BeanNameAware、ApplicationContextAware、BeanFactoryPostProcessor、InitializingBean、BeanDefinitionRegistryPostProcessor，我们先来看一下这些接口对应的方法的调用时机：</p><a id="more"></a><ul><li>BeanNameAware<br>是Bean对自己的名称感知，也就是在Bean创建的时候，自动将Bean的名称设置在Bean中，外部应用程序不需要调用setBeanName，就可以通过getBeanName()方法获取其bean名称。</li><li>ApplicationContextAware<br>自动感知ApplicationContext对象，即在Bean创建的时候，Spring工厂会自动将当前的ApplicationContext注入该Bean中。</li><li>InitializingBean<br>实现该接口，Spring在初始化Bean后会自动调用InitializingBean#afterPropertiesSet方法。</li><li>BeanFactoryPostProcessor<br>BeanFactory后置处理器，这个时候只是创建好了Bean的定义信息(BeanDefinition)，在BeanFactoryPostProcessor接口的postProcessBeanFactory方法中，我们可以修改bean的定义信息，例如修改属性的值，修改bean的scope为单例或者多例。与其相似的是BeanPostProcessor，这个是在bean初始化前后对Bean执行，即bean的构造方法调用后，init-method前执行。</li><li>BeanDefinitionRegistryPostProcessor<br>主要用来增加Bean的定义，增加BeanDefinition。由于MapperScannerConfigurer主要的目的就是扫描特定的包，并创建对应的Mapper对象，估这里是MapperScannerConfigurer重点实现的接口。</li></ul><p>那我们接下来从BeanDefinitionRegistryPostProcessor的实现接口开始跟踪。</p><h4 id="BeanDefinitionRegistryPostProcessor-postProcessBeanDefinitionRegistry"><a href="#BeanDefinitionRegistryPostProcessor-postProcessBeanDefinitionRegistry" class="headerlink" title="BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry"></a>BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123;</span><br><span class="line">    if (this.processPropertyPlaceHolders) &#123;</span><br><span class="line">      processPropertyPlaceHolders();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClassPathMapperScanner scanner &#x3D; new ClassPathMapperScanner(registry);</span><br><span class="line">    scanner.setAddToConfig(this.addToConfig);</span><br><span class="line">    scanner.setAnnotationClass(this.annotationClass);</span><br><span class="line">    scanner.setMarkerInterface(this.markerInterface);</span><br><span class="line">    scanner.setSqlSessionFactory(this.sqlSessionFactory);     &#x2F;&#x2F; @1</span><br><span class="line">    scanner.setSqlSessionTemplate(this.sqlSessionTemplate);</span><br><span class="line">    scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName);   </span><br><span class="line">    scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName);</span><br><span class="line">    scanner.setResourceLoader(this.applicationContext);</span><br><span class="line">    scanner.setBeanNameGenerator(this.nameGenerator);</span><br><span class="line">    scanner.registerFilters();</span><br><span class="line">    scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));    &#x2F;&#x2F; @2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先设置SqlSessionFactory，从该Scan器生成的Mapper最终都是受该SqlSessionFactory的管辖。<br>代码@2：调用ClassPathMapperScanner的scan方法进行扫描动作，接下来详细介绍。</p><h4 id="ClassPathMapperScanner-doScan"><a href="#ClassPathMapperScanner-doScan" class="headerlink" title="ClassPathMapperScanner#doScan"></a>ClassPathMapperScanner#doScan</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123;</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions &#x3D; super.doScan(basePackages);   &#x2F;&#x2F;@1</span><br><span class="line">    if (beanDefinitions.isEmpty()) &#123;</span><br><span class="line">      logger.warn(&quot;No MyBatis mapper was found in &#39;&quot; + Arrays.toString(basePackages) + &quot;&#39; package. Please check your configuration.&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      processBeanDefinitions(beanDefinitions);   &#x2F;&#x2F; @2</span><br><span class="line">    &#125;</span><br><span class="line">    return beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先调用父类(org.springframework.context.annotation.ClassPathBeanDefinitionScanner)方法，根据扫描的文件，构建对应的BeanDefinitionHolder对象。<br>代码@2：对这些BeanDefinitions进行处理，对Bean进行加工，加入Mybatis特性。</p><h4 id="ClassPathMapperScanner-processBeanDefinitions"><a href="#ClassPathMapperScanner-processBeanDefinitions" class="headerlink" title="ClassPathMapperScanner#processBeanDefinitions"></a>ClassPathMapperScanner#processBeanDefinitions</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">private void processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt; beanDefinitions) &#123;</span><br><span class="line">    GenericBeanDefinition definition;</span><br><span class="line">    for (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">      definition &#x3D; (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">      if (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(&quot;Creating MapperFactoryBean with name &#39;&quot; + holder.getBeanName() </span><br><span class="line">          + &quot;&#39; and &#39;&quot; + definition.getBeanClassName() + &quot;&#39; mapperInterface&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; the mapper interface is the original class of the bean</span><br><span class="line">      &#x2F;&#x2F; but, the actual class of the bean is MapperFactoryBean</span><br><span class="line">      definition.getPropertyValues().add(&quot;mapperInterface&quot;, definition.getBeanClassName());</span><br><span class="line">      definition.setBeanClass(this.mapperFactoryBean.getClass());   &#x2F;&#x2F; @1</span><br><span class="line">      definition.getPropertyValues().add(&quot;addToConfig&quot;, this.addToConfig);</span><br><span class="line">      boolean explicitFactoryUsed &#x3D; false;</span><br><span class="line">      if (StringUtils.hasText(this.sqlSessionFactoryBeanName)) &#123;    &#x2F;&#x2F; @2 start</span><br><span class="line">        definition.getPropertyValues().add(&quot;sqlSessionFactory&quot;, new RuntimeBeanReference(this.sqlSessionFactoryBeanName));</span><br><span class="line">        explicitFactoryUsed &#x3D; true;</span><br><span class="line">      &#125; else if (this.sqlSessionFactory !&#x3D; null) &#123;</span><br><span class="line">        definition.getPropertyValues().add(&quot;sqlSessionFactory&quot;, this.sqlSessionFactory);</span><br><span class="line">        explicitFactoryUsed &#x3D; true;</span><br><span class="line">      &#125;    &#x2F;&#x2F; @2 end</span><br><span class="line"></span><br><span class="line">      if (StringUtils.hasText(this.sqlSessionTemplateBeanName)) &#123;  &#x2F;&#x2F; @3</span><br><span class="line">        if (explicitFactoryUsed) &#123;</span><br><span class="line">          logger.warn(&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;, new RuntimeBeanReference(this.sqlSessionTemplateBeanName));</span><br><span class="line">        explicitFactoryUsed &#x3D; true;</span><br><span class="line">      &#125; else if (this.sqlSessionTemplate !&#x3D; null) &#123;</span><br><span class="line">        if (explicitFactoryUsed) &#123;</span><br><span class="line">          logger.warn(&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;, this.sqlSessionTemplate);</span><br><span class="line">        explicitFactoryUsed &#x3D; true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!explicitFactoryUsed) &#123;</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(&quot;Enabling autowire by type for MapperFactoryBean with name &#39;&quot; + holder.getBeanName() + &quot;&#39;.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>该方法有3个关键点：<br>代码@1：BeanDefinition中的beanClass设置的类为MapperFactoryBean，即该BeanDefinition初始化的实例为MapperFactoryBean，其名字可以看出，这是一个FactoryBean对象，会通过其getObject方法进行构建具体实例。</p><p>代码@2：将为MapperFactoryBean设置属性，将SqlSessionFactory放入其属性中，在实例化时可以自动获取到该SqlSessionFactory。</p><p>代码@3：如果sqlSessionTemplate不为空，则放入到属性中，以便Spring在实例化MapperFactoryBean时可以得到对应的SqlSessionTemplate。</p><p>分析到这里，MapperScannerConfigurer的doScan方法就结束了，但并没有初始化Mapper，只是创建了很多的BeanDefinition,并且其beanClass为MapperFactoryBean，那我们将目光转向MapperFactoryBean。</p><h3 id="1-3-MapperFactoryBean"><a href="#1-3-MapperFactoryBean" class="headerlink" title="1.3 MapperFactoryBean"></a>1.3 MapperFactoryBean</h3><p>MapperFactoryBean的类图如下：<br><img src="https://img-blog.csdnimg.cn/20190521210725838.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>先对上述核心类做一个简述：</p><h4 id="DaoSupport"><a href="#DaoSupport" class="headerlink" title="DaoSupport"></a>DaoSupport</h4><p>Dao层的基类，定义一个模板方法，供其子类实现具体的逻辑，DaoSupport的模板方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final void afterPropertiesSet() throws IllegalArgumentException, BeanInitializationException &#123;</span><br><span class="line">&#x2F;&#x2F; Let abstract subclasses check their configuration.</span><br><span class="line">checkDaoConfig(); &#x2F;&#x2F; @1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Let concrete implementations initialize themselves.</span><br><span class="line">try &#123;</span><br><span class="line">initDao();           &#x2F;&#x2F; @2</span><br><span class="line">&#125; catch (Exception ex) &#123;</span><br><span class="line">throw new BeanInitializationException(&quot;Initialization of DAO failed&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：检查或构建dao的配置信息，该方法为抽象类，供子类实现，等下我们本节的主角MapperFactoryBean主要实现该方法，从而实现与Mybatis相关的整合信息。<br>代码@2：初始化Dao相关的方法，该方法为一个空实现。</p><h4 id="SqlSessionDaoSupport"><a href="#SqlSessionDaoSupport" class="headerlink" title="SqlSessionDaoSupport"></a>SqlSessionDaoSupport</h4><p>SqlSession支持父类，通过使用SqlSessionFactory或SqlSessionTemplate创建SqlSession，那下面两个方法会在什么时候被调用呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory)</span><br><span class="line">public void setSqlSessionTemplate(SqlSessionTemplate sqlSessionTemplate)</span><br></pre></td></tr></table></figure><p>不知道大家还记不记得，在创建MapperFactoryBean的时候，其属性里会设置SqlSessionFacotry或SqlSessionTemplate，见上文代码(processBeanDefinitions)，这样的话在示例化Bean时，Spring会自动注入实例，即在实例化Bean时，上述方法中的一个或多个会被调用。</p><h4 id="MapperFactoryBean"><a href="#MapperFactoryBean" class="headerlink" title="MapperFactoryBean"></a>MapperFactoryBean</h4><p>主要看它是如何实现checkDaoConfig的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MapperFactoryBean#checkDaoConfig</span><br><span class="line">protected void checkDaoConfig() &#123;</span><br><span class="line">    super.checkDaoConfig();   &#x2F;&#x2F; @1</span><br><span class="line"></span><br><span class="line">    notNull(this.mapperInterface, &quot;Property &#39;mapperInterface&#39; is required&quot;);</span><br><span class="line"></span><br><span class="line">    Configuration configuration &#x3D; getSqlSession().getConfiguration();</span><br><span class="line">    if (this.addToConfig &amp;&amp; !configuration.hasMapper(this.mapperInterface)) &#123;     &#x2F;&#x2F; @2</span><br><span class="line">      try &#123;</span><br><span class="line">        configuration.addMapper(this.mapperInterface);                                        </span><br><span class="line">      &#125; catch (Throwable t) &#123;</span><br><span class="line">        logger.error(&quot;Error while adding the mapper &#39;&quot; + this.mapperInterface + &quot;&#39; to configuration.&quot;, t);</span><br><span class="line">        throw new IllegalArgumentException(t);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先先调用父类的checkDaoConfig方法。<br>代码@2：mapperInterface，就是具体的Mapper的接口类，例如com.demo.dao.UserMapper，如果以注册，则抛出异常，否则调用configuration增加Mapper。</p><p>接下来进入到org.apache.ibatis.session.Configuration中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; void addMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">    mapperRegistry.addMapper(type);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line">    return mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean hasMapper(Class&lt;?&gt; type) &#123;</span><br><span class="line">   return mapperRegistry.hasMapper(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，正在注册(添加)、查询、获取Mapper的核心类为MapperRegistry。</p><h3 id="1-4-MapperRegistry"><a href="#1-4-MapperRegistry" class="headerlink" title="1.4 MapperRegistry"></a>1.4 MapperRegistry</h3><p>其核心类图如下所示：<br><img src="https://img-blog.csdnimg.cn/20190521211339211.png" alt="在这里插入图片描述"><br>对其属性做个简单的介绍：</p><ul><li>Configuration config<br>Mybatis全局配置对象。</li><li>Map&lt;Class<?>, MapperProxyFactory<?>&gt; knownMappers<br>已注册Map，这里的键值为mapper接口，例如com.demo.dao.UserMapper，值为MapperProxyFactory，创建MapperProxy的工厂。</li></ul><p>下面简单介绍MapperRegistry的几个方法，其实现都比较简单。</p><h4 id="MapperRegistry-addMapper"><a href="#MapperRegistry-addMapper" class="headerlink" title="MapperRegistry#addMapper"></a>MapperRegistry#addMapper</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; void addMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">    if (type.isInterface()) &#123;</span><br><span class="line">      if (hasMapper(type)) &#123;   &#x2F;&#x2F; @1</span><br><span class="line">        throw new BindingException(&quot;Type &quot; + type + &quot; is already known to the MapperRegistry.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      boolean loadCompleted &#x3D; false;</span><br><span class="line">      try &#123;</span><br><span class="line">        knownMappers.put(type, new MapperProxyFactory&lt;T&gt;(type));    &#x2F;&#x2F; @2</span><br><span class="line">        MapperAnnotationBuilder parser &#x3D; new MapperAnnotationBuilder(config, type);    &#x2F;&#x2F; @3</span><br><span class="line">        parser.parse();</span><br><span class="line">        loadCompleted &#x3D; true;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        if (!loadCompleted) &#123;</span><br><span class="line">          knownMappers.remove(type);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果该接口已经注册，则抛出已经绑定的异常。<br>代码@2：为该接口注册MapperProxyFactory，但这里只是注册其创建MapperProxy的工厂，并不是创建MapperProxy。<br>代码@3：如果Mapper对应的xml资源未加载，触发xml的绑定操作，将xml中的sql语句与Mapper建立关系。本文将不详细介绍，在下一篇中详细介绍。</p><p>注意：addMapper方法，只是为*Mapper创建对应对应的MapperProxyFactory。</p><h4 id="MapperRegistry-getMapper"><a href="#MapperRegistry-getMapper" class="headerlink" title="MapperRegistry#getMapper"></a>MapperRegistry#getMapper</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line">    final MapperProxyFactory&lt;T&gt; mapperProxyFactory &#x3D; (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);   &#x2F;&#x2F; @1</span><br><span class="line">    if (mapperProxyFactory &#x3D;&#x3D; null)</span><br><span class="line">      throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">      return mapperProxyFactory.newInstance(sqlSession);                                                                                 &#x2F;&#x2F; @2</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>根据Mapper接口与SqlSession创建MapperProxy对象。<br>代码@1：根据接口获取MapperProxyFactory。<br>代码@2：调用MapperProxyFactory的newInstance创建MapperProxy对象。</p><p>到目前为止Mybatis Mapper的初始化构造过程就完成一半了，即MapperScannerConfigurer通过包扫描，然后构建MapperProxy，但此时MapperProxy还未与mapper.xml文件中的sql语句建立关联，由于篇幅的原因，将在下一节重点介绍其关联关系建立的流程。接下来我们先一睹MapperProxy对象，毕竟这是本文最终要创建的对象，也为后续SQL的执行流程做个简单准备。</p><h3 id="1-5-MapperProxy"><a href="#1-5-MapperProxy" class="headerlink" title="1.5 MapperProxy"></a>1.5 MapperProxy</h3><p>类图如下：<br><img src="https://img-blog.csdnimg.cn/2019052121164389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上面的类都比较简单，MapperMethod，代表一个一个的Mapper方法，从SqlCommand可以看出，每一个MapperMethod都会对应一条SQL语句。</p><p>下面以一张以SqlSessionFacotry为视角的各核心类的关系图：<br><img src="https://img-blog.csdnimg.cn/20190521211724837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>温馨提示：本文只阐述了Mybatis MapperProxy的创建流程，MapperProxy与*.Mapper.xml即SQL是如何关联的本文未涉及到，这部分的内容请看下文，即将发布。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;MapperScannerConfigurer，Spring整合Mybatis的核心类，其作用是扫描项目中Dao类，将其创建为Mybatis的Maper对象即MapperProxy对象。&lt;/p&gt;
&lt;p&gt;首先进入源码学习之前，我们先看一下在项目中的配置文件信息。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190521205718910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;我们注意到这里有两三个与Mapper相关的配置：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SqlSessionFactory#mapperLocations，指定xml文件的配置路径。&lt;/li&gt;
&lt;li&gt;SqlSessionFactory#configLocation，指定mybaits的配置文件，该配置文件也可以配置mapper.xml的配置路径信息。&lt;/li&gt;
&lt;li&gt;MapperScannerConfigurer，扫描Mapper的java类(DAO)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文的行文思路如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Mybatis MapperProxy对象的扫描与构建&lt;/li&gt;
&lt;li&gt;Mapper类与SQL语句如何建立关联&lt;br&gt;这部分主要阐述Java类的运行实例Mapper对象（例如UserMapper、BookMapper)是如何与mapper.xml(UserMapper.xml、BookMapper.xml文件建立联系的)。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Mybatis-MapperProxy对象创建流程&quot;&gt;&lt;a href=&quot;#Mybatis-MapperProxy对象创建流程&quot; class=&quot;headerlink&quot; title=&quot;Mybatis MapperProxy对象创建流程&quot;&gt;&lt;/a&gt;Mybatis MapperProxy对象创建流程&lt;/h2&gt;&lt;p&gt;下面的源码分析或许会比较枯燥，进入源码分析之前，先给出MapperProxy的创建序列图。&lt;/p&gt;
&lt;h3 id=&quot;1-1-MapperProxy创建序列图&quot;&gt;&lt;a href=&quot;#1-1-MapperProxy创建序列图&quot; class=&quot;headerlink&quot; title=&quot;1.1 MapperProxy创建序列图&quot;&gt;&lt;/a&gt;1.1 MapperProxy创建序列图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190521215333400.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-2-MapperScannerConfigurer详解&quot;&gt;&lt;a href=&quot;#1-2-MapperScannerConfigurer详解&quot; class=&quot;headerlink&quot; title=&quot;1.2 MapperScannerConfigurer详解&quot;&gt;&lt;/a&gt;1.2 MapperScannerConfigurer详解&lt;/h3&gt;&lt;p&gt;MapperScannerConfigurer的类图如下所示：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190521210119671.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;MapperScannerConfigurer实现Spring Bean生命周期相关的类：BeanNameAware、ApplicationContextAware、BeanFactoryPostProcessor、InitializingBean、BeanDefinitionRegistryPostProcessor，我们先来看一下这些接口对应的方法的调用时机：&lt;/p&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://example.com/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://example.com/tags/mybatis/"/>
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="MapperProxy" scheme="http://example.com/tags/MapperProxy/"/>
    
    <category term="MapperScannerConfigurer" scheme="http://example.com/tags/MapperScannerConfigurer/"/>
    
  </entry>
  
  <entry>
    <title>使用流收集数据之toList、joining、groupBy(多字段分组)</title>
    <link href="http://example.com/posts/79082d0a.html"/>
    <id>http://example.com/posts/79082d0a.html</id>
    <published>2020-12-09T14:45:35.000Z</published>
    <updated>2020-12-11T04:38:09.510Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文将从Collectos中构建收集器入手，详细介绍java8提供了哪些收集器，重点介绍:toList、toSet、toCollection、joining、groupBy(包含多级分组)、reducing的核心实现原理与使用示例。</p><h2 id="1、toList、toSet、toCollection"><a href="#1、toList、toSet、toCollection" class="headerlink" title="1、toList、toSet、toCollection"></a>1、toList、toSet、toCollection</h2><p>首先对流中的数据进行计算，最终返回的数据类型为集合。Collectors中定义了如下3集合类收集器，其声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, C extends Collection&lt;T&gt;&gt; Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory)</span><br></pre></td></tr></table></figure><blockquote><p>温馨提示：建议根据上篇的理论，再来反推一下这些Collector中的核心属性的值，例如supplier、accumulator、combiner、characteristics。不过特别注意，toList、toCollection是不支持并行运行的，但toSet()方法支持并行运行。</p></blockquote><p>我们首先来看一个一直使用的示例，返回菜单中所有菜品的名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_toList</span><span class="params">(List&lt;Dish&gt; menu)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; names = menu.stream().map(Dish::getName)</span><br><span class="line">                        .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于toList方法的实现原理已经在 <a href="https://blog.csdn.net/prestigeding/article/details/90813819">java8读书笔记：探究java8流收集数据原理</a>中也详细介绍，故本篇不再重点介绍。</p><h2 id="2、joining"><a href="#2、joining" class="headerlink" title="2、joining"></a>2、joining</h2><p>Collectors定义了如下3个重载方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter,</span><br><span class="line">    CharSequence prefix, CharSequence suffix)</span><br></pre></td></tr></table></figure><h3 id="2-1-joining"><a href="#2-1-joining" class="headerlink" title="2.1 joining"></a>2.1 joining</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;CharSequence, StringBuilder, String&gt;(</span><br><span class="line">        StringBuilder::<span class="keyword">new</span>, StringBuilder::append,</span><br><span class="line">        (r1, r2) -&gt; &#123; r1.append(r2); <span class="keyword">return</span> r1; &#125;,</span><br><span class="line">        StringBuilder::toString, CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Supplier&lt; A&gt; supplier()<br>其函数为StringBuilder::new，即通过该方法创建一个StringBuilder方法，作为累积器的初始值。</li><li>BiConsumer&lt;A, T&gt; accumulator<br>累积器：StringBuilder::append，即会对流中的元素执行追加。</li><li>BinaryOperator&lt; A&gt; combiner<br>组合器，也是调用append方法，进行字符串的规约。</li><li>Function&lt;A,R&gt; finisher<br>转换器：由于累积器返回的最终对象为StringBuilder，并不是目标String类型，故需要调用StringBuilder#toString方法进行转换</li><li>Set&lt; Characteristics&gt; characteristics<br>无任何行为。</li></ul><p>从上面的函数定义我们可以得出该方法的作用：针对字符串流，会对流中的元素执行字符的追加动作，流元素之间没有分隔符号，示例如下：<br><img src="https://img-blog.csdnimg.cn/20190609173712998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2-2-joining-CharSequence-delimiter"><a href="#2-2-joining-CharSequence-delimiter" class="headerlink" title="2.2 joining(CharSequence delimiter)"></a>2.2 joining(CharSequence delimiter)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter) &#123;</span><br><span class="line">    <span class="keyword">return</span> joining(delimiter, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter,</span><br><span class="line">                                                         CharSequence prefix,</span><br><span class="line">                                                         CharSequence suffix) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(</span><br><span class="line">            () -&gt; <span class="keyword">new</span> StringJoiner(delimiter, prefix, suffix),</span><br><span class="line">            StringJoiner::add, StringJoiner::merge,</span><br><span class="line">            StringJoiner::toString, CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Supplier&lt; A&gt; supplier()<br>其函数为() -&gt; new StringJoiner(delimiter, prefix, suffix)，累积器的初始值为StringJoiner。</li><li>BiConsumer&lt;A, T&gt; accumulator<br>累积器：StringJoiner::append，即会对流中的元素执行追加。</li><li>BinaryOperator&lt; A&gt; combiner<br>组合器，StringJoiner::merge。</li><li>Function&lt;A,R&gt; finisher<br>转换器：由于累积器返回的最终对象为StringBuilder，并不是目标String类型，故需要调用StringBuilder#toString方法进行转换</li><li>Set&lt; Characteristics&gt; characteristics<br>无任何行为。</li></ul><p>其示例如下：<br><img src="https://img-blog.csdnimg.cn/20190609173901452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><a id="more"></a><h2 id="3、聚合相关收集器"><a href="#3、聚合相关收集器" class="headerlink" title="3、聚合相关收集器"></a>3、聚合相关收集器</h2><p>聚合相关收集器，主要包括minBy、maxBy、sum、avg等相关函数，其主要方法声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; minBy(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; maxBy(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Long&gt; summingLong(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; summingDouble(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingLong(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingDouble(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br></pre></td></tr></table></figure><p>上面这些方法比较简单，下面举个简单的例子介绍其使用：<br><img src="https://img-blog.csdnimg.cn/20190609174021453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4-分组"><a href="#4-分组" class="headerlink" title="4 分组"></a>4 分组</h2><p>Collectors提供了3个groupingBy重载方法，我们一个一个来理解。</p><h3 id="4-1-从示例入手"><a href="#4-1-从示例入手" class="headerlink" title="4.1 从示例入手"></a>4.1 从示例入手</h3><p>我们从其中一个最简单的函数说起，从而慢慢引出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(</span><br><span class="line">             Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier)</span><br></pre></td></tr></table></figure><ul><li>Collector&lt;T, ?, Map&lt;K, List&lt; T&gt;&gt;&gt;<br>首先我们先来关注该方法的返回值Collector&lt;T, ?, Map&lt;K,List&lt; T&gt;&gt;，其最终返回的数据类型为：Map&lt;K, List&lt; T&gt;&gt;</li><li>Function&lt;? super T, ? extends K&gt; classifier<br>分类函数。</li></ul><p>示例如下：例如如下是购物车实体类，并且初始化数据如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShopCar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sellerId;</span><br><span class="line">    <span class="keyword">private</span> String sellerName;</span><br><span class="line">    <span class="keyword">private</span> String goodsName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> buyerId;</span><br><span class="line">    <span class="keyword">private</span> String buyerName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化数据如下：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;ShopCar&gt; <span class="title">initShopCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> ShopCar(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;天猫&quot;</span> , <span class="string">&quot;华为手机&quot;</span>, <span class="number">1</span> , <span class="string">&quot;dingw&quot;</span>, <span class="number">5</span>),</span><br><span class="line">            <span class="keyword">new</span> ShopCar(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;京东&quot;</span> , <span class="string">&quot;华为手机&quot;</span>, <span class="number">2</span> , <span class="string">&quot;ly&quot;</span>, <span class="number">2</span>),</span><br><span class="line">            <span class="keyword">new</span> ShopCar(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;京东&quot;</span> , <span class="string">&quot;小米手机&quot;</span>, <span class="number">3</span> , <span class="string">&quot;zhl&quot;</span>, <span class="number">3</span>),</span><br><span class="line">            <span class="keyword">new</span> ShopCar(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;1号店&quot;</span> , <span class="string">&quot;华为手机&quot;</span>, <span class="number">1</span> , <span class="string">&quot;dingw&quot;</span>, <span class="number">5</span>),</span><br><span class="line">            <span class="keyword">new</span> ShopCar(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;天猫&quot;</span> , <span class="string">&quot;苹果手机&quot;</span>, <span class="number">1</span> , <span class="string">&quot;dingw&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们看一下java8之前的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_group_jdk7</span><span class="params">(List&lt;ShopCar&gt; shopCars)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, List&lt;ShopCar&gt;&gt; shopBySellerNameMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(ShopCar c : shopCars ) &#123;</span><br><span class="line">        <span class="keyword">if</span>(shopBySellerNameMap.containsKey( c.getSellerName() )) &#123;</span><br><span class="line">            shopBySellerNameMap.get(c.getSellerName()).add(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;ShopCar&gt; aList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            shopBySellerNameMap.put(c.getSellerName(), aList);</span><br><span class="line">            aList.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print(shopBySellerNameMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码应该很容易理解，根据商家名称进行分组，拥有相同商家的名称的购物车项组成一个集合，最终返回Map&lt;String, List&lt; ShopCar &gt;&gt;类型的数据。</p><p>那如何使用java8的流分组特性来编写对应的代码呢？下面的思考过程非常关键，经过前面的学习，我想大家应该也具备了如下分析与编写的能力？</p><p>首先其声明如下：public static &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt; T&gt;&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier)，那在本例中，T,K这两个参数代表什么意思呢？</p><ul><li>T : ShopCar</li><li>K : String (sellerName的类型)<br>其判断的主要依据为groupingBy方法返回的参数Collector&lt;T, ?, Map&lt;K, List&lt; T&gt;&gt;&gt;，代表&lt;T, A, R&gt;，其中最后一个泛型参数R对应的就是本例需要返回的Map&lt;K, List&lt; T&gt;&gt;，故分析出T,K代表的含义。</li></ul><p>然后再看其参数：Function&lt;? super T, ? extends K&gt; classifier,即接受的函数式编程接口为T -&gt; K，即通过ShopCar 返回一个String，又根据其名称可知，该函数为一个分类函数，故基本可以写成如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_group_jdk8</span><span class="params">(List&lt;ShopCar&gt; shopCars)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, List&lt;ShopCar&gt;&gt; shopBySellerNameMap =  </span><br><span class="line">                 shopCars</span><br><span class="line">                     .stream()</span><br><span class="line">                     .collect(Collectors.groupingBy(ShopCar::getSellerName));</span><br><span class="line">                   <span class="comment">//.collect(Collectors.groupingBy( (ShopCar c) -&gt; c.getSellerName() ))</span></span><br><span class="line">    print(shopBySellerNameMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其运行效果如下：<br><img src="https://img-blog.csdnimg.cn/20190609174540775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">为了加深对groupingBy方法的理解，接下来我们重点分析一下其源码的实现。</p><h3 id="4-2-源码分析groupingBy方法"><a href="#4-2-源码分析groupingBy方法" class="headerlink" title="4.2 源码分析groupingBy方法"></a>4.2 源码分析groupingBy方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier) &#123;  <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">return</span> groupingBy(classifier, toList());                                                                     <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：分类参数，已经在上文中详细介绍。<br>代码@2：调用groupingBy重载方法，传入的参数为toList()，有点意思，传入的参数为Collectors.toList()，结合上文中的示例，需要返回值类型为：Map&lt;String, List&lt; ShopCar&gt;&gt;，与这里的List对应起来了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier, Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</span><br><span class="line">    <span class="keyword">return</span> groupingBy(classifier, HashMap::<span class="keyword">new</span>, downstream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该重载方法，再次调用3个参数的groupingBy方法，其中第二个参数为HashMap::new，即创建一个Map对象，我们重点关注3个参数的groupingBy。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt; Collector&lt;T, ?, M&gt; groupingBy(</span><br><span class="line">                          Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier, </span><br><span class="line">Supplier&lt;M&gt; mapFactory,</span><br><span class="line">Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123; <span class="comment">// @1</span></span><br><span class="line">    Supplier&lt;A&gt; downstreamSupplier = downstream.supplier();        <span class="comment">// @2 start</span></span><br><span class="line">    BiConsumer&lt;A, ? <span class="keyword">super</span> T&gt; downstreamAccumulator = downstream.accumulator();</span><br><span class="line">    BiConsumer&lt;Map&lt;K, A&gt;, T&gt; accumulator = (m, t) -&gt; &#123;</span><br><span class="line">        K key = Objects.requireNonNull(classifier.apply(t), <span class="string">&quot;element cannot be mapped to a null key&quot;</span>);</span><br><span class="line">        A container = m.computeIfAbsent(key, k -&gt; downstreamSupplier.get());</span><br><span class="line">        downstreamAccumulator.accept(container, t);</span><br><span class="line">    &#125;; <span class="comment">// @2 end</span></span><br><span class="line"></span><br><span class="line">    BinaryOperator&lt;Map&lt;K, A&gt;&gt; merger = Collectors.&lt;K, A, Map&lt;K, A&gt;&gt;mapMerger(downstream.combiner());   <span class="comment">// @3</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Supplier&lt;Map&lt;K, A&gt;&gt; mangledFactory = (Supplier&lt;Map&lt;K, A&gt;&gt;) mapFactory;                            </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) &#123;           <span class="comment">// @4</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, CH_ID);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                                                                                            <span class="comment">// @5</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Function&lt;A, A&gt; downstreamFinisher = (Function&lt;A, A&gt;) downstream.finisher();</span><br><span class="line">        Function&lt;Map&lt;K, A&gt;, M&gt; finisher = intermediate -&gt; &#123;</span><br><span class="line">            intermediate.replaceAll((k, v) -&gt; downstreamFinisher.apply(v));</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            M castResult = (M) intermediate;</span><br><span class="line">            <span class="keyword">return</span> castResult;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, finisher, CH_NOID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：参数介绍：</p><ul><li>Function&lt;? super T, ? extends K&gt; classifier<br>分类函数。</li><li>Supplier&lt; M&gt; mapFactory<br>map构建函数。（）-&gt; Map</li><li>Collector&lt;? super T, A, D&gt; downstream<br>下游收集器，在上面的示例中，该参数为Collectos.toList()。</li></ul><p>代码@2：构建最终的累积器。其实现要点如下：</p><ul><li>对流中的元素，使用Function&lt;? super T, ? extends K&gt; classifier，获取对应的分类键值。</li><li>使用mangledFactory创建累积初始值，并调用Map#computeIfAbsent方法，放入的值为：downstreamSupplier.get()。可以类比上例中Map&lt;String, List&lt; T&gt;&gt;，请结合如下代码进行理解：<br><img src="https://img-blog.csdnimg.cn/20190609174846127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><p>代码@3：构建最终的组合器，这里使用的是Collectos.mapMerger，其内部的实现就是对每个元素，执行map#merge方法。</p><p>代码@4：如果收集器的行为为IDENTITY_FINISH，直接根据上面已创建的累积器、组合器，创建一个最终的收集器。</p><p>代码@5：如果收集器的行为不包含IDENTITY_FINISH，则需要最终调用原收集器的finisher方法。才能最终需要返回的类型。</p><p>groupingBy的原理就讲解到这里，我们接下来思考如下场景：<br>还是上面的购物车场景，现在要求先按照供应商名称分组，然后按照购买人分组（即多级分组），类似于SQL group by sellerId,buyerId。</p><p>思考过程：首先二级分类需要返回的数据类型为Map&lt;String /** sellerName*/,   Map&lt;String、/** buyerId*/，List&lt; ShopCar&gt;&gt; &gt;,而只有一个参数的groupingBy(Function&lt;? super T, ? extends K&gt; classifier)，只接受一个分类参数，其内部会调用两个参数的groupingBy(Function&lt;? super T, ? extends K&gt; classifier,Collector&lt;? super T, A, D&gt; downstream)，默认第二个参数为Collectors.toList()，故我们可以做的文章是改变这个默认值，传入符合业务场景的收集器，结合目前的需求，很显然，该参数应该是支持分组的收集器，即应该可以通过嵌套groupingBy方法，实现二级分组，其具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二级分组示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> shopCars</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_level_group</span><span class="params">(List&lt;ShopCar&gt; shopCars)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Map&lt;String, List&lt;ShopCar&gt;&gt;&gt;  result = </span><br><span class="line">        shopCars.stream().collect(Collectors.groupingBy(ShopCar::getSellerName,</span><br><span class="line">                                    Collectors.groupingBy(ShopCar::getBuyerName)));</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>温馨提示：上面介绍的分组，主要的Map存储结构为HashMap，java8为ConcurrentMap对应类继承体系提供了对应的分组函数：groupingByConcurrent，其使用方法与groupingBy方法类型，故不重复介绍。</p><h2 id="5、-partitioningBy"><a href="#5、-partitioningBy" class="headerlink" title="5、 partitioningBy"></a>5、 partitioningBy</h2><p>分区，分区可以看出是分组的特殊化，接受的分类函数返回boolean类型，即是谓词Predicate&lt;? super T&gt; predicate。其声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, D, A&gt; Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate, Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) </span><br></pre></td></tr></table></figure><p>由于其用法与分组类似，故这里就一笔带过了。</p><h2 id="6、-reducing"><a href="#6、-reducing" class="headerlink" title="6、 reducing"></a>6、 reducing</h2><p>规约。其函数声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U&gt; Collector&lt;T, ?, U&gt; reducing(U identity, Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper, BinaryOperator&lt;U&gt; op)</span><br></pre></td></tr></table></figure><p>其参数如下：</p><ul><li>U identity<br>规约初始值。</li><li>Function&lt;? super T, ? extends U&gt; mapper<br>累加器函数。</li><li>BinaryOperator<U> op<br>组合器函数。<br>关于Collectors.reducing，建议可以直接使用Stream自身提供的reducing方法。</li></ul></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将从Collectos中构建收集器入手，详细介绍java8提供了哪些收集器，重点介绍:toList、toSet、toCollection、joining、groupBy(包含多级分组)、reducing的核心实现原理与使用示例。&lt;/p&gt;
&lt;h2 id=&quot;1、toList、toSet、toCollection&quot;&gt;&lt;a href=&quot;#1、toList、toSet、toCollection&quot; class=&quot;headerlink&quot; title=&quot;1、toList、toSet、toCollection&quot;&gt;&lt;/a&gt;1、toList、toSet、toCollection&lt;/h2&gt;&lt;p&gt;首先对流中的数据进行计算，最终返回的数据类型为集合。Collectors中定义了如下3集合类收集器，其声明如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; Collector&amp;lt;T, ?, List&amp;lt;T&amp;gt;&amp;gt; toList()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; Collector&amp;lt;T, ?, Set&amp;lt;T&amp;gt;&amp;gt; toSet()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T, C extends Collection&amp;lt;T&amp;gt;&amp;gt; Collector&amp;lt;T, ?, C&amp;gt; toCollection(Supplier&amp;lt;C&amp;gt; collectionFactory)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;温馨提示：建议根据上篇的理论，再来反推一下这些Collector中的核心属性的值，例如supplier、accumulator、combiner、characteristics。不过特别注意，toList、toCollection是不支持并行运行的，但toSet()方法支持并行运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们首先来看一个一直使用的示例，返回菜单中所有菜品的名称：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test_toList&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(List&amp;lt;Dish&amp;gt; menu)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List&amp;lt;String&amp;gt; names = menu.stream().map(Dish::getName)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .collect(Collectors.toList());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于toList方法的实现原理已经在 &lt;a href=&quot;https://blog.csdn.net/prestigeding/article/details/90813819&quot;&gt;java8读书笔记：探究java8流收集数据原理&lt;/a&gt;中也详细介绍，故本篇不再重点介绍。&lt;/p&gt;
&lt;h2 id=&quot;2、joining&quot;&gt;&lt;a href=&quot;#2、joining&quot; class=&quot;headerlink&quot; title=&quot;2、joining&quot;&gt;&lt;/a&gt;2、joining&lt;/h2&gt;&lt;p&gt;Collectors定义了如下3个重载方法。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Collector&amp;lt;CharSequence, ?, String&amp;gt; joining()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Collector&amp;lt;CharSequence, ?, String&amp;gt; joining(CharSequence delimiter)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Collector&amp;lt;CharSequence, ?, String&amp;gt; joining(CharSequence delimiter,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CharSequence prefix, CharSequence suffix)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;2-1-joining&quot;&gt;&lt;a href=&quot;#2-1-joining&quot; class=&quot;headerlink&quot; title=&quot;2.1 joining&quot;&gt;&lt;/a&gt;2.1 joining&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Collector&amp;lt;CharSequence, ?, String&amp;gt; joining() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CollectorImpl&amp;lt;CharSequence, StringBuilder, String&amp;gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        StringBuilder::&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;, StringBuilder::append,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        (r1, r2) -&amp;gt; &amp;#123; r1.append(r2); &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; r1; &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        StringBuilder::toString, CH_NOID);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Supplier&amp;lt; A&amp;gt; supplier()&lt;br&gt;其函数为StringBuilder::new，即通过该方法创建一个StringBuilder方法，作为累积器的初始值。&lt;/li&gt;
&lt;li&gt;BiConsumer&amp;lt;A, T&amp;gt; accumulator&lt;br&gt;累积器：StringBuilder::append，即会对流中的元素执行追加。&lt;/li&gt;
&lt;li&gt;BinaryOperator&amp;lt; A&amp;gt; combiner&lt;br&gt;组合器，也是调用append方法，进行字符串的规约。&lt;/li&gt;
&lt;li&gt;Function&amp;lt;A,R&amp;gt; finisher&lt;br&gt;转换器：由于累积器返回的最终对象为StringBuilder，并不是目标String类型，故需要调用StringBuilder#toString方法进行转换&lt;/li&gt;
&lt;li&gt;Set&amp;lt; Characteristics&amp;gt; characteristics&lt;br&gt;无任何行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上面的函数定义我们可以得出该方法的作用：针对字符串流，会对流中的元素执行字符的追加动作，流元素之间没有分隔符号，示例如下：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190609173712998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-2-joining-CharSequence-delimiter&quot;&gt;&lt;a href=&quot;#2-2-joining-CharSequence-delimiter&quot; class=&quot;headerlink&quot; title=&quot;2.2 joining(CharSequence delimiter)&quot;&gt;&lt;/a&gt;2.2 joining(CharSequence delimiter)&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Collector&amp;lt;CharSequence, ?, String&amp;gt; joining(CharSequence delimiter) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; joining(delimiter, &lt;span class=&quot;string&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Collector&amp;lt;CharSequence, ?, String&amp;gt; joining(CharSequence delimiter,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                         CharSequence prefix,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                         CharSequence suffix) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CollectorImpl&amp;lt;&amp;gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            () -&amp;gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; StringJoiner(delimiter, prefix, suffix),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            StringJoiner::add, StringJoiner::merge,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            StringJoiner::toString, CH_NOID);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Supplier&amp;lt; A&amp;gt; supplier()&lt;br&gt;其函数为() -&amp;gt; new StringJoiner(delimiter, prefix, suffix)，累积器的初始值为StringJoiner。&lt;/li&gt;
&lt;li&gt;BiConsumer&amp;lt;A, T&amp;gt; accumulator&lt;br&gt;累积器：StringJoiner::append，即会对流中的元素执行追加。&lt;/li&gt;
&lt;li&gt;BinaryOperator&amp;lt; A&amp;gt; combiner&lt;br&gt;组合器，StringJoiner::merge。&lt;/li&gt;
&lt;li&gt;Function&amp;lt;A,R&amp;gt; finisher&lt;br&gt;转换器：由于累积器返回的最终对象为StringBuilder，并不是目标String类型，故需要调用StringBuilder#toString方法进行转换&lt;/li&gt;
&lt;li&gt;Set&amp;lt; Characteristics&amp;gt; characteristics&lt;br&gt;无任何行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其示例如下：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190609173901452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="java8" scheme="http://example.com/categories/java8/"/>
    
    
    <category term="java8" scheme="http://example.com/tags/java8/"/>
    
    <category term="Lambda" scheme="http://example.com/tags/Lambda/"/>
    
    <category term="流计算" scheme="http://example.com/tags/%E6%B5%81%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>探究java8流收集数据原理</title>
    <link href="http://example.com/posts/bfa9fca1.html"/>
    <id>http://example.com/posts/bfa9fca1.html</id>
    <published>2020-12-09T14:43:35.000Z</published>
    <updated>2020-12-11T04:38:09.518Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文揭示如何学习一门新技术，从示例入手，重点阐述Stream#collect方法的实现原理，为更好的使用java8中流来收集数据。</p><p>我们在前面的文章中反复使用的场景：获取菜单中所有菜品的名称，返回一个集合，其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_toList</span><span class="params">(List&lt;Dish&gt; menu)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; names = menu.stream().map(Dish::getName)</span><br><span class="line">                        .collect(Collectors.toList()); <span class="comment">// @1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(String s : names) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Stream.collect这个终端操作进行数据收集，至于如何收集，则由该方法的参数来决定(Collector)，即行为参数化。</p><p>代码@1：collect(Collectors.toList()) 的意思就是返回List，这里涉及到两个关键，一个是Stream#collect方法，另外一个就是其参数Collectors.toList()。</p><p>接下来我们将以上述两个突破点来揭开如何使用java8的流来收集数据。</p><h2 id="1、Stream-collect"><a href="#1、Stream-collect" class="headerlink" title="1、Stream#collect"></a>1、Stream#collect</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ReferencePipeline#collect</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> P_OUT, A, R&gt; collector)</span> </span>&#123;   <span class="comment">// @1</span></span><br><span class="line">    A container;</span><br><span class="line">    <span class="keyword">if</span> (isParallel()</span><br><span class="line">            &amp;&amp; (collector.characteristics().contains(Collector.Characteristics.CONCURRENT))</span><br><span class="line">            &amp;&amp; (!isOrdered() || collector.characteristics().contains(Collector.Characteristics.UNORDERED))) &#123;   <span class="comment">// @2</span></span><br><span class="line">        container = collector.supplier().get();                                                                 <span class="comment">// @3</span></span><br><span class="line">        BiConsumer&lt;A, ? <span class="keyword">super</span> P_OUT&gt; accumulator = collector.accumulator();</span><br><span class="line">        forEach(u -&gt; accumulator.accept(container, u));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                                                                                                     <span class="comment">// @4</span></span><br><span class="line">        container = evaluate(ReduceOps.makeRef(collector));                                                                                              </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)                    <span class="comment">// @5</span></span><br><span class="line">           ? (R) container</span><br><span class="line">           : collector.finisher().apply(container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：函数声明，该方法返回的结果类型为R，传入的行为参数接口为Collector。<br>代码@2：判断是否符合并行化累积与规约的条件。</p><ul><li>是否是并行流，例如上例中创建流的代码为menu.stream()，该方法的流是非并行化流，如果要支持并行化执行，需要满足的第一个条件就是需要使用menu.parallelStream()方法返回的流。</li><li>Collector(收集器，行为化参数)中收集器行为集合中是否包含Characteristics.CONCURRENT(并行执行)，如果不包含该行为，则不支持并行执行。</li><li>原始流是否有顺序 或 者 收集器的行为集合中明确包含Characteristics.UNORDERED(不要求顺序性)。<br>上述三个条件必须同时满足，才能并行执行，否则串行执行。</li></ul><p>代码@3：并行执行收集动作。</p><p>代码@4：串行执行收集动作。</p><p>代码@5：如果收集器收集行为集合中包含Characteristics.IDENTITY_FINISH，则直接返回原始值，否则使用Collector.finishier()方式对计算的值进行函数式计算。</p><p>通过上面的代码，我们应该对Characteristics枚举类型中的3个值不难得出如下类型：</p><ul><li>CONCURRENT<br>收集器行为，表示收集其中的累积函数是否支持并行执行。</li><li>Characteristics.UNORDERED<br>收集器行为，表示整个收集期间，没有顺序要求。</li><li>Characteristics.IDENTITY_FINISH<br>收集器行为，表示可以忽略Collector.finsher()定义的最终转换函数，直接返回累积之后的结果即可。</li></ul><blockquote><p>疑问？代码@3,这段代码不是很好理解，该怎么继续往下深入呢？</p></blockquote><p>针对上面看不太懂的代码，我的处理办法是先转移思路，看一下Collector接口以及示例中Collectos.toList()返回的收集器是什么(重点关注返回的Collector中具体属性)。</p><a id="more"></a><h2 id="2、Collector接口"><a href="#2、Collector接口" class="headerlink" title="2、Collector接口"></a>2、Collector接口</h2><p><img src="https://img-blog.csdnimg.cn/20190604211337662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>收集器中的泛型参数说明如下：</p><ul><li>T ：累积器中一个操作数类型</li><li>A： 累积器中的初始值类型</li><li>R：返回值的类型，例如List&lt; R &gt;。</li></ul><p>其属性一览如下：</p><ul><li>Supplier&lt; A &gt; supplier()<br>该函数式接口，大家应该都非常熟悉了，其函数声明如下：() -&gt; T，通常用于构建对象，那这里是构建什么对象呢？这是下一个待解疑问。</li><li>BiConsumer&lt;A, T&gt; accumulator()<br>从名字命名来看，应该是返回累积器，（T,U）-&gt; void。通常用于输入两个参数，对其进行处理，但返回void类型。</li><li>BinaryOperator&lt; A &gt; combiner()<br>从名字命令来看，应该是组合器（请参考流计算函数reduce)。</li><li>Function&lt;A, R&gt; finisher()<br>最终函数，如果收集器行为包含IDENTITY_FINISH，则无需使用该函数对累积器产生的结果进行处理，否则使用该函数对累积器结果进行最后的处理。</li><li>Set&lt; Characteristics &gt; characteristics()<br>累积器行为，在上文已做详细介绍。</li></ul><p>其supplier函数到底是干什么的呢？对上面的方法都是基于名字来推测的（当然JDK代码非常优雅，根据名字去猜测，准确度还是很高的），但如何确认呢？这个时候我们还是结合Collectos.toList()方法返回的Collector来做进一步推断。</p><h2 id="3、Collectors-toList"><a href="#3、Collectors-toList" class="headerlink" title="3、Collectors.toList()"></a>3、Collectors.toList()</h2><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>, List::add,</span><br><span class="line">                               (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">                               CH_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Collector的第一个参数Supplier，在这里为ArrayList::new，即调用supper.get()方法将返回一个List。</li><li>Collector的第二个参数accumulator:累积器，这里是List:add方法。</li><li>Collector的第三个参数combiner:组合器，这里就是(left, right) -&gt; {left.addAll(right);return left;}</li><li>Collector的第四个函数characteristics：收集器的行为，这里为CH_IL，其选项为：IDENTITY_FINISH。</li></ul><p>有了上面这些知识，我们再来看如下这段代码：<br><img src="https://img-blog.csdnimg.cn/2019060421180264.png" alt="在这里插入图片描述"><br>1、A container：累积器的初始值，如果使用Collectors.toList()，则这里会返回List<T>的对象。<br>2、获取collector中定义的累积器。<br>3、遍历流，执行累积器动作，其中形式参数u，代表流中的一个个元素。</p><p>至于forEach方法，底层流的具体实现，本文就不再往深探究。</p><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>java8 使用流来收集数据的基本用法：</p><ul><li>使用流stream的collect对象进行数据收集，其参数为Collector函数是编程接口，具体的收集逻辑由该接口来指定。</li><li>流的收集其具备基本的属性即作用：<ul><li>Supplier&lt; A &gt; supplier()<br>通过该函数式编程接口，返回累积器的初始值。</li><li>BiConsumer&lt;A, T&gt; accumulator<br>累积器函数。</li><li>BinaryOperator&lt; A &gt; combiner<br>组合器，可以参考函数式编程接口的reduce方法。</li><li>Set&lt; Characteristics &gt; characteristics<br>收集器行为。</li></ul></li><li>java8中的Collectors提供了很多默认的收集器，例如Collectors.toList()方法，下一节我们会根据该类，详细介绍在java8中默认提供的收集器，指导我们如何使用java8中的流来收集数据。</li></ul><p>下一节，将以Collectos类为入口，详细介绍java8中默认提供的收集器，已经如何使用。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文揭示如何学习一门新技术，从示例入手，重点阐述Stream#collect方法的实现原理，为更好的使用java8中流来收集数据。&lt;/p&gt;
&lt;p&gt;我们在前面的文章中反复使用的场景：获取菜单中所有菜品的名称，返回一个集合，其代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test_toList&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(List&amp;lt;Dish&amp;gt; menu)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List&amp;lt;String&amp;gt; names = menu.stream().map(Dish::getName)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .collect(Collectors.toList()); &lt;span class=&quot;comment&quot;&gt;// @1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(String s : names) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(s);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过Stream.collect这个终端操作进行数据收集，至于如何收集，则由该方法的参数来决定(Collector)，即行为参数化。&lt;/p&gt;
&lt;p&gt;代码@1：collect(Collectors.toList()) 的意思就是返回List，这里涉及到两个关键，一个是Stream#collect方法，另外一个就是其参数Collectors.toList()。&lt;/p&gt;
&lt;p&gt;接下来我们将以上述两个突破点来揭开如何使用java8的流来收集数据。&lt;/p&gt;
&lt;h2 id=&quot;1、Stream-collect&quot;&gt;&lt;a href=&quot;#1、Stream-collect&quot; class=&quot;headerlink&quot; title=&quot;1、Stream#collect&quot;&gt;&lt;/a&gt;1、Stream#collect&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ReferencePipeline#collect&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &amp;lt;R, A&amp;gt; &lt;span class=&quot;function&quot;&gt;R &lt;span class=&quot;title&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Collector&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; P_OUT, A, R&amp;gt; collector)&lt;/span&gt; &lt;/span&gt;&amp;#123;   &lt;span class=&quot;comment&quot;&gt;// @1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    A container;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isParallel()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;amp;&amp;amp; (collector.characteristics().contains(Collector.Characteristics.CONCURRENT))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;amp;&amp;amp; (!isOrdered() || collector.characteristics().contains(Collector.Characteristics.UNORDERED))) &amp;#123;   &lt;span class=&quot;comment&quot;&gt;// @2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        container = collector.supplier().get();                                                                 &lt;span class=&quot;comment&quot;&gt;// @3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        BiConsumer&amp;lt;A, ? &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; P_OUT&amp;gt; accumulator = collector.accumulator();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        forEach(u -&amp;gt; accumulator.accept(container, u));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;                                                                                                     &lt;span class=&quot;comment&quot;&gt;// @4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        container = evaluate(ReduceOps.makeRef(collector));                                                                                              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)                    &lt;span class=&quot;comment&quot;&gt;// @5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           ? (R) container&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           : collector.finisher().apply(container);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码@1：函数声明，该方法返回的结果类型为R，传入的行为参数接口为Collector。&lt;br&gt;代码@2：判断是否符合并行化累积与规约的条件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否是并行流，例如上例中创建流的代码为menu.stream()，该方法的流是非并行化流，如果要支持并行化执行，需要满足的第一个条件就是需要使用menu.parallelStream()方法返回的流。&lt;/li&gt;
&lt;li&gt;Collector(收集器，行为化参数)中收集器行为集合中是否包含Characteristics.CONCURRENT(并行执行)，如果不包含该行为，则不支持并行执行。&lt;/li&gt;
&lt;li&gt;原始流是否有顺序 或 者 收集器的行为集合中明确包含Characteristics.UNORDERED(不要求顺序性)。&lt;br&gt;上述三个条件必须同时满足，才能并行执行，否则串行执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码@3：并行执行收集动作。&lt;/p&gt;
&lt;p&gt;代码@4：串行执行收集动作。&lt;/p&gt;
&lt;p&gt;代码@5：如果收集器收集行为集合中包含Characteristics.IDENTITY_FINISH，则直接返回原始值，否则使用Collector.finishier()方式对计算的值进行函数式计算。&lt;/p&gt;
&lt;p&gt;通过上面的代码，我们应该对Characteristics枚举类型中的3个值不难得出如下类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CONCURRENT&lt;br&gt;收集器行为，表示收集其中的累积函数是否支持并行执行。&lt;/li&gt;
&lt;li&gt;Characteristics.UNORDERED&lt;br&gt;收集器行为，表示整个收集期间，没有顺序要求。&lt;/li&gt;
&lt;li&gt;Characteristics.IDENTITY_FINISH&lt;br&gt;收集器行为，表示可以忽略Collector.finsher()定义的最终转换函数，直接返回累积之后的结果即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;疑问？代码@3,这段代码不是很好理解，该怎么继续往下深入呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;针对上面看不太懂的代码，我的处理办法是先转移思路，看一下Collector接口以及示例中Collectos.toList()返回的收集器是什么(重点关注返回的Collector中具体属性)。&lt;/p&gt;</summary>
    
    
    
    <category term="java8" scheme="http://example.com/categories/java8/"/>
    
    
    <category term="java8" scheme="http://example.com/tags/java8/"/>
    
    <category term="Lambda" scheme="http://example.com/tags/Lambda/"/>
    
    <category term="流计算" scheme="http://example.com/tags/%E6%B5%81%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>数值流、Stream创建与Optional类的使用</title>
    <link href="http://example.com/posts/fcb673e6.html"/>
    <id>http://example.com/posts/fcb673e6.html</id>
    <published>2020-12-09T14:32:35.000Z</published>
    <updated>2020-12-11T04:38:09.519Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="1、数值流"><a href="#1、数值流" class="headerlink" title="1、数值流"></a>1、数值流</h2><p>不知大家还记不得，在介绍函数式编程接口中为了避免基础数据类型的装箱/拆箱带来的性能损耗，特意为函数式接口引入了基础数据类型的函数式编程接口，例如IntPredicate、LongPredicate、DoublePredicate。同样，流API也考虑到基本数据类型的装箱/拆箱会带来性能损耗，引入了数值流，例如IntStream、LongStream、DoubleStream。</p><h3 id="1-1-原始数据特化流"><a href="#1-1-原始数据特化流" class="headerlink" title="1.1 原始数据特化流"></a>1.1 原始数据特化流</h3><p>java8中提供了3个原始数据特化流，分别为IntStream、LongStream、DoubleStream。本文将以IntStream进行讲解，其他流类似，只是数据类型分别代表Long或Double。</p><h4 id="1-1-1-映射到数据流"><a href="#1-1-1-映射到数据流" class="headerlink" title="1.1.1 映射到数据流"></a>1.1.1 映射到数据流</h4><p>首先我们还是从一个示例开始本节的学习：计算菜单中所有菜品的卡路里之和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_reduce_caluli</span><span class="params">(List&lt;Dish&gt; menu)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> calories = menu.stream()</span><br><span class="line">                    .map(Dish::getCalories)</span><br><span class="line">                    .reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">    System.out.println(<span class="string">&quot;菜品中的总卡路里：&quot;</span> + calories);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面包含了一个基本数据类型的装箱/拆箱动作，java8的流API提供了mapToInt方法，直接返回int类型的流</p><p>我们先稍微看一下mapToInt的方法声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IntStream <span class="title">mapToInt</span><span class="params">(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span></span><br></pre></td></tr></table></figure><p>接受一个T-&gt;int的函数式编程接口，直接返回IntStream流对象，而且IntStream本身提供了一些常用的聚合函数，例如sum。<br>使用IntStream来实现计算菜单中所有菜品的卡路里之和，其示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_reduce_caluli_intStream</span><span class="params">(List&lt;Dish&gt; menu)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> calories = menu.stream()</span><br><span class="line">            .mapToInt(Dish::getCalories)</span><br><span class="line">            .sum();</span><br><span class="line">    System.out.println(<span class="string">&quot;菜品中的总卡路里：&quot;</span> + calories);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-2-转换回对象流"><a href="#1-1-2-转换回对象流" class="headerlink" title="1.1.2 转换回对象流"></a>1.1.2 转换回对象流</h4><p>使用了特化流例如IntStream后，将不能再自动转换为其对应的封装对象流Stream&lt; T &gt;了，我们可以随意从IntStream对象中对应的通用方法的函数声明，例如IntStream#map函数的声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IntStream <span class="title">map</span><span class="params">(IntUnaryOperator mapper)</span></span>;</span><br></pre></td></tr></table></figure><p>只能接受int -&gt; int的函数式编程接口，如果想将IntStream转回到Stream&lt; Integer &gt;，该如何处理呢？</p><p>IntStream提供了boxed()方法来实现将基础数据类型转换回对应的包装类型的流。</p><h4 id="1-1-3-常用函数"><a href="#1-1-3-常用函数" class="headerlink" title="1.1.3 常用函数"></a>1.1.3 常用函数</h4><p>Stream中定义的方法，IntStream也可以使用，例如map、flatMap、distinict等，IntStream除这些之外，还提供了常用的聚合函数，例如sum、min、max、average(平均数)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OptionalDouble <span class="title">average</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">OptionalInt <span class="title">max</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">OptionalInt <span class="title">min</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>有关Optional相关的类将在下文详细介绍。</p><p>另外除了上面提到的聚合函数，IntStream还提供了两个与数值范围的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title">range</span><span class="params">(<span class="keyword">int</span> startInclusive, <span class="keyword">int</span> endExclusive)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title">rangeClosed</span><span class="params">(<span class="keyword">int</span> startInclusive, <span class="keyword">int</span> endExclusive)</span></span>;</span><br></pre></td></tr></table></figure><p>rangeClosed与range的区别就是rangeClosed包含结束边界，举一个简单示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_range</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = IntStream.range(<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">                        .filter( i -&gt; i % <span class="number">2</span> == <span class="number">0</span> )</span><br><span class="line">                         .count();</span><br><span class="line">    System.out.println(<span class="string">&quot;count:&quot;</span> + count);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算【1，100）中包含的偶数个数，将输出49。如果将range(1,100)修改为rangeClosed(1,100)，在输出的个数为50。</p><h2 id="2、构建流"><a href="#2、构建流" class="headerlink" title="2、构建流"></a>2、构建流</h2><h3 id="2-1-通过值构建流"><a href="#2-1-通过值构建流" class="headerlink" title="2.1 通过值构建流"></a>2.1 通过值构建流</h3><p>java 8的Stream提供了两个重载的of函数来显示的构建流，其声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span></span></span><br></pre></td></tr></table></figure><h3 id="2-2-通过数组构建流"><a href="#2-2-通过数组构建流" class="headerlink" title="2.2 通过数组构建流"></a>2.2 通过数组构建流</h3><p>通过Arrays.stream构建流，其声明如下：<br>Arrays#stream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">(T[] array)</span></span></span><br></pre></td></tr></table></figure><h3 id="2-3-通过文件流"><a href="#2-3-通过文件流" class="headerlink" title="2.3 通过文件流"></a>2.3 通过文件流</h3><p>可以通过文件流创建流，在java.nio.file.Files类中定义了如下创建流的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Path&gt; <span class="title">list</span><span class="params">(Path dir)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Path&gt; <span class="title">walk</span><span class="params">(Path start, <span class="keyword">int</span> maxDepth, FileVisitOption... options)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Path&gt; <span class="title">walk</span><span class="params">(Path start, FileVisitOption... options)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Path&gt; <span class="title">find</span><span class="params">(Path start, <span class="keyword">int</span> maxDepth,BiPredicate&lt;Path, BasicFileAttributes&gt; matcher,   </span></span></span><br><span class="line"><span class="function"><span class="params">    FileVisitOption... options)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;String&gt; <span class="title">lines</span><span class="params">(Path path, Charset cs)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;String&gt; <span class="title">lines</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><p>下面我们举一个示例：找出一个文件中不同词的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_file_stram</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> uniqueWords = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span>(Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">&quot;d:/tmp/words.txt&quot;</span>), Charset.defaultCharset())) &#123;  </span><br><span class="line">        uniqueWords = lines.flatMap(line -&gt; Arrays.stream(line.split(<span class="string">&quot;&quot;</span> )))</span><br><span class="line">                .distinct()</span><br><span class="line">                .count();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;不重复字符个数：&quot;</span> + uniqueWords);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-4-函数生成流：创建无限流"><a href="#2-4-函数生成流：创建无限流" class="headerlink" title="2.4 函数生成流：创建无限流"></a>2.4 函数生成流：创建无限流</h3><p>Stream API提供了两个静态方法从函数生成流：iterate、generate，我们先来看一下其函数声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">generate</span><span class="params">(Supplier&lt;T&gt; s)</span></span></span><br></pre></td></tr></table></figure><h4 id="2-4-1-iterate"><a href="#2-4-1-iterate" class="headerlink" title="2.4.1 iterate"></a>2.4.1 iterate</h4><p>iterate方法的第一个参数类型为T，表示其初始值，第二个参数如下：<br><img src="https://img-blog.csdnimg.cn/20190602202005106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>即其函数式声明为为T-T。其示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_iterate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream.iterate(<span class="number">0</span>, a -&gt; a + <span class="number">2</span>)</span><br><span class="line">            .limit(<span class="number">10</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：由于是无限流，故千万记得使用limit截断流，否则会无限循环下去。</p></blockquote><h4 id="2-4-2-generate"><a href="#2-4-2-generate" class="headerlink" title="2.4.2 generate"></a>2.4.2 generate</h4><p>其参数为Supplier&lt; T &gt;，其定义如下：<br><img src="https://img-blog.csdnimg.cn/20190602202222354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>即构造一个T类型的对象，举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_iterate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream.iterate(<span class="number">0</span>, a -&gt; a + <span class="number">2</span>)</span><br><span class="line">            .limit(<span class="number">10</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-集合对象的stream"><a href="#2-5-集合对象的stream" class="headerlink" title="2.5 集合对象的stream"></a>2.5 集合对象的stream</h3><p>这个在前面的示例中用的最多，就不做过多介绍。</p><h2 id="3、Optional类"><a href="#3、Optional类" class="headerlink" title="3、Optional类"></a>3、Optional类</h2><p>为了更优雅的处理null值，避免空指针错误，java8中引入Optional类。<br><img src="https://img-blog.csdnimg.cn/20190602202332539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来对这些方法一一做个介绍。</p><ul><li>public static&lt; T&gt; Optional&lt; T&gt; empty()<br>创建一个Optional对象，其内部持有的对象为null。</li><li>public static &lt; T &gt; Optional&lt; T &gt; of(T value)<br>使用value的值，创建一个Optional对象。</li><li>public static &lt; T &gt; Optional&lt; T &gt; ofNullable(T value)<br>使用v去创建一个Optional对象，如果value为null，则返回empty()。</li><li>public T get()<br>从Optional对象获取内嵌的对象，如果为空，则抛出NoSuchElementException。</li><li>public boolean isPresent()<br>判断Optional对象中包含的值是否存在。</li><li>public void ifPresent(Consumer<? super T> consumer)如果Optional包裹的对象存在，则消费该对象。Consumer<?>的函数式编程接口：T -&gt; void。</li><li>public Optional&lt; T &gt; filter(Predicate&lt;? super T&gt; predicate)<br>如果Optional中包裹的对象为空，则返回自身，否则如果包裹的对象满足predicate表达式，则返回自身，否则返回empty()。</li><li>public&lt; U &gt; Optional&lt; U &gt; map(Function&lt;? super T, ? extends U&gt; mapper)<br>如果Optional对象中包裹的对象为空，则返回empty()，否则运用(T-U)，包裹U,当然如果U为空，则返回empty()。</li><li>public&lt; U &gt; Optional&lt; U &gt; flatMap(Function&lt;? super T, Optional&lt; U &gt;&gt; mapper)<br>如果Option对象中包裹的对象为空，则返回empty()，否则使用对Optional中的包裹的对象value应用Function，最终返回Optional对象。</li><li>public T orElse(T other)<br>返回Optional中包裹的对象，如果其值为空，则返回other。</li><li>public T orElseGet(Supplier&lt;? extends T&gt; other)<br>返回Optional中包裹的对象，如果其值为空，则返回 Supplier函数式编辑接口中创建的值。</li><li>public &lt; X extends Throwable&gt; T orElseThrow(Supplier&lt; ? extends X&gt; exceptionSupplier) throws X<br>返回Optional中包裹的对象，如果其值为空，则抛出自定义一次，由Supplier函数式编程接口返回。</li></ul><p> 其示例代码如下：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_option</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Optional&lt;String&gt; value = Optional.ofNullable(data.get(<span class="string">&quot;userName&quot;</span>));</span><br><span class="line">    <span class="comment">// 如果存在userName值，则输出</span></span><br><span class="line">    value.ifPresent(System.out::println);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>本文就介绍到这里了，本文详细介绍了java8中的数值流、Stream的创建以及java8中Optional类的使用。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1、数值流&quot;&gt;&lt;a href=&quot;#1、数值流&quot; class=&quot;headerlink&quot; title=&quot;1、数值流&quot;&gt;&lt;/a&gt;1、数值流&lt;/h2&gt;&lt;p&gt;不知大家还记不得，在介绍函数式编程接口中为了避免基础数据类型的装箱/拆箱带来的性能损耗，特意为函数式接口引入了基础数据类型的函数式编程接口，例如IntPredicate、LongPredicate、DoublePredicate。同样，流API也考虑到基本数据类型的装箱/拆箱会带来性能损耗，引入了数值流，例如IntStream、LongStream、DoubleStream。&lt;/p&gt;
&lt;h3 id=&quot;1-1-原始数据特化流&quot;&gt;&lt;a href=&quot;#1-1-原始数据特化流&quot; class=&quot;headerlink&quot; title=&quot;1.1 原始数据特化流&quot;&gt;&lt;/a&gt;1.1 原始数据特化流&lt;/h3&gt;&lt;p&gt;java8中提供了3个原始数据特化流，分别为IntStream、LongStream、DoubleStream。本文将以IntStream进行讲解，其他流类似，只是数据类型分别代表Long或Double。&lt;/p&gt;
&lt;h4 id=&quot;1-1-1-映射到数据流&quot;&gt;&lt;a href=&quot;#1-1-1-映射到数据流&quot; class=&quot;headerlink&quot; title=&quot;1.1.1 映射到数据流&quot;&gt;&lt;/a&gt;1.1.1 映射到数据流&lt;/h4&gt;&lt;p&gt;首先我们还是从一个示例开始本节的学习：计算菜单中所有菜品的卡路里之和。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test_reduce_caluli&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(List&amp;lt;Dish&amp;gt; menu)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; calories = menu.stream()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    .map(Dish::getCalories)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    .reduce(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, Integer::sum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;菜品中的总卡路里：&amp;quot;&lt;/span&gt; + calories);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面包含了一个基本数据类型的装箱/拆箱动作，java8的流API提供了mapToInt方法，直接返回int类型的流&lt;/p&gt;
&lt;p&gt;我们先稍微看一下mapToInt的方法声明：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;IntStream &lt;span class=&quot;title&quot;&gt;mapToInt&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ToIntFunction&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; T&amp;gt; mapper)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接受一个T-&amp;gt;int的函数式编程接口，直接返回IntStream流对象，而且IntStream本身提供了一些常用的聚合函数，例如sum。&lt;br&gt;使用IntStream来实现计算菜单中所有菜品的卡路里之和，其示例如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test_reduce_caluli_intStream&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(List&amp;lt;Dish&amp;gt; menu)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; calories = menu.stream()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .mapToInt(Dish::getCalories)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .sum();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;菜品中的总卡路里：&amp;quot;&lt;/span&gt; + calories);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;1-1-2-转换回对象流&quot;&gt;&lt;a href=&quot;#1-1-2-转换回对象流&quot; class=&quot;headerlink&quot; title=&quot;1.1.2 转换回对象流&quot;&gt;&lt;/a&gt;1.1.2 转换回对象流&lt;/h4&gt;&lt;p&gt;使用了特化流例如IntStream后，将不能再自动转换为其对应的封装对象流Stream&amp;lt; T &amp;gt;了，我们可以随意从IntStream对象中对应的通用方法的函数声明，例如IntStream#map函数的声明如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;IntStream &lt;span class=&quot;title&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(IntUnaryOperator mapper)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;只能接受int -&amp;gt; int的函数式编程接口，如果想将IntStream转回到Stream&amp;lt; Integer &amp;gt;，该如何处理呢？&lt;/p&gt;
&lt;p&gt;IntStream提供了boxed()方法来实现将基础数据类型转换回对应的包装类型的流。&lt;/p&gt;
&lt;h4 id=&quot;1-1-3-常用函数&quot;&gt;&lt;a href=&quot;#1-1-3-常用函数&quot; class=&quot;headerlink&quot; title=&quot;1.1.3 常用函数&quot;&gt;&lt;/a&gt;1.1.3 常用函数&lt;/h4&gt;&lt;p&gt;Stream中定义的方法，IntStream也可以使用，例如map、flatMap、distinict等，IntStream除这些之外，还提供了常用的聚合函数，例如sum、min、max、average(平均数)。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;OptionalDouble &lt;span class=&quot;title&quot;&gt;average&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;OptionalInt &lt;span class=&quot;title&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;OptionalInt &lt;span class=&quot;title&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有关Optional相关的类将在下文详细介绍。&lt;/p&gt;
&lt;p&gt;另外除了上面提到的聚合函数，IntStream还提供了两个与数值范围的方法：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; IntStream &lt;span class=&quot;title&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; startInclusive, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; endExclusive)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; IntStream &lt;span class=&quot;title&quot;&gt;rangeClosed&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; startInclusive, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; endExclusive)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;rangeClosed与range的区别就是rangeClosed包含结束边界，举一个简单示例如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test_range&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; count = IntStream.range(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        .filter( i -&amp;gt; i % &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                         .count();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;count:&amp;quot;&lt;/span&gt; + count);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;计算【1，100）中包含的偶数个数，将输出49。如果将range(1,100)修改为rangeClosed(1,100)，在输出的个数为50。&lt;/p&gt;
&lt;h2 id=&quot;2、构建流&quot;&gt;&lt;a href=&quot;#2、构建流&quot; class=&quot;headerlink&quot; title=&quot;2、构建流&quot;&gt;&lt;/a&gt;2、构建流&lt;/h2&gt;&lt;h3 id=&quot;2-1-通过值构建流&quot;&gt;&lt;a href=&quot;#2-1-通过值构建流&quot; class=&quot;headerlink&quot; title=&quot;2.1 通过值构建流&quot;&gt;&lt;/a&gt;2.1 通过值构建流&lt;/h3&gt;&lt;p&gt;java 8的Stream提供了两个重载的of函数来显示的构建流，其声明如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt;&amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; &lt;span class=&quot;title&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T t)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt;&amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; &lt;span class=&quot;title&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T... values)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;2-2-通过数组构建流&quot;&gt;&lt;a href=&quot;#2-2-通过数组构建流&quot; class=&quot;headerlink&quot; title=&quot;2.2 通过数组构建流&quot;&gt;&lt;/a&gt;2.2 通过数组构建流&lt;/h3&gt;&lt;p&gt;通过Arrays.stream构建流，其声明如下：&lt;br&gt;Arrays#stream&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;Stream&amp;lt;T&amp;gt; &lt;span class=&quot;title&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T[] array)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;2-3-通过文件流&quot;&gt;&lt;a href=&quot;#2-3-通过文件流&quot; class=&quot;headerlink&quot; title=&quot;2.3 通过文件流&quot;&gt;&lt;/a&gt;2.3 通过文件流&lt;/h3&gt;&lt;p&gt;可以通过文件流创建流，在java.nio.file.Files类中定义了如下创建流的方法。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Stream&amp;lt;Path&amp;gt; &lt;span class=&quot;title&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Path dir)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Stream&amp;lt;Path&amp;gt; &lt;span class=&quot;title&quot;&gt;walk&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Path start, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxDepth, FileVisitOption... options)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Stream&amp;lt;Path&amp;gt; &lt;span class=&quot;title&quot;&gt;walk&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Path start, FileVisitOption... options)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Stream&amp;lt;Path&amp;gt; &lt;span class=&quot;title&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Path start, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxDepth,BiPredicate&amp;lt;Path, BasicFileAttributes&amp;gt; matcher,   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;    FileVisitOption... options)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Stream&amp;lt;String&amp;gt; &lt;span class=&quot;title&quot;&gt;lines&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Path path, Charset cs)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Stream&amp;lt;String&amp;gt; &lt;span class=&quot;title&quot;&gt;lines&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Path path)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面我们举一个示例：找出一个文件中不同词的个数。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test_file_stram&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; uniqueWords = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;(Stream&amp;lt;String&amp;gt; lines = Files.lines(Paths.get(&lt;span class=&quot;string&quot;&gt;&amp;quot;d:/tmp/words.txt&amp;quot;&lt;/span&gt;), Charset.defaultCharset())) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        uniqueWords = lines.flatMap(line -&amp;gt; Arrays.stream(line.split(&lt;span class=&quot;string&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt; )))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .distinct()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .count();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;不重复字符个数：&amp;quot;&lt;/span&gt; + uniqueWords);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (IOException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="java8" scheme="http://example.com/categories/java8/"/>
    
    
    <category term="java8" scheme="http://example.com/tags/java8/"/>
    
    <category term="Lambda" scheme="http://example.com/tags/Lambda/"/>
    
    <category term="流计算" scheme="http://example.com/tags/%E6%B5%81%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
</feed>
