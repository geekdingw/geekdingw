<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>初识Stream、流的基本操作（流计算） | 中间件兴趣圈</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文中的部分示例基于如下场景：餐厅点菜，Dish为餐厅中可提供的菜品，Dish的定义如下： 123456789101112131415161718192021public class Dish &amp;#123;    &#x2F;** 菜品名称 *&#x2F;	private final String name;	&#x2F;** 是否是素食 *&#x2F;	private final boolean">
<meta property="og:type" content="article">
<meta property="og:title" content="初识Stream、流的基本操作（流计算）">
<meta property="og:url" content="http://example.com/2020/12/09/%E5%88%9D%E8%AF%86Stream%E3%80%81%E6%B5%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E6%B5%81%E8%AE%A1%E7%AE%97%EF%BC%89/index.html">
<meta property="og:site_name" content="中间件兴趣圈">
<meta property="og:description" content="本文中的部分示例基于如下场景：餐厅点菜，Dish为餐厅中可提供的菜品，Dish的定义如下： 123456789101112131415161718192021public class Dish &amp;#123;    &#x2F;** 菜品名称 *&#x2F;	private final String name;	&#x2F;** 是否是素食 *&#x2F;	private final boolean">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190518134242508.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190518134853228.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190518134944653.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190518135118267.png">
<meta property="article:published_time" content="2020-12-09T14:32:35.000Z">
<meta property="article:modified_time" content="2020-12-09T14:35:17.541Z">
<meta property="article:author" content="中间件兴趣圈">
<meta property="article:tag" content="java8 Lambda 流计算">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190518134242508.png">
  
    <link rel="alternate" href="/atom.xml" title="中间件兴趣圈" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">中间件兴趣圈</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-初识Stream、流的基本操作（流计算）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/09/%E5%88%9D%E8%AF%86Stream%E3%80%81%E6%B5%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E6%B5%81%E8%AE%A1%E7%AE%97%EF%BC%89/" class="article-date">
  <time datetime="2020-12-09T14:32:35.000Z" itemprop="datePublished">2020-12-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java8/">java8</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      初识Stream、流的基本操作（流计算）
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div id="vip-container"><p>本文中的部分示例基于如下场景：餐厅点菜，Dish为餐厅中可提供的菜品，Dish的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Dish &#123;</span><br><span class="line">    &#x2F;** 菜品名称 *&#x2F;</span><br><span class="line">	private final String name;</span><br><span class="line">	&#x2F;** 是否是素食 *&#x2F;</span><br><span class="line">	private final boolean vegetarian;</span><br><span class="line">	&#x2F;** 含卡路里 *&#x2F;</span><br><span class="line">	private final int calories;</span><br><span class="line">	&#x2F;** 类型 *&#x2F;</span><br><span class="line">	private final Type type;</span><br><span class="line">	</span><br><span class="line">	public Dish(String name, boolean vegetarian, int calories, Type type) &#123;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">		this.vegetarian &#x3D; vegetarian;</span><br><span class="line">		this.calories &#x3D; calories;</span><br><span class="line">		this.type &#x3D; type;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public enum Type &#123; MEAT, FISH, OTHER &#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 省略set get方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>菜单的数据如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dish&gt; menu &#x3D; Arrays.asList(</span><br><span class="line">new Dish(&quot;pork&quot;, false, 800, Dish.Type.MEAT),</span><br><span class="line">new Dish(&quot;beef&quot;, false, 700, Dish.Type.MEAT),</span><br><span class="line">new Dish(&quot;chicken&quot;, false, 400, Dish.Type.MEAT),</span><br><span class="line">new Dish(&quot;french fries&quot;, true, 530, Dish.Type.OTHER),</span><br><span class="line">new Dish(&quot;rice&quot;, true, 350, Dish.Type.OTHER),</span><br><span class="line">new Dish(&quot;season fruit&quot;, true, 120, Dish.Type.OTHER),</span><br><span class="line">new Dish(&quot;pizza&quot;, true, 550, Dish.Type.OTHER),</span><br><span class="line">new Dish(&quot;prawns&quot;, false, 300, Dish.Type.FISH),</span><br><span class="line">new Dish(&quot;salmon&quot;, false, 450, Dish.Type.FISH) );</span><br></pre></td></tr></table></figure>
<p>我们以一个简单的示例来引入流：从菜单列表中，查找出是素食的菜品，并打印其菜品的名称。</p>
<p>在Java8之前，我们通常是这样实现该需求的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; dishNames &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">for(Dish d menu) &#123;</span><br><span class="line">    if(d.isVegetarian()) &#123;</span><br><span class="line">        dishNames.add(d.getName()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出帅选出来的菜品的名称：</span><br><span class="line">for(String n : dishNames) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那在java8中，我们可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">menu.streams() .filter( Dish::isVegetarian).map( Dish::getName) .forEach( a -&gt; System.out.println(a) );</span><br></pre></td></tr></table></figure>
<p>其运行输出的结果：<br><img src="https://img-blog.csdnimg.cn/20190518134242508.png" alt="在这里插入图片描述"><br>怎么样，神奇吧！！！</p>
<p>在解释上面的代码之前，我们先对流做一个理论上的介绍。</p>
<h2 id="1、流是什么？"><a href="#1、流是什么？" class="headerlink" title="1、流是什么？"></a>1、流是什么？</h2><p>流，就是数据流，是元素序列，在Java8中，流的接口定义在 java.util.stream.Stream包中，并且在Collection(集合)接口中新增一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">default Stream&lt;E&gt; stream() &#123;</span><br><span class="line">        return StreamSupport.stream(spliterator(), false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流的简短定义：从支持数据处理操作的源生成的元素序列。例如集合、数组都是支持数据操作的数据结构（容器），都可以做为流的创建源，该定义的核心要素如下：</p>
<ul>
<li>源<br>流是从一个源创建来而来，而且这个源是支持数据处理的，例如集合、数组等。</li>
<li>元素序列<br>流代表一个元素序列（流水线），因为是从根据一个数据处理源而创建得来的。</li>
<li>数据处理操作<br>流的侧重点并不在数据存储，而在于数据处理，例如示例中的filter、map、forEach等。</li>
<li>迭代方式<br>流的迭代方式为内部迭代，而集合的迭代方式为外部迭代。例如我们遍历Collection接口需要用户去做迭代，例如for-each，然后在循环体中写对应的处理代码，这叫外部迭代。相反，Stream库使用内部迭代，我们只需要对流传入对应的函数即可，表示要做什么就行。</li>
</ul>
<blockquote>
<p>注意：流和迭代器Iterator一样，只能遍历一次，如果要多次遍历，请创建多个流。</p>
</blockquote>
<p>接下来我们将重点先介绍流的常用操作方法。</p>
<h2 id="2、常用的流操作方法"><a href="#2、常用的流操作方法" class="headerlink" title="2、常用的流操作方法"></a>2、常用的流操作方法</h2><h4 id="2-1-filter"><a href="#2-1-filter" class="headerlink" title="2.1 filter"></a>2.1 filter</h4><p>filter函数的方法声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.stream.Stream#filter</span><br><span class="line">Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</span><br></pre></td></tr></table></figure>
<p>该方法接收一个谓词，返回一个流，即filter方法接收的lambda表达式需要满足 （  T  -&gt; Boolean ）。</p>
<p>示例：从菜单中选出所有是素食的菜品：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dish&gt; vegetarianDishs &#x3D; menu.stream().filter(  Dish::isVegetarian )    &#x2F;&#x2F; 使用filter过滤流中的菜品。</span><br><span class="line">                                          .collect(toList())；              &#x2F;&#x2F; 将流转换成List，该方法将在后面介绍。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>温馨提示：流的操作可以分成中间件操作和终端操作。中间操作通常的返回结果还是流，并且在调用终端操作之前，并不会立即调用，等终端方法调用后，中间操作才会真正触发执行，该示例中的collect方法为终端方法。</p>
</blockquote>
<p>我们类比一下数据库查询操作，除了基本的筛选动作外，还有去重，分页等功能，那java8的流API能支持这些操作吗？<br>答案当然是肯定。</p>
<h4 id="2-1-1-distinct"><a href="#2-1-1-distinct" class="headerlink" title="2.1.1 distinct"></a>2.1.1 distinct</h4><p>distinct，类似于数据库中的排重函数，就是对结果集去重。<br>例如有一个数值numArr = [1,5,8,6,5,2,6]，现在要输出该数值中的所有奇数并且不能重复输出，那该如何实现呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(numArr).filter(  a -&gt; a % 2 &#x3D;&#x3D; 0 ).distinict().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h4 id="2-1-2-limit"><a href="#2-1-2-limit" class="headerlink" title="2.1.2 limit"></a>2.1.2 limit</h4><p>截断流，返回一个i不超过指定元素个数的流。<br>还是以上例举例，如果要输出的元素是偶数，不能重复输出，并且只输出1个元素，那又该如何实现呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(numArr).filter(  a -&gt; a % 2 &#x3D;&#x3D; 0 ).distinict().limit(1).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h4 id="2-1-3-skip"><a href="#2-1-3-skip" class="headerlink" title="2.1.3 skip"></a>2.1.3 skip</h4><p>跳过指定元素，返回剩余元素的流，与limit互补。</p>
<a id="more"></a>

<h4 id="2-2-Map"><a href="#2-2-Map" class="headerlink" title="2.2 Map"></a>2.2 Map</h4><p>还是类比数据库操作，我们通常可以只选择一个表中的某一列，java8流操作也提供了类似的方法。<br>例如，我们需要从菜单中提取所有菜品的名称，在java8中我们可以使用如下代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">版本1：List&lt;String&gt; dishNames &#x3D; menu.stream().map( (Dish d) -&gt; d.getName() ).collect(Collectors.toList());</span><br><span class="line">版本2：List&lt;String&gt; dishNames &#x3D; menu.stream().map( d -&gt; d.getName() ).collect(Collectors.toList());</span><br><span class="line">版本3：List&lt;String&gt; dishNames &#x3D; menu.stream().map(Dish::getName).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>文章的后续部分尽量使用最简洁的lambda表达式。</p>
</blockquote>
<p>我们来看一下Stream关于map方法的声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</span><br></pre></td></tr></table></figure>
<p>接受一个函数Function，其函数声明为：T -&gt; R，接收一个T类型的对象，返回一个R类型的对象。</p>
<p>当然，java为了高效的处理基础数据类型（避免装箱、拆箱带来性能损耗）也定义了如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper)</span><br><span class="line">LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper)</span><br><span class="line">DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper)</span><br></pre></td></tr></table></figure>

<p>思考题：对于字符数值[“Hello”,”World”] ，输出字符序列，并且去重。<br>第一次尝试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void test_flat_map() &#123;</span><br><span class="line">    String[] strArr &#x3D; new String[] &#123;&quot;hello&quot;, &quot;world&quot;&#125;;</span><br><span class="line">    List&lt;String&gt; strList &#x3D; Arrays.asList(strArr);</span><br><span class="line">    strList.stream().map( s -&gt; s.split(&quot;&quot;))</span><br><span class="line">                    .distinct().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：<br><img src="https://img-blog.csdnimg.cn/20190518134853228.png" alt="在这里插入图片描述"><br>为什么会返回两个String[]元素呢？因为map(s -&gt; s.split()) 此时返回的流为Stream&lt;String[]&gt;，那我们是不是可以继续对该Steam[String[]],把String[]转换为字符流，其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void test_flat_map() &#123;</span><br><span class="line">    String[] strArr &#x3D; new String[] &#123;&quot;hello&quot;, &quot;world&quot;&#125;;</span><br><span class="line">    List&lt;String&gt; strList &#x3D; Arrays.asList(strArr);</span><br><span class="line">    strList.stream().map( s -&gt; s.split(&quot;&quot;))</span><br><span class="line">                    .map(Arrays::stream)</span><br><span class="line">                    .distinct().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其返回结果：<br><img src="https://img-blog.csdnimg.cn/20190518134944653.png" alt="在这里插入图片描述"><br>还是不符合预期，其实原因也很好理解，再次经过map(Arrays:stream)后，返回的结果为 Stream&lt;Stream&lt; String&gt;&gt;，即包含两个元素，每一个元素为一个字符流，可以通过如下代码验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void test_flat_map() &#123;</span><br><span class="line">    String[] strArr &#x3D; new String[] &#123;&quot;hello&quot;, &quot;world&quot;&#125;;</span><br><span class="line">    List&lt;String&gt; strList &#x3D; Arrays.asList(strArr);</span><br><span class="line">    strList.stream().map( s -&gt; s.split(&quot;&quot;))</span><br><span class="line">                    .map(Arrays::stream)</span><br><span class="line">                    .forEach(  (Stream&lt;String&gt; s) -&gt; &#123;</span><br><span class="line">                        System.out.println(&quot;\n --start---&quot;);</span><br><span class="line">                        s.forEach(a -&gt; System.out.print(a + &quot; &quot;));</span><br><span class="line">                        System.out.println(&quot;\n --end---&quot;);</span><br><span class="line">                    &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综合上述分析，之所以不符合预期，主要是原数组中的两个字符，经过map后返回的是两个独立的流，那有什么方法将这两个流合并成一个流，然后再进行disinic去重呢？</p>
<p>答案当然是可以的，flatMap方法闪亮登场：先看代码和显示结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void test_flat_map() &#123;</span><br><span class="line">    String[] strArr &#x3D; new String[] &#123;&quot;hello&quot;, &quot;world&quot;&#125;;</span><br><span class="line">    List&lt;String&gt; strList &#x3D; Arrays.asList(strArr);</span><br><span class="line">    strList.stream().map( s -&gt; s.split(&quot;&quot;))</span><br><span class="line">                    .flatMap(Arrays::stream)</span><br><span class="line">                    .distinct().forEach( a -&gt; System.out.print(a +&quot; &quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其输出结果：<br><img src="https://img-blog.csdnimg.cn/20190518135118267.png" alt="在这里插入图片描述"><br>符合预期。一言以蔽之，flatMap可以把两个流合并成一个流进行操作。</p>
<h4 id="2-3-查找和匹配"><a href="#2-3-查找和匹配" class="headerlink" title="2.3 查找和匹配"></a>2.3 查找和匹配</h4><p>Stream API提供了allMatch、anyMatch、noneMatch、findFirst和findAny方法来实现对流中数据的匹配与查找。</p>
<h5 id="2-3-1-allMatch"><a href="#2-3-1-allMatch" class="headerlink" title="2.3.1 allMatch"></a>2.3.1 allMatch</h5><p>我们先看一下该方法的声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean allMatch(Predicate&lt;? super T&gt; predicate);</span><br></pre></td></tr></table></figure>
<p>接收一个谓词函数(T-&gt;boolean)，返回一个boolean值，是一个终端操作，用于判断流中的所有元素是否与Predicate相匹配，只要其中一个元素不复合，该表达式将返回false。<br>示例如下：例如存在这样一个List a,其中元素为 1,2,4,6,8。判断流中的元素是否都是偶数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean result &#x3D; a.stream().allMatch(  a -&gt; a % 2 &#x3D;&#x3D; 0 )；  &#x2F;&#x2F; 将返回false。</span><br></pre></td></tr></table></figure>

<h5 id="2-3-2-anyMatch"><a href="#2-3-2-anyMatch" class="headerlink" title="2.3.2 anyMatch"></a>2.3.2 anyMatch</h5><p>该方法的函数声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean anyMatch(Predicate&lt;? super T&gt; predicate)</span><br></pre></td></tr></table></figure>
<p>同样接收一个谓词Predicate( T -&gt; boolean )，表示只要流中的元素至少一个匹配谓词，即返回真。</p>
<p>示例如下：例如存在这样一个List a,其中元素为 1,2,4,6,8。判断流中的元素是否包含偶数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean result &#x3D; a.stream().anyMatch(  a -&gt; a % 2 &#x3D;&#x3D; 0 )；  &#x2F;&#x2F; 将返回true。</span><br></pre></td></tr></table></figure>

<h5 id="2-3-3-noneMatch"><a href="#2-3-3-noneMatch" class="headerlink" title="2.3.3 noneMatch"></a>2.3.3 noneMatch</h5><p>该方法的函数声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean noneMatch(Predicate&lt;? super T&gt; predicate);</span><br></pre></td></tr></table></figure>
<p>同样接收一个谓词Predicate( T -&gt; boolean )，表示只要流中的元素全部不匹配谓词表达式，则返回true。</p>
<p>示例如下：例如存在这样一个List a,其中元素为 2,4,6,8。判断流中的所有元素都不式奇数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean result &#x3D; a.stream().noneMatch(  a -&gt; a % 2 &#x3D;&#x3D; 1 )；  &#x2F;&#x2F; 将返回true。</span><br></pre></td></tr></table></figure>

<h5 id="2-3-4-findFirst"><a href="#2-3-4-findFirst" class="headerlink" title="2.3.4 findFirst"></a>2.3.4 findFirst</h5><p>查找流中的一个元素，其函数声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; findFirst();</span><br></pre></td></tr></table></figure>
<p>返回流中的一个元素。其返回值为Optional<T>，这是jdk8中引入的一个类，俗称值容器类，其主要左右是用来避免值空指针，一种更加优雅的方式来处理null。该类的具体使用将在下一篇详细介绍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void test_find_first(List&lt;Dish&gt; menu) &#123;</span><br><span class="line">    Optional&lt;Dish&gt; dish &#x3D; menu.stream().findFirst();</span><br><span class="line">    &#x2F;&#x2F; 这个方法表示，Optional中包含Dish对象，则执行里面的代码，否则什么事不干，是不是比判断是否为null更友好</span><br><span class="line">    dish.ifPresent(a -&gt; System.out.println(a.getName()));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-5-findAny"><a href="#2-3-5-findAny" class="headerlink" title="2.3.5 findAny"></a>2.3.5 findAny</h5><p>返回流中任意一个元素，其函数声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; findAny();</span><br></pre></td></tr></table></figure>
<h4 id="2-4-reduce"><a href="#2-4-reduce" class="headerlink" title="2.4 reduce"></a>2.4 reduce</h4><p>reduce归约，看过大数据的人用过会非常敏感，目前的java8的流操作是不是有点map-reduce的味道，归约，就是对流中所有的元素进行统计分析，归约成一个数值。<br>首先我们看一下reduce的函数说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</span><br></pre></td></tr></table></figure>
<ul>
<li>T identity：累积器的初始值。</li>
<li>BinaryOperator&lt; T&gt; accumulator：累积函数。BinaryOperator&lt; T&gt; extend BiFunction&lt;T, U, R&gt;。BinaryOperator<T>的函数式表示，接受两个T类型的入参，返回T类型的返回值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);</span><br></pre></td></tr></table></figure>
可以理解为没有初始值的归约，如果流为空，则会返回空，故其返回值使用了Optional类来优雅处理null值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner);</span><br></pre></td></tr></table></figure>
<p>首先，最后的返回值类型为U。</p>
<ul>
<li>U identity：累积函数的初始值。</li>
<li>BiFunction&lt;U, ? super T, U&gt; accumulator：累积器函数，对流中的元素使用该累积器进行归约，在具体执行时accumulator.apply(  identity,  第二个参数的类型不做限制 )，只要最终返回U即可。</li>
<li>BinaryOperator&lt; U&gt; combiner：组合器。对累积器的结果进行组合，因为归约reduce，java流计算内部使用了fork-join框架，会对流的中的元素使用并行累积，每个线程处理流中一部分数据，最后对结果进行组合，得出最终的值。</li>
</ul>
<blockquote>
<p>温馨提示：对流API的学习，一个最最重点的就是要掌握这些函数式编程接口，然后掌握如何使用Lambda表达式进行行为参数化（lambda表达当成参数传入到函数中）。</p>
</blockquote>
<p>接下来我们举例来展示如何使用reduce。<br>示例1：对集合中的元素求和</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; goodsNumber &#x3D; Arrays.asList(   3, 5, 8, 4, 2, 13 );</span><br><span class="line">java7之前的示例：</span><br><span class="line">int sum &#x3D; 0;</span><br><span class="line">for(Integer i : goodsNumber) &#123;</span><br><span class="line">sum +&#x3D; i;&#x2F;&#x2F;  sum &#x3D; sum + i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;sum:&quot; + sum);</span><br></pre></td></tr></table></figure>
<p>求和运算符： c = a + b，也就是接受2个参数，返回一个值，并且这三个值的类型一致。</p>
<p>故我们可以使用T reduce(T identity, BinaryOperator&lt; T&gt; accumulator)来实现我们的需求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void test_reduce() &#123;</span><br><span class="line">    List&lt;Integer&gt; goodsNumber &#x3D; Arrays.asList(   3, 5, 8, 4, 2, 13 );</span><br><span class="line">    int sum &#x3D; goodsNumber.stream().reduce(0, (a,b) -&gt; a + b);</span><br><span class="line">    &#x2F;&#x2F;这里也可以写成这样：</span><br><span class="line">    &#x2F;&#x2F; int sum &#x3D; goodsNumber.stream().reduce(0, Integer::sum);</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不知大家是否只读(a,b)这两个参数的来源，其实第一个参数为初始值T identity，第二个参数为流中的元素。</p>
<p>那三个参数的reduce函数主要用在什么场景下呢？接下来还是用求和的例子来展示其使用场景。在java多线程编程模型中，引入了fork-join框架，就是对一个大的任务进行先拆解，用多线程分别并行执行，最终再两两进行合并，得出最终的结果。reduce函数的第三个函数，就是组合这个动作，下面给出并行执行的流式处理示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> public static void test_reduce_combiner() &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 初始化待操作的流 *&#x2F;</span><br><span class="line">    List&lt;Integer&gt; nums &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    int s &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; 200; i ++) &#123;</span><br><span class="line">        nums.add(i);</span><br><span class="line">        s &#x3D; s + i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对流进行归并，求和,这里使用了流的并行执行版本 parallelStream，内部使用Fork-Join框架多线程并行执行，</span><br><span class="line">    &#x2F;&#x2F; 关于流的内部高级特性，后续再进行深入，目前先以掌握其用法为主。</span><br><span class="line">    int sum2 &#x3D; nums.parallelStream().reduce(0,Integer::sum, Integer::sum);</span><br><span class="line">    System.out.println(&quot;和为：&quot; + sum2);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 下面给出上述版本的debug版本。</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 累积器执行的次数</span><br><span class="line">    AtomicInteger accumulatorCount &#x3D; new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 组合器执行的次数（其实就是内部并行度）</span><br><span class="line">    AtomicInteger combinerCount &#x3D; new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    int sum &#x3D; nums.parallelStream().reduce(0,(a,b) -&gt; &#123;</span><br><span class="line">                accumulatorCount.incrementAndGet();</span><br><span class="line">                return a + b;</span><br><span class="line">           &#125;, (c,d) -&gt; &#123;</span><br><span class="line">                combinerCount.incrementAndGet();</span><br><span class="line">                return  c+d;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;accumulatorCount:&quot; + accumulatorCount.get());</span><br><span class="line">    System.out.println(&quot;combinerCountCount:&quot; + combinerCount.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从结果上可以看出，执行了100次累积动作，但只进行了15次合并。</p>
<p>流的基本操作就介绍到这里，在此总结一下，目前接触到的流操作：<br>1、filter</p>
<ul>
<li>函数功能：过滤</li>
<li>操作类型：中间操作</li>
<li>返回类型：Stream<T></li>
<li>函数式接口：Predicate<T></li>
<li>函数描述符：T -&gt; boolean</li>
</ul>
<p>2、distinct</p>
<ul>
<li>函数功能：去重</li>
<li>操作类型：中间操作</li>
<li>返回类型：Stream<T></li>
</ul>
<p>3、skip</p>
<ul>
<li>函数功能：跳过n个元素</li>
<li>操作类型：中间操作</li>
<li>返回类型：Stream<T></li>
<li>接受参数：long</li>
</ul>
<p>4、limit</p>
<ul>
<li>函数功能：截断流，值返回前n个元素的流</li>
<li>操作类型：中间操作</li>
<li>返回类型：Stream<T></li>
<li>接受参数：long</li>
</ul>
<p>5、map</p>
<ul>
<li>函数功能：映射</li>
<li>操作类型：中间操作</li>
<li>返回类型：Stream<R></li>
<li>函数式接口：Function&lt;T,R&gt;</li>
<li>函数描述符：T -&gt; R<br>6、flatMap</li>
<li>函数功能：扁平化流，将多个流合并成一个流</li>
<li>操作类型：中间操作</li>
<li>返回类型：Stream<R></li>
<li>函数式接口：Function&lt;T, Stream<R>&gt;</li>
<li>函数描述符：T -&gt; Stream<R><br>7、sorted</li>
<li>函数功能：排序</li>
<li>操作类型：中间操作</li>
<li>返回类型：Stream<T></li>
<li>函数式接口：Comparator<T></li>
<li>函数描述符：(T,T) -&gt; int<br>8、anyMatch</li>
<li>函数功能：流中任意一个匹配则返回true</li>
<li>操作类型：终端操作</li>
<li>返回类型：boolean</li>
<li>函数式接口：Predicate<T></li>
<li>函数描述符：T -&gt; boolean<br>9、allMatch</li>
<li>函数功能：流中全部元素匹配则返回true</li>
<li>操作类型：终端操作</li>
<li>返回类型：boolean</li>
<li>函数式接口：Predicate<T></li>
<li>函数描述符：T -&gt; boolean<br>10、 noneMatch</li>
<li>函数功能：流中所有元素都不匹配则返回true</li>
<li>操作类型：终端操作</li>
<li>返回类型：boolean</li>
<li>函数式接口：Predicate<T></li>
<li>函数描述符：T -&gt; boolean<br>11、findAny</li>
<li>函数功能：从流中任意返回一个元素</li>
<li>操作类型：终端操作</li>
<li>返回类型：Optional<T><br>12、findFirst</li>
<li>函数功能：返回流中第一个元素</li>
<li>操作类型：终端操作</li>
<li>返回类型：Optional<T><br>13、forEach</li>
<li>函数功能：遍历流</li>
<li>操作类型：终端操作</li>
<li>返回类型：void</li>
<li>函数式接口：Consumer<T></li>
<li>函数描述符：T -&gt; void<br>14、collect</li>
<li>函数功能：将流进行转换</li>
<li>操作类型：终端操作</li>
<li>返回类型：R</li>
<li>函数式接口：Collector&lt;T,A,R&gt;</li>
</ul>
<p>15、reduce</p>
<ul>
<li><p>函数功能：规约流</p>
</li>
<li><p>操作类型：终端操作 </p>
</li>
<li><p>返回类型：Optional<T></p>
</li>
<li><p>函数式接口：BinaryOperator<T></p>
</li>
<li><p>函数描述符：(T,T) -&gt; T</p>
<p>16、count</p>
</li>
<li><p>函数功能：返回流中总元素个数</p>
</li>
<li><p>操作类型：终端操作</p>
</li>
<li><p>返回类型：long</p>
</li>
</ul>
<p>由于篇幅的原因，流的基本计算就介绍到这里了，下文还将重点介绍流的创建，数值流与Optional类的使用。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/09/%E5%88%9D%E8%AF%86Stream%E3%80%81%E6%B5%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E6%B5%81%E8%AE%A1%E7%AE%97%EF%BC%89/" data-id="ckiibfotq0059pkrg9p2i3y87" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java8-Lambda-%E6%B5%81%E8%AE%A1%E7%AE%97/" rel="tag">java8 Lambda 流计算</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/12/09/%E6%95%B0%E5%80%BC%E6%B5%81%E3%80%81Stream%E5%88%9B%E5%BB%BA%E4%B8%8EOptional%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          数值流、Stream创建与Optional类的使用
        
      </div>
    </a>
  
  
    <a href="/2020/12/09/%E5%A4%8D%E5%90%88Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">复合Lambda表达式</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java8/">java8</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka-rocketmq/">kafka rocketmq</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mybatis/">mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/rocketmq/">rocketmq</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/sentinel/">sentinel</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F-%E9%80%86%E8%A2%AD-%E8%81%8C%E5%9C%BA%E5%8F%91%E5%B1%95/">程序人生 逆袭 职场发展</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-reference/" rel="tag">java reference</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-%E7%AE%97%E6%B3%95/" rel="tag">java 算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java8-Lambda-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag">java8 Lambda 函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java8-Lambda-%E6%B5%81%E8%AE%A1%E7%AE%97/" rel="tag">java8 Lambda 流计算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka-rocketmq/" rel="tag">kafka rocketmq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rocketmq/" rel="tag">rocketmq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rocketmq-broker-busy-TIMEOUT-CLEAN-QUEUE-PCBUSY-CLEAN-QUEUE/" rel="tag">rocketmq broker busy TIMEOUT_CLEAN_QUEUE PCBUSY_CLEAN_QUEUE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rocketmq-%E4%B8%BB%E9%A2%98%E6%89%A9%E5%AE%B9-%E5%AE%9E%E6%88%98-%E5%9D%91/" rel="tag">rocketmq 主题扩容 实战 坑</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rocketmq-%E5%A4%9A%E5%89%AF%E6%9C%AC-raft-%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2/" rel="tag">rocketmq 多副本 raft 主从切换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rocketmq-%E5%A4%9A%E5%89%AF%E6%9C%AC-raft-%E9%80%89%E4%B8%BB/" rel="tag">rocketmq 多副本 raft 选主</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sentinel/" rel="tag">sentinel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/" rel="tag">程序人生</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/java-reference/" style="font-size: 10px;">java reference</a> <a href="/tags/java-%E7%AE%97%E6%B3%95/" style="font-size: 12px;">java 算法</a> <a href="/tags/java8-Lambda-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 12px;">java8 Lambda 函数式编程</a> <a href="/tags/java8-Lambda-%E6%B5%81%E8%AE%A1%E7%AE%97/" style="font-size: 14px;">java8 Lambda 流计算</a> <a href="/tags/kafka-rocketmq/" style="font-size: 10px;">kafka rocketmq</a> <a href="/tags/mybatis/" style="font-size: 16px;">mybatis</a> <a href="/tags/rocketmq/" style="font-size: 20px;">rocketmq</a> <a href="/tags/rocketmq-broker-busy-TIMEOUT-CLEAN-QUEUE-PCBUSY-CLEAN-QUEUE/" style="font-size: 10px;">rocketmq broker busy TIMEOUT_CLEAN_QUEUE PCBUSY_CLEAN_QUEUE</a> <a href="/tags/rocketmq-%E4%B8%BB%E9%A2%98%E6%89%A9%E5%AE%B9-%E5%AE%9E%E6%88%98-%E5%9D%91/" style="font-size: 10px;">rocketmq 主题扩容 实战 坑</a> <a href="/tags/rocketmq-%E5%A4%9A%E5%89%AF%E6%9C%AC-raft-%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2/" style="font-size: 10px;">rocketmq 多副本 raft 主从切换</a> <a href="/tags/rocketmq-%E5%A4%9A%E5%89%AF%E6%9C%AC-raft-%E9%80%89%E4%B8%BB/" style="font-size: 10px;">rocketmq 多副本 raft 选主</a> <a href="/tags/sentinel/" style="font-size: 18px;">sentinel</a> <a href="/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/" style="font-size: 10px;">程序人生</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/12/09/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95java%E7%89%88%E5%AE%9E%E7%8E%B0/">快速排序算法java版实现</a>
          </li>
        
          <li>
            <a href="/2020/12/09/%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91JAVA%E7%89%88%E5%AE%9E%E7%8E%B0/">排序二叉树JAVA版实现</a>
          </li>
        
          <li>
            <a href="/2020/12/09/java%20Reference%20%E5%BC%95%E7%94%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">java Reference 引用学习总结</a>
          </li>
        
          <li>
            <a href="/2020/12/09/Mybatis%E4%B8%80%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">Mybatis一二级缓存实现原理与使用指南</a>
          </li>
        
          <li>
            <a href="/2020/12/09/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90Mybatis%E6%8F%92%E4%BB%B6(Plugin)%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%AE%9E%E6%88%98/">源码分析Mybatis插件(Plugin)机制与实战</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 中间件兴趣圈<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>